<html xmlns="http://www.w3.org/1999/xhtml"><head><title>clojure.clr.io - Clojure-clr v1.3 API Documentation</title><link href="http://clojure.github.com/clojure/static/favicon.png" rel="shortcut icon"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/clojure.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/wiki.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/internal.css" rel="stylesheet"/><link media="all" type="text/css" href="/css/clr.css" rel="stylesheet"/></head><style>.shortcuts a { margin-right: .5em; }</style><body><div id="AllContentContainer"><div id="Header"><a id="Logo" href="index.html"><img alt="Clojure-clr" height="100" width="100" src="http://richhickey.github.com/clojure-contrib/static/clojure-icon.gif"/></a><h1><a title="page header title" id="page-header" href="index.html">Clojure-clr API Reference</a></h1></div><div id="leftcolumn"><div/><div class="menu"><div class="WikiCustomNav WikiElement wiki"><span class="toc-header"><span id="project-name">Clojure-clr v</span><span id="version">1.3</span></span><br/><ul><li><a class="wiki_link" href="index.html">Overview</a></li><li><a class="wiki_link" href="api-index.html">API Index</a></li></ul><div class="NamespaceTOC"><span class="toc-header">Namespaces</span><ul id="left-sidebar-list"><li><a href="clojure.clr.io.html" class="wiki_link">clojure.clr.io</a></li><li><a href="clojure.clr.shell.html" class="wiki_link">clojure.clr.shell</a></li><li><a href="clojure.contrib.gen-html-docs.html" class="wiki_link">clojure.contrib.gen-html-docs</a></li><li><a href="clojure.core.html" class="wiki_link">clojure.core</a></li><li><a href="clojure.pprint.html" class="wiki_link">clojure.pprint</a></li><li><a href="clojure.reflect.html" class="wiki_link">clojure.reflect</a></li><li><a href="clojure.string.html" class="wiki_link">clojure.string</a></li><li><a href="clojure.test-helper.html" class="wiki_link">clojure.test-helper</a></li></ul></div></div></div></div></div><div id="rightcolumn"><div id="Content"><div class="contentBox"><div class="innerContentBox"><div id="content_view" class="wiki wikiPage"><div id="right-sidebar"/><div id="content-tag"><h1 Id="overview">Index of Public Functions and Variables - Clojure-clr v1.3</h1><p>This page has an alphabetical index of all the documented functions and variables in Clojure.
Shortcuts</p><div class="shortcuts">Shortcuts: <br/><a href="#A">A</a><a href="#B">B</a><a href="#C">C</a><a href="#D">D</a><a href="#E">E</a><a href="#F">F</a><a href="#G">G</a><a href="#H">H</a><a href="#I">I</a><a href="#J">J</a><a href="#K">K</a><a href="#L">L</a><a href="#M">M</a><a href="#N">N</a><a href="#O">O</a><a href="#P">P</a><a href="#Q">Q</a><a href="#R">R</a><a href="#S">S</a><a href="#T">T</a><a href="#U">U</a><a href="#V">V</a><a href="#W">W</a><a href="#X">X</a><a href="#Y">Y</a><a href="#Z">Z</a><a href="#other">Other</a></div><div id="index-body"><table><thead><tr><th colspan="3" id="A">A</th></tr></thead><tr name="#&apos;clojure.core/accessor"><td id="section-content"><a href="clojure.core.html#clojure.core/accessor">accessor</a></td><td>    fn</td><td>clojure.core</td><td>Returns a fn that, given an instance of a struc...</td></tr><tr name="#&apos;clojure.core/aclone"><td id="section-content"><a href="clojure.core.html#clojure.core/aclone">aclone</a></td><td>    fn</td><td>clojure.core</td><td>Returns a clone of the Java array. Works on arr...</td></tr><tr name="#&apos;clojure.core/add-watch"><td id="section-content"><a href="clojure.core.html#clojure.core/add-watch">add-watch</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Adds a watch funct...</td></tr><tr name="#&apos;clojure.core/agent"><td id="section-content"><a href="clojure.core.html#clojure.core/agent">agent</a></td><td>    fn</td><td>clojure.core</td><td>Creates and returns an agent with an initial va...</td></tr><tr name="#&apos;clojure.core/agent-error"><td id="section-content"><a href="clojure.core.html#clojure.core/agent-error">agent-error</a></td><td>    fn</td><td>clojure.core</td><td>Returns the exception thrown during an asynchro...</td></tr><tr name="#&apos;clojure.core/agent-errors"><td id="section-content"><a href="clojure.core.html#clojure.core/agent-errors">agent-errors</a></td><td>    fn</td><td>clojure.core</td><td>DEPRECATED: Use &apos;agent-error&apos; instead.
  Return...</td></tr><tr name="#&apos;clojure.core/aget"><td id="section-content"><a href="clojure.core.html#clojure.core/aget">aget</a></td><td>    fn</td><td>clojure.core</td><td>Returns the value at the index/indices. Works o...</td></tr><tr name="#&apos;clojure.core/alength"><td id="section-content"><a href="clojure.core.html#clojure.core/alength">alength</a></td><td>    fn</td><td>clojure.core</td><td>Returns the length of the Java array. Works on ...</td></tr><tr name="#&apos;clojure.core/alias"><td id="section-content"><a href="clojure.core.html#clojure.core/alias">alias</a></td><td>    fn</td><td>clojure.core</td><td>Add an alias in the current namespace to anothe...</td></tr><tr name="#&apos;clojure.core/all-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/all-ns">all-ns</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sequence of all namespaces.</td></tr><tr name="#&apos;clojure.core/alter"><td id="section-content"><a href="clojure.core.html#clojure.core/alter">alter</a></td><td>    fn</td><td>clojure.core</td><td>Must be called in a transaction. Sets the in-tr...</td></tr><tr name="#&apos;clojure.core/alter-meta!"><td id="section-content"><a href="clojure.core.html#clojure.core/alter-meta!">alter-meta!</a></td><td>    fn</td><td>clojure.core</td><td>Atomically sets the metadata for a namespace/va...</td></tr><tr name="#&apos;clojure.core/alter-var-root"><td id="section-content"><a href="clojure.core.html#clojure.core/alter-var-root">alter-var-root</a></td><td>    fn</td><td>clojure.core</td><td>Atomically alters the root binding of var v by ...</td></tr><tr name="#&apos;clojure.core/amap"><td id="section-content"><a href="clojure.core.html#clojure.core/amap">amap</a></td><td>    macro</td><td>clojure.core</td><td>Maps an expression across an array a, using an ...</td></tr><tr name="#&apos;clojure.core/ancestors"><td id="section-content"><a href="clojure.core.html#clojure.core/ancestors">ancestors</a></td><td>    fn</td><td>clojure.core</td><td>Returns the immediate and indirect parents of t...</td></tr><tr name="#&apos;clojure.core/and"><td id="section-content"><a href="clojure.core.html#clojure.core/and">and</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates exprs one at a time, from left to rig...</td></tr><tr name="#&apos;clojure.core/apply"><td id="section-content"><a href="clojure.core.html#clojure.core/apply">apply</a></td><td>    fn</td><td>clojure.core</td><td>Applies fn f to the argument list formed by pre...</td></tr><tr name="#&apos;clojure.core/areduce"><td id="section-content"><a href="clojure.core.html#clojure.core/areduce">areduce</a></td><td>    macro</td><td>clojure.core</td><td>Reduces an expression across an array a, using ...</td></tr><tr name="#&apos;clojure.core/array?"><td id="section-content"><a href="clojure.core.html#clojure.core/array?">array?</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/array-map"><td id="section-content"><a href="clojure.core.html#clojure.core/array-map">array-map</a></td><td>    fn</td><td>clojure.core</td><td>Constructs an array-map.</td></tr><tr name="#&apos;clojure.core/aset"><td id="section-content"><a href="clojure.core.html#clojure.core/aset">aset</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on J...</td></tr><tr name="#&apos;clojure.core/aset-boolean"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-boolean">aset-boolean</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-byte"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-byte">aset-byte</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-char"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-char">aset-char</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-decimal"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-decimal">aset-decimal</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-double"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-double">aset-double</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-float"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-float">aset-float</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-int"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-int">aset-int</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-long"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-long">aset-long</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-sbyte"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-sbyte">aset-sbyte</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-short"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-short">aset-short</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-uint"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-uint">aset-uint</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-ulong"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-ulong">aset-ulong</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.core/aset-ushort"><td id="section-content"><a href="clojure.core.html#clojure.core/aset-ushort">aset-ushort</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value at the index/indices. Works on a...</td></tr><tr name="#&apos;clojure.clr.io/as-file"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/as-file">as-file</a></td><td>    fn</td><td>clojure.clr.io</td><td>Coerce argument to a file.</td></tr><tr name="#&apos;clojure.core/assembly-load"><td id="section-content"><a href="clojure.core.html#clojure.core/assembly-load">assembly-load</a></td><td>    fn</td><td>clojure.core</td><td>Load an assembly given its name</td></tr><tr name="#&apos;clojure.core/assembly-load-file"><td id="section-content"><a href="clojure.core.html#clojure.core/assembly-load-file">assembly-load-file</a></td><td>    fn</td><td>clojure.core</td><td>Load an assembly given its name</td></tr><tr name="#&apos;clojure.core/assembly-load-from"><td id="section-content"><a href="clojure.core.html#clojure.core/assembly-load-from">assembly-load-from</a></td><td>    fn</td><td>clojure.core</td><td>Load an assembly given its path</td></tr><tr name="#&apos;clojure.core/assert"><td id="section-content"><a href="clojure.core.html#clojure.core/assert">assert</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates expr and throws an exception if it do...</td></tr><tr name="#&apos;clojure.core/assoc"><td id="section-content"><a href="clojure.core.html#clojure.core/assoc">assoc</a></td><td>    fn</td><td>clojure.core</td><td>assoc[iate]. When applied to a map, returns a n...</td></tr><tr name="#&apos;clojure.core/assoc!"><td id="section-content"><a href="clojure.core.html#clojure.core/assoc!">assoc!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  When applied to a ...</td></tr><tr name="#&apos;clojure.core/associative?"><td id="section-content"><a href="clojure.core.html#clojure.core/associative?">associative?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll implements Associative</td></tr><tr name="#&apos;clojure.core/assoc-in"><td id="section-content"><a href="clojure.core.html#clojure.core/assoc-in">assoc-in</a></td><td>    fn</td><td>clojure.core</td><td>Associates a value in a nested associative stru...</td></tr><tr name="#&apos;clojure.clr.io/as-uri"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/as-uri">as-uri</a></td><td>    fn</td><td>clojure.clr.io</td><td>Coerce argument to a URI.</td></tr><tr name="#&apos;clojure.core/atom"><td id="section-content"><a href="clojure.core.html#clojure.core/atom">atom</a></td><td>    fn</td><td>clojure.core</td><td>Creates and returns an Atom with an initial val...</td></tr><tr name="#&apos;clojure.core/await"><td id="section-content"><a href="clojure.core.html#clojure.core/await">await</a></td><td>    fn</td><td>clojure.core</td><td>Blocks the current thread (indefinitely!) until...</td></tr><tr name="#&apos;clojure.core/await1"><td id="section-content"><a href="clojure.core.html#clojure.core/await1">await1</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/await-for"><td id="section-content"><a href="clojure.core.html#clojure.core/await-for">await-for</a></td><td>    fn</td><td>clojure.core</td><td>Blocks the current thread until all actions dis...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="B">B</th></tr></thead><tr name="#&apos;clojure.core/bases"><td id="section-content"><a href="clojure.core.html#clojure.core/bases">bases</a></td><td>    fn</td><td>clojure.core</td><td>Returns the immediate superclass and direct int...</td></tr><tr name="#&apos;clojure.core/bigdec"><td id="section-content"><a href="clojure.core.html#clojure.core/bigdec">bigdec</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to BigDecimal</td></tr><tr name="#&apos;clojure.core/bigint"><td id="section-content"><a href="clojure.core.html#clojure.core/bigint">bigint</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to BigInt</td></tr><tr name="#&apos;clojure.core/biginteger"><td id="section-content"><a href="clojure.core.html#clojure.core/biginteger">biginteger</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to BigInteger</td></tr><tr name="#&apos;clojure.clr.io/binary-reader"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/binary-reader">binary-reader</a></td><td>    fn</td><td>clojure.clr.io</td><td>Attempt to coerce its argument into an open Sys...</td></tr><tr name="#&apos;clojure.clr.io/binary-writer"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/binary-writer">binary-writer</a></td><td>    fn</td><td>clojure.clr.io</td><td>Attempt to coerce its argument into an open Sys...</td></tr><tr name="#&apos;clojure.core/binding"><td id="section-content"><a href="clojure.core.html#clojure.core/binding">binding</a></td><td>    macro</td><td>clojure.core</td><td>binding =&gt; var-symbol init-expr

  Creates new ...</td></tr><tr name="#&apos;clojure.core/bit-and"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-and">bit-and</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise and</td></tr><tr name="#&apos;clojure.core/bit-and-not"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-and-not">bit-and-not</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise and with complement</td></tr><tr name="#&apos;clojure.core/bit-clear"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-clear">bit-clear</a></td><td>    fn</td><td>clojure.core</td><td>Clear bit at index n</td></tr><tr name="#&apos;clojure.core/bit-flip"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-flip">bit-flip</a></td><td>    fn</td><td>clojure.core</td><td>Flip bit at index n</td></tr><tr name="#&apos;clojure.core/bit-not"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-not">bit-not</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise complement</td></tr><tr name="#&apos;clojure.core/bit-or"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-or">bit-or</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise or</td></tr><tr name="#&apos;clojure.core/bit-set"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-set">bit-set</a></td><td>    fn</td><td>clojure.core</td><td>Set bit at index n</td></tr><tr name="#&apos;clojure.core/bit-shift-left"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-shift-left">bit-shift-left</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise shift left</td></tr><tr name="#&apos;clojure.core/bit-shift-right"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-shift-right">bit-shift-right</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise shift right</td></tr><tr name="#&apos;clojure.core/bit-test"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-test">bit-test</a></td><td>    fn</td><td>clojure.core</td><td>Test bit at index n</td></tr><tr name="#&apos;clojure.core/bit-xor"><td id="section-content"><a href="clojure.core.html#clojure.core/bit-xor">bit-xor</a></td><td>    fn</td><td>clojure.core</td><td>Bitwise exclusive or</td></tr><tr name="#&apos;clojure.string/blank?"><td id="section-content"><a href="clojure.string.html#clojure.string/blank?">blank?</a></td><td>    fn</td><td>clojure.string</td><td>True if s is nil, empty, or contains only white...</td></tr><tr name="#&apos;clojure.core/boolean"><td id="section-content"><a href="clojure.core.html#clojure.core/boolean">boolean</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to boolean</td></tr><tr name="#&apos;clojure.core/boolean-array"><td id="section-content"><a href="clojure.core.html#clojure.core/boolean-array">boolean-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of booleans</td></tr><tr name="#&apos;clojure.core/booleans"><td id="section-content"><a href="clojure.core.html#clojure.core/booleans">booleans</a></td><td>    fn</td><td>clojure.core</td><td>Casts to boolean[]</td></tr><tr name="#&apos;clojure.core/bound?"><td id="section-content"><a href="clojure.core.html#clojure.core/bound?">bound?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if all of the vars provided as arg...</td></tr><tr name="#&apos;clojure.core/bound-fn"><td id="section-content"><a href="clojure.core.html#clojure.core/bound-fn">bound-fn</a></td><td>    macro</td><td>clojure.core</td><td>Returns a function defined by the given fntail,...</td></tr><tr name="#&apos;clojure.core/bound-fn*"><td id="section-content"><a href="clojure.core.html#clojure.core/bound-fn*">bound-fn*</a></td><td>    fn</td><td>clojure.core</td><td>Returns a function, which will install the same...</td></tr><tr name="#&apos;clojure.core/butlast"><td id="section-content"><a href="clojure.core.html#clojure.core/butlast">butlast</a></td><td>    fn</td><td>clojure.core</td><td>Return a seq of all but the last item in coll, ...</td></tr><tr name="#&apos;clojure.core/by-ref"><td id="section-content"><a href="clojure.core.html#clojure.core/by-ref">by-ref</a></td><td>    fn</td><td>clojure.core</td><td>Signals that a by-ref parameter is desired at t...</td></tr><tr name="#&apos;clojure.core/byte"><td id="section-content"><a href="clojure.core.html#clojure.core/byte">byte</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to byte</td></tr><tr name="#&apos;clojure.core/byte-array"><td id="section-content"><a href="clojure.core.html#clojure.core/byte-array">byte-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of bytes</td></tr><tr name="#&apos;clojure.core/bytes"><td id="section-content"><a href="clojure.core.html#clojure.core/bytes">bytes</a></td><td>    fn</td><td>clojure.core</td><td>Casts to bytes[]</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="*">*</th></tr></thead><tr name="#&apos;clojure.core/*clojure-version*"><td id="section-content"><a href="clojure.core.html#clojure.core/*clojure-version*">*clojure-version*</a></td><td>    var</td><td>clojure.core</td><td>The version info for Clojure core, as a map con...</td></tr><tr name="#&apos;clojure.core/*command-line-args*"><td id="section-content"><a href="clojure.core.html#clojure.core/*command-line-args*">*command-line-args*</a></td><td>    var</td><td>clojure.core</td><td>A sequence of the supplied command line argumen...</td></tr><tr name="#&apos;clojure.core/*compile-files*"><td id="section-content"><a href="clojure.core.html#clojure.core/*compile-files*">*compile-files*</a></td><td>    var</td><td>clojure.core</td><td>Set to true when compiling files, false otherwi...</td></tr><tr name="#&apos;clojure.core/*compile-path*"><td id="section-content"><a href="clojure.core.html#clojure.core/*compile-path*">*compile-path*</a></td><td>    var</td><td>clojure.core</td><td>Specifies the directory where &apos;compile&apos; will wr...</td></tr><tr name="#&apos;clojure.reflect/-&gt;ClrReflector"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/-&gt;ClrReflector">-&gt;ClrReflector</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.reflect/-&gt;Constructor"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/-&gt;Constructor">-&gt;Constructor</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/-cache-protocol-fn"><td id="section-content"><a href="clojure.core.html#clojure.core/-cache-protocol-fn">-cache-protocol-fn</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.string/capitalize"><td id="section-content"><a href="clojure.string.html#clojure.string/capitalize">capitalize</a></td><td>    fn</td><td>clojure.string</td><td>Converts first character of the string to upper...</td></tr><tr name="#&apos;clojure.core/case"><td id="section-content"><a href="clojure.core.html#clojure.core/case">case</a></td><td>    macro</td><td>clojure.core</td><td>Takes an expression, and a set of clauses.

  E...</td></tr><tr name="#&apos;clojure.core/cast"><td id="section-content"><a href="clojure.core.html#clojure.core/cast">cast</a></td><td>    fn</td><td>clojure.core</td><td>Throws a ClassCastException if x is not a c, el...</td></tr><tr name="#&apos;clojure.test-helper/causes"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/causes">causes</a></td><td>    fn</td><td>clojure.test-helper</td><td></td></tr><tr name="#&apos;clojure.core/char"><td id="section-content"><a href="clojure.core.html#clojure.core/char">char</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to char</td></tr><tr name="#&apos;clojure.core/char?"><td id="section-content"><a href="clojure.core.html#clojure.core/char?">char?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x is a Character</td></tr><tr name="#&apos;clojure.core/char-array"><td id="section-content"><a href="clojure.core.html#clojure.core/char-array">char-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of chars</td></tr><tr name="#&apos;clojure.core/char-escape-string"><td id="section-content"><a href="clojure.core.html#clojure.core/char-escape-string">char-escape-string</a></td><td>    var</td><td>clojure.core</td><td>Returns escape string for char or nil if none</td></tr><tr name="#&apos;clojure.core/char-name-string"><td id="section-content"><a href="clojure.core.html#clojure.core/char-name-string">char-name-string</a></td><td>    var</td><td>clojure.core</td><td>Returns name string for char or nil if none</td></tr><tr name="#&apos;clojure.core/chars"><td id="section-content"><a href="clojure.core.html#clojure.core/chars">chars</a></td><td>    fn</td><td>clojure.core</td><td>Casts to chars[]</td></tr><tr name="#&apos;clojure.core/chunk"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk">chunk</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-append"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-append">chunk-append</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-buffer"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-buffer">chunk-buffer</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-cons"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-cons">chunk-cons</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunked-seq?"><td id="section-content"><a href="clojure.core.html#clojure.core/chunked-seq?">chunked-seq?</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-first"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-first">chunk-first</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-next"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-next">chunk-next</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/chunk-rest"><td id="section-content"><a href="clojure.core.html#clojure.core/chunk-rest">chunk-rest</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/class"><td id="section-content"><a href="clojure.core.html#clojure.core/class">class</a></td><td>    fn</td><td>clojure.core</td><td>Returns the Class of x</td></tr><tr name="#&apos;clojure.core/class?"><td id="section-content"><a href="clojure.core.html#clojure.core/class?">class?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is an instance of Class</td></tr><tr name="#&apos;clojure.reflect/class-flags"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/class-flags">class-flags</a></td><td>    var</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/clear-agent-errors"><td id="section-content"><a href="clojure.core.html#clojure.core/clear-agent-errors">clear-agent-errors</a></td><td>    fn</td><td>clojure.core</td><td>DEPRECATED: Use &apos;restart-agent&apos; instead.
  Clea...</td></tr><tr name="#&apos;clojure.pprint/cl-format"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/cl-format">cl-format</a></td><td>    fn</td><td>clojure.pprint</td><td>An implementation of a Common Lisp compatible f...</td></tr><tr name="#&apos;clojure.core/clojure-version"><td id="section-content"><a href="clojure.core.html#clojure.core/clojure-version">clojure-version</a></td><td>    fn</td><td>clojure.core</td><td>Returns clojure version as a printable string.</td></tr><tr name="#&apos;clojure.pprint/code-dispatch"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/code-dispatch">code-dispatch</a></td><td>    var</td><td>clojure.pprint</td><td>The pretty print dispatch function for pretty p...</td></tr><tr name="#&apos;clojure.clr.io/Coercions"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/Coercions">Coercions</a></td><td>    var</td><td>clojure.clr.io</td><td>Coerce between various &apos;resource-namish&apos; things...</td></tr><tr name="#&apos;clojure.core/coll?"><td id="section-content"><a href="clojure.core.html#clojure.core/coll?">coll?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x implements IPersistentCollect...</td></tr><tr name="#&apos;clojure.core/comment"><td id="section-content"><a href="clojure.core.html#clojure.core/comment">comment</a></td><td>    macro</td><td>clojure.core</td><td>Ignores body, yields nil</td></tr><tr name="#&apos;clojure.core/commute"><td id="section-content"><a href="clojure.core.html#clojure.core/commute">commute</a></td><td>    fn</td><td>clojure.core</td><td>Must be called in a transaction. Sets the in-tr...</td></tr><tr name="#&apos;clojure.core/comp"><td id="section-content"><a href="clojure.core.html#clojure.core/comp">comp</a></td><td>    fn</td><td>clojure.core</td><td>Takes a set of functions and returns a fn that ...</td></tr><tr name="#&apos;clojure.core/comparator"><td id="section-content"><a href="clojure.core.html#clojure.core/comparator">comparator</a></td><td>    fn</td><td>clojure.core</td><td>Returns an implementation of java.util.Comparat...</td></tr><tr name="#&apos;clojure.core/compare"><td id="section-content"><a href="clojure.core.html#clojure.core/compare">compare</a></td><td>    fn</td><td>clojure.core</td><td>Comparator. Returns a negative number, zero, or...</td></tr><tr name="#&apos;clojure.core/compare-and-set!"><td id="section-content"><a href="clojure.core.html#clojure.core/compare-and-set!">compare-and-set!</a></td><td>    fn</td><td>clojure.core</td><td>Atomically sets the value of atom to newval if ...</td></tr><tr name="#&apos;clojure.core/compile"><td id="section-content"><a href="clojure.core.html#clojure.core/compile">compile</a></td><td>    fn</td><td>clojure.core</td><td>Compiles the namespace named by the symbol lib ...</td></tr><tr name="#&apos;clojure.core/complement"><td id="section-content"><a href="clojure.core.html#clojure.core/complement">complement</a></td><td>    fn</td><td>clojure.core</td><td>Takes a fn f and returns a fn that takes the sa...</td></tr><tr name="#&apos;clojure.core/concat"><td id="section-content"><a href="clojure.core.html#clojure.core/concat">concat</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq representing the concatenati...</td></tr><tr name="#&apos;clojure.core/cond"><td id="section-content"><a href="clojure.core.html#clojure.core/cond">cond</a></td><td>    macro</td><td>clojure.core</td><td>Takes a set of test/expr pairs. It evaluates ea...</td></tr><tr name="#&apos;clojure.core/condp"><td id="section-content"><a href="clojure.core.html#clojure.core/condp">condp</a></td><td>    macro</td><td>clojure.core</td><td>Takes a binary predicate, an expression, and a ...</td></tr><tr name="#&apos;clojure.core/conj"><td id="section-content"><a href="clojure.core.html#clojure.core/conj">conj</a></td><td>    fn</td><td>clojure.core</td><td>conj[oin]. Returns a new collection with the xs...</td></tr><tr name="#&apos;clojure.core/conj!"><td id="section-content"><a href="clojure.core.html#clojure.core/conj!">conj!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Adds x to the tran...</td></tr><tr name="#&apos;clojure.core/cons"><td id="section-content"><a href="clojure.core.html#clojure.core/cons">cons</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new seq where x is the first element ...</td></tr><tr name="#&apos;clojure.core/constantly"><td id="section-content"><a href="clojure.core.html#clojure.core/constantly">constantly</a></td><td>    fn</td><td>clojure.core</td><td>Returns a function that takes any number of arg...</td></tr><tr name="#&apos;clojure.core/construct-proxy"><td id="section-content"><a href="clojure.core.html#clojure.core/construct-proxy">construct-proxy</a></td><td>    fn</td><td>clojure.core</td><td>Takes a proxy class and any arguments for its s...</td></tr><tr name="#&apos;clojure.core/contains?"><td id="section-content"><a href="clojure.core.html#clojure.core/contains?">contains?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if key is present in the given col...</td></tr><tr name="#&apos;clojure.clr.io/copy"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/copy">copy</a></td><td>    fn</td><td>clojure.clr.io</td><td>Copies input to output.  Returns nil or throws ...</td></tr><tr name="#&apos;clojure.core/count"><td id="section-content"><a href="clojure.core.html#clojure.core/count">count</a></td><td>    fn</td><td>clojure.core</td><td>Returns the number of items in the collection. ...</td></tr><tr name="#&apos;clojure.core/counted?"><td id="section-content"><a href="clojure.core.html#clojure.core/counted?">counted?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll implements count in consta...</td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/create-api-func-desc"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/create-api-func-desc">create-api-func-desc</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/create-api-func-row"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/create-api-func-row">create-api-func-row</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.core/create-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/create-ns">create-ns</a></td><td>    fn</td><td>clojure.core</td><td>Create a new namespace named by the symbol if o...</td></tr><tr name="#&apos;clojure.core/create-struct"><td id="section-content"><a href="clojure.core.html#clojure.core/create-struct">create-struct</a></td><td>    fn</td><td>clojure.core</td><td>Returns a structure basis object.</td></tr><tr name="#&apos;clojure.core/cycle"><td id="section-content"><a href="clojure.core.html#clojure.core/cycle">cycle</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy (infinite!) sequence of repetiti...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="D">D</th></tr></thead><tr name="#&apos;clojure.core/dec"><td id="section-content"><a href="clojure.core.html#clojure.core/dec">dec</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one less than num. Does not au...</td></tr><tr name="#&apos;clojure.core/dec&apos;"><td id="section-content"><a href="clojure.core.html#clojure.core/dec">dec</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one less than num.  Supports a...</td></tr><tr name="#&apos;clojure.core/decimal"><td id="section-content"><a href="clojure.core.html#clojure.core/decimal">decimal</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to decimal</td></tr><tr name="#&apos;clojure.core/decimal?"><td id="section-content"><a href="clojure.core.html#clojure.core/decimal?">decimal?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is a BigDecimal</td></tr><tr name="#&apos;clojure.core/declare"><td id="section-content"><a href="clojure.core.html#clojure.core/declare">declare</a></td><td>    macro</td><td>clojure.core</td><td>defs the supplied var names with no bindings, u...</td></tr><tr name="#&apos;clojure.clr.io/default-streams-impl"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/default-streams-impl">default-streams-impl</a></td><td>    var</td><td>clojure.clr.io</td><td></td></tr><tr name="#&apos;clojure.core/definline"><td id="section-content"><a href="clojure.core.html#clojure.core/definline">definline</a></td><td>    macro</td><td>clojure.core</td><td>Experimental - like defmacro, except defines a ...</td></tr><tr name="#&apos;clojure.core/definterface"><td id="section-content"><a href="clojure.core.html#clojure.core/definterface">definterface</a></td><td>    macro</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/defmacro"><td id="section-content"><a href="clojure.core.html#clojure.core/defmacro">defmacro</a></td><td>    macro</td><td>clojure.core</td><td>Like defn, but the resulting function name is d...</td></tr><tr name="#&apos;clojure.core/defmethod"><td id="section-content"><a href="clojure.core.html#clojure.core/defmethod">defmethod</a></td><td>    macro</td><td>clojure.core</td><td>Creates and installs a new method of multimetho...</td></tr><tr name="#&apos;clojure.core/defmulti"><td id="section-content"><a href="clojure.core.html#clojure.core/defmulti">defmulti</a></td><td>    macro</td><td>clojure.core</td><td>Creates a new multimethod with the associated d...</td></tr><tr name="#&apos;clojure.core/defn"><td id="section-content"><a href="clojure.core.html#clojure.core/defn">defn</a></td><td>    macro</td><td>clojure.core</td><td>Same as (def name (fn [params* ] exprs*)) or (d...</td></tr><tr name="#&apos;clojure.core/defn-"><td id="section-content"><a href="clojure.core.html#clojure.core/defn-">defn-</a></td><td>    macro</td><td>clojure.core</td><td>same as defn, yielding non-public def</td></tr><tr name="#&apos;clojure.core/defonce"><td id="section-content"><a href="clojure.core.html#clojure.core/defonce">defonce</a></td><td>    macro</td><td>clojure.core</td><td>defs name to have the root value of the expr if...</td></tr><tr name="#&apos;clojure.core/defprotocol"><td id="section-content"><a href="clojure.core.html#clojure.core/defprotocol">defprotocol</a></td><td>    macro</td><td>clojure.core</td><td>A protocol is a named set of named methods and ...</td></tr><tr name="#&apos;clojure.core/defrecord"><td id="section-content"><a href="clojure.core.html#clojure.core/defrecord">defrecord</a></td><td>    macro</td><td>clojure.core</td><td>Alpha - subject to change
  
  (defrecord name ...</td></tr><tr name="#&apos;clojure.core/defstruct"><td id="section-content"><a href="clojure.core.html#clojure.core/defstruct">defstruct</a></td><td>    macro</td><td>clojure.core</td><td>Same as (def name (create-struct keys...))</td></tr><tr name="#&apos;clojure.core/deftype"><td id="section-content"><a href="clojure.core.html#clojure.core/deftype">deftype</a></td><td>    macro</td><td>clojure.core</td><td>Alpha - subject to change
  
  (deftype name [f...</td></tr><tr name="#&apos;clojure.core/delay"><td id="section-content"><a href="clojure.core.html#clojure.core/delay">delay</a></td><td>    macro</td><td>clojure.core</td><td>Takes a body of expressions and yields a Delay ...</td></tr><tr name="#&apos;clojure.core/delay?"><td id="section-content"><a href="clojure.core.html#clojure.core/delay?">delay?</a></td><td>    fn</td><td>clojure.core</td><td>returns true if x is a Delay created with delay</td></tr><tr name="#&apos;clojure.core/deliver"><td id="section-content"><a href="clojure.core.html#clojure.core/deliver">deliver</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Delivers the suppl...</td></tr><tr name="#&apos;clojure.core/denominator"><td id="section-content"><a href="clojure.core.html#clojure.core/denominator">denominator</a></td><td>    fn</td><td>clojure.core</td><td>Returns the denominator part of a Ratio.</td></tr><tr name="#&apos;clojure.core/deref"><td id="section-content"><a href="clojure.core.html#clojure.core/deref">deref</a></td><td>    fn</td><td>clojure.core</td><td>Also reader macro: @ref/@agent/@var/@atom/@dela...</td></tr><tr name="#&apos;clojure.core/derive"><td id="section-content"><a href="clojure.core.html#clojure.core/derive">derive</a></td><td>    fn</td><td>clojure.core</td><td>Establishes a parent/child relationship between...</td></tr><tr name="#&apos;clojure.core/descendants"><td id="section-content"><a href="clojure.core.html#clojure.core/descendants">descendants</a></td><td>    fn</td><td>clojure.core</td><td>Returns the immediate and indirect children of ...</td></tr><tr name="#&apos;clojure.core/destructure"><td id="section-content"><a href="clojure.core.html#clojure.core/destructure">destructure</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/disj"><td id="section-content"><a href="clojure.core.html#clojure.core/disj">disj</a></td><td>    fn</td><td>clojure.core</td><td>disj[oin]. Returns a new set of the same (hashe...</td></tr><tr name="#&apos;clojure.core/disj!"><td id="section-content"><a href="clojure.core.html#clojure.core/disj!">disj!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  disj[oin]. Returns...</td></tr><tr name="#&apos;clojure.core/dissoc"><td id="section-content"><a href="clojure.core.html#clojure.core/dissoc">dissoc</a></td><td>    fn</td><td>clojure.core</td><td>dissoc[iate]. Returns a new map of the same (ha...</td></tr><tr name="#&apos;clojure.core/dissoc!"><td id="section-content"><a href="clojure.core.html#clojure.core/dissoc!">dissoc!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Returns a transien...</td></tr><tr name="#&apos;clojure.core/distinct"><td id="section-content"><a href="clojure.core.html#clojure.core/distinct">distinct</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the elements of coll...</td></tr><tr name="#&apos;clojure.core/distinct?"><td id="section-content"><a href="clojure.core.html#clojure.core/distinct?">distinct?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if no two of the arguments are =</td></tr><tr name="#&apos;clojure.core/doall"><td id="section-content"><a href="clojure.core.html#clojure.core/doall">doall</a></td><td>    fn</td><td>clojure.core</td><td>When lazy sequences are produced via functions ...</td></tr><tr name="#&apos;clojure.reflect/do-reflect"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/do-reflect">do-reflect</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/dorun"><td id="section-content"><a href="clojure.core.html#clojure.core/dorun">dorun</a></td><td>    fn</td><td>clojure.core</td><td>When lazy sequences are produced via functions ...</td></tr><tr name="#&apos;clojure.core/doseq"><td id="section-content"><a href="clojure.core.html#clojure.core/doseq">doseq</a></td><td>    macro</td><td>clojure.core</td><td>Repeatedly executes body (presumably for side-e...</td></tr><tr name="#&apos;clojure.core/dosync"><td id="section-content"><a href="clojure.core.html#clojure.core/dosync">dosync</a></td><td>    macro</td><td>clojure.core</td><td>Runs the exprs (in an implicit do) in a transac...</td></tr><tr name="#&apos;clojure.core/dotimes"><td id="section-content"><a href="clojure.core.html#clojure.core/dotimes">dotimes</a></td><td>    macro</td><td>clojure.core</td><td>bindings =&gt; name n

  Repeatedly executes body ...</td></tr><tr name="#&apos;clojure.core/doto"><td id="section-content"><a href="clojure.core.html#clojure.core/doto">doto</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates x then calls all of the methods and f...</td></tr><tr name="#&apos;clojure.core/double"><td id="section-content"><a href="clojure.core.html#clojure.core/double">double</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to double</td></tr><tr name="#&apos;clojure.core/double-array"><td id="section-content"><a href="clojure.core.html#clojure.core/double-array">double-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of doubles</td></tr><tr name="#&apos;clojure.core/doubles"><td id="section-content"><a href="clojure.core.html#clojure.core/doubles">doubles</a></td><td>    fn</td><td>clojure.core</td><td>Casts to double[]</td></tr><tr name="#&apos;clojure.core/drop"><td id="section-content"><a href="clojure.core.html#clojure.core/drop">drop</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of all but the first n ...</td></tr><tr name="#&apos;clojure.core/drop-last"><td id="section-content"><a href="clojure.core.html#clojure.core/drop-last">drop-last</a></td><td>    fn</td><td>clojure.core</td><td>Return a lazy sequence of all but the last n (d...</td></tr><tr name="#&apos;clojure.core/drop-while"><td id="section-content"><a href="clojure.core.html#clojure.core/drop-while">drop-while</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the items in coll st...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="E">E</th></tr></thead><tr name="#&apos;clojure.core/empty"><td id="section-content"><a href="clojure.core.html#clojure.core/empty">empty</a></td><td>    fn</td><td>clojure.core</td><td>Returns an empty collection of the same categor...</td></tr><tr name="#&apos;clojure.core/empty?"><td id="section-content"><a href="clojure.core.html#clojure.core/empty?">empty?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll has no items - same as (no...</td></tr><tr name="#&apos;clojure.core/EMPTY-NODE"><td id="section-content"><a href="clojure.core.html#clojure.core/EMPTY-NODE">EMPTY-NODE</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/ensure"><td id="section-content"><a href="clojure.core.html#clojure.core/ensure">ensure</a></td><td>    fn</td><td>clojure.core</td><td>Must be called in a transaction. Protects the r...</td></tr><tr name="#&apos;clojure.core/enum?"><td id="section-content"><a href="clojure.core.html#clojure.core/enum?">enum?</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/enum-and"><td id="section-content"><a href="clojure.core.html#clojure.core/enum-and">enum-and</a></td><td>    fn</td><td>clojure.core</td><td>Combine via and several enum (flag values).  Co...</td></tr><tr name="#&apos;clojure.core/enumeration-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/enumeration-seq">enumeration-seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns a seq on a java.util.Enumeration</td></tr><tr name="#&apos;clojure.core/enum-or"><td id="section-content"><a href="clojure.core.html#clojure.core/enum-or">enum-or</a></td><td>    fn</td><td>clojure.core</td><td>Combine via or several enum (flag values).  Coe...</td></tr><tr name="#&apos;clojure.core/enum-val"><td id="section-content"><a href="clojure.core.html#clojure.core/enum-val">enum-val</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/error-handler"><td id="section-content"><a href="clojure.core.html#clojure.core/error-handler">error-handler</a></td><td>    fn</td><td>clojure.core</td><td>Returns the error-handler of agent a, or nil if...</td></tr><tr name="#&apos;clojure.core/error-mode"><td id="section-content"><a href="clojure.core.html#clojure.core/error-mode">error-mode</a></td><td>    fn</td><td>clojure.core</td><td>Returns the error-mode of agent a.  See set-err...</td></tr><tr name="#&apos;clojure.string/escape"><td id="section-content"><a href="clojure.string.html#clojure.string/escape">escape</a></td><td>    fn</td><td>clojure.string</td><td>Return a new string, using cmap to escape each ...</td></tr><tr name="#&apos;clojure.core/eval"><td id="section-content"><a href="clojure.core.html#clojure.core/eval">eval</a></td><td>    fn</td><td>clojure.core</td><td>Evaluates the form data structure (not text!) a...</td></tr><tr name="#&apos;clojure.test-helper/eval-in-temp-ns"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/eval-in-temp-ns">eval-in-temp-ns</a></td><td>    macro</td><td>clojure.test-helper</td><td></td></tr><tr name="#&apos;clojure.core/even?"><td id="section-content"><a href="clojure.core.html#clojure.core/even?">even?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is even, throws an exception ...</td></tr><tr name="#&apos;clojure.core/every?"><td id="section-content"><a href="clojure.core.html#clojure.core/every?">every?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if (pred x) is logical true for ev...</td></tr><tr name="#&apos;clojure.core/every-pred"><td id="section-content"><a href="clojure.core.html#clojure.core/every-pred">every-pred</a></td><td>    fn</td><td>clojure.core</td><td>Takes a set of predicates and returns a functio...</td></tr><tr name="#&apos;clojure.test-helper/exception"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/exception">exception</a></td><td>    fn</td><td>clojure.test-helper</td><td>Use this function to ensure that execution of a...</td></tr><tr name="#&apos;clojure.core/extend"><td id="section-content"><a href="clojure.core.html#clojure.core/extend">extend</a></td><td>    fn</td><td>clojure.core</td><td>Implementations of protocol methods can be prov...</td></tr><tr name="#&apos;clojure.core/extenders"><td id="section-content"><a href="clojure.core.html#clojure.core/extenders">extenders</a></td><td>    fn</td><td>clojure.core</td><td>Returns a collection of the types explicitly ex...</td></tr><tr name="#&apos;clojure.core/extend-protocol"><td id="section-content"><a href="clojure.core.html#clojure.core/extend-protocol">extend-protocol</a></td><td>    macro</td><td>clojure.core</td><td>Useful when you want to provide several impleme...</td></tr><tr name="#&apos;clojure.core/extends?"><td id="section-content"><a href="clojure.core.html#clojure.core/extends?">extends?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if atype  extends protocol</td></tr><tr name="#&apos;clojure.core/extend-type"><td id="section-content"><a href="clojure.core.html#clojure.core/extend-type">extend-type</a></td><td>    macro</td><td>clojure.core</td><td>A macro that expands into an extend call. Usefu...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="F">F</th></tr></thead><tr name="#&apos;clojure.core/false?"><td id="section-content"><a href="clojure.core.html#clojure.core/false?">false?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is the value false, false oth...</td></tr><tr name="#&apos;clojure.core/ffirst"><td id="section-content"><a href="clojure.core.html#clojure.core/ffirst">ffirst</a></td><td>    fn</td><td>clojure.core</td><td>Same as (first (first x))</td></tr><tr name="#&apos;clojure.reflect/field-flags"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/field-flags">field-flags</a></td><td>    var</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/file-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/file-seq">file-seq</a></td><td>    fn</td><td>clojure.core</td><td>A tree seq on java.io.Files</td></tr><tr name="#&apos;clojure.core/filter"><td id="section-content"><a href="clojure.core.html#clojure.core/filter">filter</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the items in coll fo...</td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/filter-out-clr-ns"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/filter-out-clr-ns">filter-out-clr-ns</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.core/find"><td id="section-content"><a href="clojure.core.html#clojure.core/find">find</a></td><td>    fn</td><td>clojure.core</td><td>Returns the map entry for key, or nil if key no...</td></tr><tr name="#&apos;clojure.core/find-keyword"><td id="section-content"><a href="clojure.core.html#clojure.core/find-keyword">find-keyword</a></td><td>    fn</td><td>clojure.core</td><td>Returns a Keyword with the given namespace and ...</td></tr><tr name="#&apos;clojure.core/find-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/find-ns">find-ns</a></td><td>    fn</td><td>clojure.core</td><td>Returns the namespace named by the symbol or ni...</td></tr><tr name="#&apos;clojure.core/find-protocol-impl"><td id="section-content"><a href="clojure.core.html#clojure.core/find-protocol-impl">find-protocol-impl</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/find-protocol-method"><td id="section-content"><a href="clojure.core.html#clojure.core/find-protocol-method">find-protocol-method</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/find-var"><td id="section-content"><a href="clojure.core.html#clojure.core/find-var">find-var</a></td><td>    fn</td><td>clojure.core</td><td>Returns the global var named by the namespace-q...</td></tr><tr name="#&apos;clojure.core/first"><td id="section-content"><a href="clojure.core.html#clojure.core/first">first</a></td><td>    fn</td><td>clojure.core</td><td>Returns the first item in the collection. Calls...</td></tr><tr name="#&apos;clojure.core/flatten"><td id="section-content"><a href="clojure.core.html#clojure.core/flatten">flatten</a></td><td>    fn</td><td>clojure.core</td><td>Takes any nested combination of sequential thin...</td></tr><tr name="#&apos;clojure.core/float"><td id="section-content"><a href="clojure.core.html#clojure.core/float">float</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to float</td></tr><tr name="#&apos;clojure.core/float?"><td id="section-content"><a href="clojure.core.html#clojure.core/float?">float?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is a floating point number</td></tr><tr name="#&apos;clojure.core/float-array"><td id="section-content"><a href="clojure.core.html#clojure.core/float-array">float-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of floats</td></tr><tr name="#&apos;clojure.core/floats"><td id="section-content"><a href="clojure.core.html#clojure.core/floats">floats</a></td><td>    fn</td><td>clojure.core</td><td>Casts to float[]</td></tr><tr name="#&apos;clojure.core/flush"><td id="section-content"><a href="clojure.core.html#clojure.core/flush">flush</a></td><td>    fn</td><td>clojure.core</td><td>Flushes the output stream that is the current v...</td></tr><tr name="#&apos;clojure.core/fn"><td id="section-content"><a href="clojure.core.html#clojure.core/fn">fn</a></td><td>    macro</td><td>clojure.core</td><td>params =&gt; positional-params* , or positional-pa...</td></tr><tr name="#&apos;clojure.core/fn?"><td id="section-content"><a href="clojure.core.html#clojure.core/fn?">fn?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x implements Fn, i.e. is an obj...</td></tr><tr name="#&apos;clojure.core/fnext"><td id="section-content"><a href="clojure.core.html#clojure.core/fnext">fnext</a></td><td>    fn</td><td>clojure.core</td><td>Same as (first (next x))</td></tr><tr name="#&apos;clojure.core/fnil"><td id="section-content"><a href="clojure.core.html#clojure.core/fnil">fnil</a></td><td>    fn</td><td>clojure.core</td><td>Takes a function f, and returns a function that...</td></tr><tr name="#&apos;clojure.core/for"><td id="section-content"><a href="clojure.core.html#clojure.core/for">for</a></td><td>    macro</td><td>clojure.core</td><td>List comprehension. Takes a vector of one or mo...</td></tr><tr name="#&apos;clojure.core/force"><td id="section-content"><a href="clojure.core.html#clojure.core/force">force</a></td><td>    fn</td><td>clojure.core</td><td>If x is a Delay, returns the (possibly cached) ...</td></tr><tr name="#&apos;clojure.core/format"><td id="section-content"><a href="clojure.core.html#clojure.core/format">format</a></td><td>    fn</td><td>clojure.core</td><td>Formats a string using java.lang.String.format,...</td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/format-source"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/format-source">format-source</a></td><td>    var</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.pprint/formatter"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/formatter">formatter</a></td><td>    macro</td><td>clojure.pprint</td><td>Makes a function which can directly run format-...</td></tr><tr name="#&apos;clojure.pprint/formatter-out"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/formatter-out">formatter-out</a></td><td>    macro</td><td>clojure.pprint</td><td>Makes a function which can directly run format-...</td></tr><tr name="#&apos;clojure.core/frequencies"><td id="section-content"><a href="clojure.core.html#clojure.core/frequencies">frequencies</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map from distinct items in coll to th...</td></tr><tr name="#&apos;clojure.pprint/fresh-line"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/fresh-line">fresh-line</a></td><td>    fn</td><td>clojure.pprint</td><td>Make a newline if *out* is not already at the b...</td></tr><tr name="#&apos;clojure.core/future"><td id="section-content"><a href="clojure.core.html#clojure.core/future">future</a></td><td>    macro</td><td>clojure.core</td><td>Takes a body of expressions and yields a future...</td></tr><tr name="#&apos;clojure.core/future?"><td id="section-content"><a href="clojure.core.html#clojure.core/future?">future?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is a future</td></tr><tr name="#&apos;clojure.core/future-call"><td id="section-content"><a href="clojure.core.html#clojure.core/future-call">future-call</a></td><td>    fn</td><td>clojure.core</td><td>Takes a function of no args and yields a future...</td></tr><tr name="#&apos;clojure.core/future-cancel"><td id="section-content"><a href="clojure.core.html#clojure.core/future-cancel">future-cancel</a></td><td>    fn</td><td>clojure.core</td><td>Cancels the future, if possible.</td></tr><tr name="#&apos;clojure.core/future-cancelled?"><td id="section-content"><a href="clojure.core.html#clojure.core/future-cancelled?">future-cancelled?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if future f is cancelled</td></tr><tr name="#&apos;clojure.core/future-done?"><td id="section-content"><a href="clojure.core.html#clojure.core/future-done?">future-done?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if future f is done</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="G">G</th></tr></thead><tr name="#&apos;clojure.contrib.gen-html-docs/gen-api-index"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/gen-api-index">gen-api-index</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.core/gen-class"><td id="section-content"><a href="clojure.core.html#clojure.core/gen-class">gen-class</a></td><td>    macro</td><td>clojure.core</td><td>When compiling, generates compiled bytecode for...</td></tr><tr name="#&apos;clojure.core/gen-delegate"><td id="section-content"><a href="clojure.core.html#clojure.core/gen-delegate">gen-delegate</a></td><td>    macro</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/generate-clr-docs"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/generate-clr-docs">generate-clr-docs</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/generate-documentation"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/generate-documentation">generate-documentation</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td>Generates a single HMTL page for the provided n...</td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/generate-documentation-to-files"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/generate-documentation-to-files">generate-documentation-to-files</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/generate-index-file"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/generate-index-file">generate-index-file</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.core/gen-interface"><td id="section-content"><a href="clojure.core.html#clojure.core/gen-interface">gen-interface</a></td><td>    macro</td><td>clojure.core</td><td>When compiling, generates compiled bytecode for...</td></tr><tr name="#&apos;clojure.core/gensym"><td id="section-content"><a href="clojure.core.html#clojure.core/gensym">gensym</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new symbol with a unique name. If a p...</td></tr><tr name="#&apos;clojure.core/get"><td id="section-content"><a href="clojure.core.html#clojure.core/get">get</a></td><td>    fn</td><td>clojure.core</td><td>Returns the value mapped to key, not-found or n...</td></tr><tr name="#&apos;clojure.test-helper/get-field"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/get-field">get-field</a></td><td>    fn</td><td>clojure.test-helper</td><td>Access to private or protected field.  field-na...</td></tr><tr name="#&apos;clojure.core/get-in"><td id="section-content"><a href="clojure.core.html#clojure.core/get-in">get-in</a></td><td>    fn</td><td>clojure.core</td><td>Returns the value in a nested associative struc...</td></tr><tr name="#&apos;clojure.core/get-method"><td id="section-content"><a href="clojure.core.html#clojure.core/get-method">get-method</a></td><td>    fn</td><td>clojure.core</td><td>Given a multimethod and a dispatch value, retur...</td></tr><tr name="#&apos;clojure.pprint/get-pretty-writer"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/get-pretty-writer">get-pretty-writer</a></td><td>    fn</td><td>clojure.pprint</td><td>Returns the java.io.Writer passed in wrapped in...</td></tr><tr name="#&apos;clojure.core/get-proxy-class"><td id="section-content"><a href="clojure.core.html#clojure.core/get-proxy-class">get-proxy-class</a></td><td>    fn</td><td>clojure.core</td><td>Takes an optional single class followed by zero...</td></tr><tr name="#&apos;clojure.core/get-thread-bindings"><td id="section-content"><a href="clojure.core.html#clojure.core/get-thread-bindings">get-thread-bindings</a></td><td>    fn</td><td>clojure.core</td><td>Get a map with the Var/value pairs which is cur...</td></tr><tr name="#&apos;clojure.core/get-validator"><td id="section-content"><a href="clojure.core.html#clojure.core/get-validator">get-validator</a></td><td>    fn</td><td>clojure.core</td><td>Gets the validator-fn for a var/ref/agent/atom.</td></tr><tr name="#&apos;clojure.core/group-by"><td id="section-content"><a href="clojure.core.html#clojure.core/group-by">group-by</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the elements of coll keyed by ...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="H">H</th></tr></thead><tr name="#&apos;clojure.core/hash"><td id="section-content"><a href="clojure.core.html#clojure.core/hash">hash</a></td><td>    fn</td><td>clojure.core</td><td>Returns the hash code of its argument</td></tr><tr name="#&apos;clojure.core/hash-combine"><td id="section-content"><a href="clojure.core.html#clojure.core/hash-combine">hash-combine</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/hash-map"><td id="section-content"><a href="clojure.core.html#clojure.core/hash-map">hash-map</a></td><td>    fn</td><td>clojure.core</td><td>keyval =&gt; key val
  Returns a new hash map with...</td></tr><tr name="#&apos;clojure.core/hash-set"><td id="section-content"><a href="clojure.core.html#clojure.core/hash-set">hash-set</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new hash set with supplied keys.</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="I">I</th></tr></thead><tr name="#&apos;clojure.core/identical?"><td id="section-content"><a href="clojure.core.html#clojure.core/identical?">identical?</a></td><td>    fn</td><td>clojure.core</td><td>Tests if 2 arguments are the same object</td></tr><tr name="#&apos;clojure.core/identity"><td id="section-content"><a href="clojure.core.html#clojure.core/identity">identity</a></td><td>    fn</td><td>clojure.core</td><td>Returns its argument.</td></tr><tr name="#&apos;clojure.core/if-let"><td id="section-content"><a href="clojure.core.html#clojure.core/if-let">if-let</a></td><td>    macro</td><td>clojure.core</td><td>bindings =&gt; binding-form test

  If test is tru...</td></tr><tr name="#&apos;clojure.core/ifn?"><td id="section-content"><a href="clojure.core.html#clojure.core/ifn?">ifn?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x implements IFn. Note that man...</td></tr><tr name="#&apos;clojure.core/if-not"><td id="section-content"><a href="clojure.core.html#clojure.core/if-not">if-not</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates test. If logical false, evaluates and...</td></tr><tr name="#&apos;clojure.core/import"><td id="section-content"><a href="clojure.core.html#clojure.core/import">import</a></td><td>    macro</td><td>clojure.core</td><td>import-list =&gt; (package-symbol class-name-symbo...</td></tr><tr name="#&apos;clojure.core/inc"><td id="section-content"><a href="clojure.core.html#clojure.core/inc">inc</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one greater than num. Does not...</td></tr><tr name="#&apos;clojure.core/inc&apos;"><td id="section-content"><a href="clojure.core.html#clojure.core/inc">inc</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one greater than num.  Support...</td></tr><tr name="#&apos;clojure.core/init-proxy"><td id="section-content"><a href="clojure.core.html#clojure.core/init-proxy">init-proxy</a></td><td>    fn</td><td>clojure.core</td><td>Takes a proxy instance and a map of strings (wh...</td></tr><tr name="#&apos;clojure.core/in-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/in-ns">in-ns</a></td><td>    var</td><td>clojure.core</td><td>Sets *ns* to the namespace named by the symbol,...</td></tr><tr name="#&apos;clojure.clr.io/input-stream"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/input-stream">input-stream</a></td><td>    fn</td><td>clojure.clr.io</td><td>Attempts to coerce its argument into an open Sy...</td></tr><tr name="#&apos;clojure.core/instance?"><td id="section-content"><a href="clojure.core.html#clojure.core/instance?">instance?</a></td><td>    fn</td><td>clojure.core</td><td>Evaluates x and tests if it is an instance of t...</td></tr><tr name="#&apos;clojure.core/int"><td id="section-content"><a href="clojure.core.html#clojure.core/int">int</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to int</td></tr><tr name="#&apos;clojure.core/int-array"><td id="section-content"><a href="clojure.core.html#clojure.core/int-array">int-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of ints</td></tr><tr name="#&apos;clojure.core/integer?"><td id="section-content"><a href="clojure.core.html#clojure.core/integer?">integer?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is an integer</td></tr><tr name="#&apos;clojure.core/interleave"><td id="section-content"><a href="clojure.core.html#clojure.core/interleave">interleave</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq of the first item in each co...</td></tr><tr name="#&apos;clojure.core/intern"><td id="section-content"><a href="clojure.core.html#clojure.core/intern">intern</a></td><td>    fn</td><td>clojure.core</td><td>Finds or creates a var named by the symbol name...</td></tr><tr name="#&apos;clojure.core/interpose"><td id="section-content"><a href="clojure.core.html#clojure.core/interpose">interpose</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq of the elements of coll sepa...</td></tr><tr name="#&apos;clojure.core/into"><td id="section-content"><a href="clojure.core.html#clojure.core/into">into</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new coll consisting of to-coll with a...</td></tr><tr name="#&apos;clojure.core/into-array"><td id="section-content"><a href="clojure.core.html#clojure.core/into-array">into-array</a></td><td>    fn</td><td>clojure.core</td><td>Returns an array with components set to the val...</td></tr><tr name="#&apos;clojure.core/ints"><td id="section-content"><a href="clojure.core.html#clojure.core/ints">ints</a></td><td>    fn</td><td>clojure.core</td><td>Casts to int[]</td></tr><tr name="#&apos;clojure.core/io!"><td id="section-content"><a href="clojure.core.html#clojure.core/io!">io!</a></td><td>    macro</td><td>clojure.core</td><td>If an io! block occurs in a transaction, throws...</td></tr><tr name="#&apos;clojure.clr.io/IOFactory"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/IOFactory">IOFactory</a></td><td>    var</td><td>clojure.clr.io</td><td>Factory functions that create ready-to-use, buf...</td></tr><tr name="#&apos;clojure.core/isa?"><td id="section-content"><a href="clojure.core.html#clojure.core/isa?">isa?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if (= child parent), or child is d...</td></tr><tr name="#&apos;clojure.core/iterate"><td id="section-content"><a href="clojure.core.html#clojure.core/iterate">iterate</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of x, (f x), (f (f x)) ...</td></tr><tr name="#&apos;clojure.core/iterator-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/iterator-seq">iterator-seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns a seq on a java.util.Iterator. Note tha...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="J">J</th></tr></thead><tr name="#&apos;clojure.string/join"><td id="section-content"><a href="clojure.string.html#clojure.string/join">join</a></td><td>    fn</td><td>clojure.string</td><td>Returns a string of all elements in coll, as re...</td></tr><tr name="#&apos;clojure.core/juxt"><td id="section-content"><a href="clojure.core.html#clojure.core/juxt">juxt</a></td><td>    fn</td><td>clojure.core</td><td>Takes a set of functions and returns a fn that ...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="K">K</th></tr></thead><tr name="#&apos;clojure.core/keep"><td id="section-content"><a href="clojure.core.html#clojure.core/keep">keep</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the non-nil results ...</td></tr><tr name="#&apos;clojure.core/keep-indexed"><td id="section-content"><a href="clojure.core.html#clojure.core/keep-indexed">keep-indexed</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the non-nil results ...</td></tr><tr name="#&apos;clojure.core/key"><td id="section-content"><a href="clojure.core.html#clojure.core/key">key</a></td><td>    fn</td><td>clojure.core</td><td>Returns the key of the map entry.</td></tr><tr name="#&apos;clojure.core/keys"><td id="section-content"><a href="clojure.core.html#clojure.core/keys">keys</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sequence of the map&apos;s keys.</td></tr><tr name="#&apos;clojure.core/keyword"><td id="section-content"><a href="clojure.core.html#clojure.core/keyword">keyword</a></td><td>    fn</td><td>clojure.core</td><td>Returns a Keyword with the given namespace and ...</td></tr><tr name="#&apos;clojure.core/keyword?"><td id="section-content"><a href="clojure.core.html#clojure.core/keyword?">keyword?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x is a Keyword</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="L">L</th></tr></thead><tr name="#&apos;clojure.core/last"><td id="section-content"><a href="clojure.core.html#clojure.core/last">last</a></td><td>    fn</td><td>clojure.core</td><td>Return the last item in coll, in linear time</td></tr><tr name="#&apos;clojure.core/lazy-cat"><td id="section-content"><a href="clojure.core.html#clojure.core/lazy-cat">lazy-cat</a></td><td>    macro</td><td>clojure.core</td><td>Expands to code which yields a lazy sequence of...</td></tr><tr name="#&apos;clojure.core/lazy-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/lazy-seq">lazy-seq</a></td><td>    macro</td><td>clojure.core</td><td>Takes a body of expressions that returns an ISe...</td></tr><tr name="#&apos;clojure.core/let"><td id="section-content"><a href="clojure.core.html#clojure.core/let">let</a></td><td>    macro</td><td>clojure.core</td><td>binding =&gt; binding-form init-expr

  Evaluates ...</td></tr><tr name="#&apos;clojure.core/letfn"><td id="section-content"><a href="clojure.core.html#clojure.core/letfn">letfn</a></td><td>    macro</td><td>clojure.core</td><td>fnspec ==&gt; (fname [params*] exprs) or (fname ([...</td></tr><tr name="#&apos;clojure.core/line-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/line-seq">line-seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns the lines of text from rdr as a lazy se...</td></tr><tr name="#&apos;clojure.core/list"><td id="section-content"><a href="clojure.core.html#clojure.core/list">list</a></td><td>    fn</td><td>clojure.core</td><td>Creates a new list containing the items.</td></tr><tr name="#&apos;clojure.core/list*"><td id="section-content"><a href="clojure.core.html#clojure.core/list*">list*</a></td><td>    fn</td><td>clojure.core</td><td>Creates a new list containing the items prepend...</td></tr><tr name="#&apos;clojure.core/list?"><td id="section-content"><a href="clojure.core.html#clojure.core/list?">list?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x implements IPersistentList</td></tr><tr name="#&apos;clojure.core/load"><td id="section-content"><a href="clojure.core.html#clojure.core/load">load</a></td><td>    fn</td><td>clojure.core</td><td>Loads Clojure code from resources in classpath....</td></tr><tr name="#&apos;clojure.core/loaded-libs"><td id="section-content"><a href="clojure.core.html#clojure.core/loaded-libs">loaded-libs</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sorted set of symbols naming the curr...</td></tr><tr name="#&apos;clojure.core/load-file"><td id="section-content"><a href="clojure.core.html#clojure.core/load-file">load-file</a></td><td>    var</td><td>clojure.core</td><td>Sequentially read and evaluate the set of forms...</td></tr><tr name="#&apos;clojure.core/load-reader"><td id="section-content"><a href="clojure.core.html#clojure.core/load-reader">load-reader</a></td><td>    fn</td><td>clojure.core</td><td>Sequentially read and evaluate the set of forms...</td></tr><tr name="#&apos;clojure.core/load-string"><td id="section-content"><a href="clojure.core.html#clojure.core/load-string">load-string</a></td><td>    fn</td><td>clojure.core</td><td>Sequentially read and evaluate the set of forms...</td></tr><tr name="#&apos;clojure.core/locking"><td id="section-content"><a href="clojure.core.html#clojure.core/locking">locking</a></td><td>    macro</td><td>clojure.core</td><td>Executes exprs in an implicit do, while holding...</td></tr><tr name="#&apos;clojure.core/long"><td id="section-content"><a href="clojure.core.html#clojure.core/long">long</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to long</td></tr><tr name="#&apos;clojure.core/long-array"><td id="section-content"><a href="clojure.core.html#clojure.core/long-array">long-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of longs</td></tr><tr name="#&apos;clojure.core/longs"><td id="section-content"><a href="clojure.core.html#clojure.core/longs">longs</a></td><td>    fn</td><td>clojure.core</td><td>Casts to long[]</td></tr><tr name="#&apos;clojure.core/loop"><td id="section-content"><a href="clojure.core.html#clojure.core/loop">loop</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates the exprs in a lexical context in whi...</td></tr><tr name="#&apos;clojure.string/lower-case"><td id="section-content"><a href="clojure.string.html#clojure.string/lower-case">lower-case</a></td><td>    fn</td><td>clojure.string</td><td>Converts string to all lower-case.</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="M">M</th></tr></thead><tr name="#&apos;clojure.core/macroexpand"><td id="section-content"><a href="clojure.core.html#clojure.core/macroexpand">macroexpand</a></td><td>    fn</td><td>clojure.core</td><td>Repeatedly calls macroexpand-1 on form until it...</td></tr><tr name="#&apos;clojure.core/macroexpand-1"><td id="section-content"><a href="clojure.core.html#clojure.core/macroexpand-1">macroexpand-1</a></td><td>    fn</td><td>clojure.core</td><td>If form represents a macro form, returns its ex...</td></tr><tr name="#&apos;clojure.core/make-array"><td id="section-content"><a href="clojure.core.html#clojure.core/make-array">make-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates and returns an array of instances of th...</td></tr><tr name="#&apos;clojure.clr.io/make-binary-reader"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-binary-reader">make-binary-reader</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a BinaryReader.  See also IOFactory doc...</td></tr><tr name="#&apos;clojure.clr.io/make-binary-writer"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-binary-writer">make-binary-writer</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a BinaryWriter.  See also IOFactory doc...</td></tr><tr name="#&apos;clojure.core/make-hierarchy"><td id="section-content"><a href="clojure.core.html#clojure.core/make-hierarchy">make-hierarchy</a></td><td>    fn</td><td>clojure.core</td><td>Creates a hierarchy object for use with derive,...</td></tr><tr name="#&apos;clojure.clr.io/make-input-stream"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-input-stream">make-input-stream</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a Stream in input mode.  See also IOFac...</td></tr><tr name="#&apos;clojure.clr.io/make-output-stream"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-output-stream">make-output-stream</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a Stream in output mode.  See also IOFa...</td></tr><tr name="#&apos;clojure.clr.io/make-text-reader"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-text-reader">make-text-reader</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a TextReader.  See also IOFactory docs.</td></tr><tr name="#&apos;clojure.clr.io/make-text-writer"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/make-text-writer">make-text-writer</a></td><td>    fn</td><td>clojure.clr.io</td><td>Creates a TextWriter.  See also IOFactory docs.</td></tr><tr name="#&apos;clojure.core/map"><td id="section-content"><a href="clojure.core.html#clojure.core/map">map</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence consisting of the resul...</td></tr><tr name="#&apos;clojure.core/map?"><td id="section-content"><a href="clojure.core.html#clojure.core/map?">map?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x implements IPersistentMap</td></tr><tr name="#&apos;clojure.reflect/map-&gt;Constructor"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/map-&gt;Constructor">map-&gt;Constructor</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.reflect/map-&gt;Field"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/map-&gt;Field">map-&gt;Field</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.reflect/map-&gt;Method"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/map-&gt;Method">map-&gt;Method</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.reflect/map-&gt;Property"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/map-&gt;Property">map-&gt;Property</a></td><td>    fn</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/mapcat"><td id="section-content"><a href="clojure.core.html#clojure.core/mapcat">mapcat</a></td><td>    fn</td><td>clojure.core</td><td>Returns the result of applying concat to the re...</td></tr><tr name="#&apos;clojure.core/map-indexed"><td id="section-content"><a href="clojure.core.html#clojure.core/map-indexed">map-indexed</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence consisting of the resul...</td></tr><tr name="#&apos;clojure.core/max"><td id="section-content"><a href="clojure.core.html#clojure.core/max">max</a></td><td>    fn</td><td>clojure.core</td><td>Returns the greatest of the nums.</td></tr><tr name="#&apos;clojure.core/max-key"><td id="section-content"><a href="clojure.core.html#clojure.core/max-key">max-key</a></td><td>    fn</td><td>clojure.core</td><td>Returns the x for which (k x), a number, is gre...</td></tr><tr name="#&apos;clojure.contrib.gen-html-docs/member-type"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/member-type">member-type</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td>Figures out for a var x whether it&apos;s a macro, f...</td></tr><tr name="#&apos;clojure.core/memfn"><td id="section-content"><a href="clojure.core.html#clojure.core/memfn">memfn</a></td><td>    macro</td><td>clojure.core</td><td>Expands into code that creates a fn that expect...</td></tr><tr name="#&apos;clojure.core/memoize"><td id="section-content"><a href="clojure.core.html#clojure.core/memoize">memoize</a></td><td>    fn</td><td>clojure.core</td><td>Returns a memoized version of a referentially t...</td></tr><tr name="#&apos;clojure.core/merge"><td id="section-content"><a href="clojure.core.html#clojure.core/merge">merge</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map that consists of the rest of the ...</td></tr><tr name="#&apos;clojure.core/merge-with"><td id="section-content"><a href="clojure.core.html#clojure.core/merge-with">merge-with</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map that consists of the rest of the ...</td></tr><tr name="#&apos;clojure.core/meta"><td id="section-content"><a href="clojure.core.html#clojure.core/meta">meta</a></td><td>    fn</td><td>clojure.core</td><td>Returns the metadata of obj, returns nil if the...</td></tr><tr name="#&apos;clojure.reflect/method-flags"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/method-flags">method-flags</a></td><td>    var</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/methods"><td id="section-content"><a href="clojure.core.html#clojure.core/methods">methods</a></td><td>    fn</td><td>clojure.core</td><td>Given a multimethod, returns a map of dispatch ...</td></tr><tr name="#&apos;clojure.core/method-sig"><td id="section-content"><a href="clojure.core.html#clojure.core/method-sig">method-sig</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/min"><td id="section-content"><a href="clojure.core.html#clojure.core/min">min</a></td><td>    fn</td><td>clojure.core</td><td>Returns the least of the nums.</td></tr><tr name="#&apos;clojure.core/min-key"><td id="section-content"><a href="clojure.core.html#clojure.core/min-key">min-key</a></td><td>    fn</td><td>clojure.core</td><td>Returns the x for which (k x), a number, is lea...</td></tr><tr name="#&apos;clojure.core/mod"><td id="section-content"><a href="clojure.core.html#clojure.core/mod">mod</a></td><td>    fn</td><td>clojure.core</td><td>Modulus of num and div. Truncates toward negati...</td></tr><tr name="#&apos;clojure.core/munge"><td id="section-content"><a href="clojure.core.html#clojure.core/munge">munge</a></td><td>    fn</td><td>clojure.core</td><td></td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="N">N</th></tr></thead><tr name="#&apos;clojure.core/name"><td id="section-content"><a href="clojure.core.html#clojure.core/name">name</a></td><td>    fn</td><td>clojure.core</td><td>Returns the name String of a string, symbol or ...</td></tr><tr name="#&apos;clojure.core/namespace"><td id="section-content"><a href="clojure.core.html#clojure.core/namespace">namespace</a></td><td>    fn</td><td>clojure.core</td><td>Returns the namespace String of a symbol or key...</td></tr><tr name="#&apos;clojure.core/namespace-munge"><td id="section-content"><a href="clojure.core.html#clojure.core/namespace-munge">namespace-munge</a></td><td>    fn</td><td>clojure.core</td><td>Convert a Clojure namespace name to a legal Jav...</td></tr><tr name="#&apos;clojure.core/neg?"><td id="section-content"><a href="clojure.core.html#clojure.core/neg?">neg?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if num is less than zero, else fal...</td></tr><tr name="#&apos;clojure.core/newline"><td id="section-content"><a href="clojure.core.html#clojure.core/newline">newline</a></td><td>    fn</td><td>clojure.core</td><td>Writes a platform-specific newline to *out*</td></tr><tr name="#&apos;clojure.core/next"><td id="section-content"><a href="clojure.core.html#clojure.core/next">next</a></td><td>    fn</td><td>clojure.core</td><td>Returns a seq of the items after the first. Cal...</td></tr><tr name="#&apos;clojure.core/nfirst"><td id="section-content"><a href="clojure.core.html#clojure.core/nfirst">nfirst</a></td><td>    fn</td><td>clojure.core</td><td>Same as (next(first x))</td></tr><tr name="#&apos;clojure.core/nil?"><td id="section-content"><a href="clojure.core.html#clojure.core/nil?">nil?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is nil, false otherwise.</td></tr><tr name="#&apos;clojure.core/nnext"><td id="section-content"><a href="clojure.core.html#clojure.core/nnext">nnext</a></td><td>    fn</td><td>clojure.core</td><td>Same as (next (next x))</td></tr><tr name="#&apos;clojure.core/not"><td id="section-content"><a href="clojure.core.html#clojure.core/not">not</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is logical false, false other...</td></tr><tr name="#&apos;clojure.core/not="><td id="section-content"><a href="clojure.core.html#clojure.core/not=">not=</a></td><td>    fn</td><td>clojure.core</td><td>Same as (not (= obj1 obj2))</td></tr><tr name="#&apos;clojure.core/not-any?"><td id="section-content"><a href="clojure.core.html#clojure.core/not-any?">not-any?</a></td><td>    fn</td><td>clojure.core</td><td>Returns false if (pred x) is logical true for a...</td></tr><tr name="#&apos;clojure.core/not-empty"><td id="section-content"><a href="clojure.core.html#clojure.core/not-empty">not-empty</a></td><td>    fn</td><td>clojure.core</td><td>If coll is empty, returns nil, else coll</td></tr><tr name="#&apos;clojure.core/not-every?"><td id="section-content"><a href="clojure.core.html#clojure.core/not-every?">not-every?</a></td><td>    fn</td><td>clojure.core</td><td>Returns false if (pred x) is logical true for e...</td></tr><tr name="#&apos;clojure.core/ns"><td id="section-content"><a href="clojure.core.html#clojure.core/ns">ns</a></td><td>    macro</td><td>clojure.core</td><td>Sets *ns* to the namespace named by name (uneva...</td></tr><tr name="#&apos;clojure.core/ns-aliases"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-aliases">ns-aliases</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the aliases for the namespace.</td></tr><tr name="#&apos;clojure.core/ns-imports"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-imports">ns-imports</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the import mappings for the na...</td></tr><tr name="#&apos;clojure.core/ns-interns"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-interns">ns-interns</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the intern mappings for the na...</td></tr><tr name="#&apos;clojure.core/ns-map"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-map">ns-map</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of all the mappings for the names...</td></tr><tr name="#&apos;clojure.core/ns-name"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-name">ns-name</a></td><td>    fn</td><td>clojure.core</td><td>Returns the name of the namespace, a symbol.</td></tr><tr name="#&apos;clojure.core/ns-publics"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-publics">ns-publics</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the public intern mappings for...</td></tr><tr name="#&apos;clojure.core/ns-refers"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-refers">ns-refers</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map of the refer mappings for the nam...</td></tr><tr name="#&apos;clojure.core/ns-resolve"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-resolve">ns-resolve</a></td><td>    fn</td><td>clojure.core</td><td>Returns the var or Class to which a symbol will...</td></tr><tr name="#&apos;clojure.core/ns-unalias"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-unalias">ns-unalias</a></td><td>    fn</td><td>clojure.core</td><td>Removes the alias for the symbol from the names...</td></tr><tr name="#&apos;clojure.core/ns-unmap"><td id="section-content"><a href="clojure.core.html#clojure.core/ns-unmap">ns-unmap</a></td><td>    fn</td><td>clojure.core</td><td>Removes the mappings for the symbol from the na...</td></tr><tr name="#&apos;clojure.core/nth"><td id="section-content"><a href="clojure.core.html#clojure.core/nth">nth</a></td><td>    fn</td><td>clojure.core</td><td>Returns the value at the index. get returns nil...</td></tr><tr name="#&apos;clojure.core/nthnext"><td id="section-content"><a href="clojure.core.html#clojure.core/nthnext">nthnext</a></td><td>    fn</td><td>clojure.core</td><td>Returns the nth next of coll, (seq coll) when n...</td></tr><tr name="#&apos;clojure.core/nthrest"><td id="section-content"><a href="clojure.core.html#clojure.core/nthrest">nthrest</a></td><td>    fn</td><td>clojure.core</td><td>Returns the nth rest of coll, coll when n is 0.</td></tr><tr name="#&apos;clojure.core/num"><td id="section-content"><a href="clojure.core.html#clojure.core/num">num</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to Number</td></tr><tr name="#&apos;clojure.core/number?"><td id="section-content"><a href="clojure.core.html#clojure.core/number?">number?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is a Number</td></tr><tr name="#&apos;clojure.core/numerator"><td id="section-content"><a href="clojure.core.html#clojure.core/numerator">numerator</a></td><td>    fn</td><td>clojure.core</td><td>Returns the numerator part of a Ratio.</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="P">P</th></tr></thead><tr name="#&apos;clojure.core/parents"><td id="section-content"><a href="clojure.core.html#clojure.core/parents">parents</a></td><td>    fn</td><td>clojure.core</td><td>Returns the immediate parents of tag, either vi...</td></tr><tr name="#&apos;clojure.core/partial"><td id="section-content"><a href="clojure.core.html#clojure.core/partial">partial</a></td><td>    fn</td><td>clojure.core</td><td>Takes a function f and fewer than the normal ar...</td></tr><tr name="#&apos;clojure.core/partition"><td id="section-content"><a href="clojure.core.html#clojure.core/partition">partition</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of lists of n items eac...</td></tr><tr name="#&apos;clojure.core/partition-all"><td id="section-content"><a href="clojure.core.html#clojure.core/partition-all">partition-all</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of lists like partition...</td></tr><tr name="#&apos;clojure.core/partition-by"><td id="section-content"><a href="clojure.core.html#clojure.core/partition-by">partition-by</a></td><td>    fn</td><td>clojure.core</td><td>Applies f to each value in coll, splitting it e...</td></tr><tr name="#&apos;clojure.core/pcalls"><td id="section-content"><a href="clojure.core.html#clojure.core/pcalls">pcalls</a></td><td>    fn</td><td>clojure.core</td><td>Executes the no-arg fns in parallel, returning ...</td></tr><tr name="#&apos;clojure.core/peek"><td id="section-content"><a href="clojure.core.html#clojure.core/peek">peek</a></td><td>    fn</td><td>clojure.core</td><td>For a list or queue, same as first, for a vecto...</td></tr><tr name="#&apos;clojure.core/persistent!"><td id="section-content"><a href="clojure.core.html#clojure.core/persistent!">persistent!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Returns a new, per...</td></tr><tr name="#&apos;clojure.test-helper/platform-newlines"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/platform-newlines">platform-newlines</a></td><td>    fn</td><td>clojure.test-helper</td><td></td></tr><tr name="#&apos;clojure.core/pmap"><td id="section-content"><a href="clojure.core.html#clojure.core/pmap">pmap</a></td><td>    fn</td><td>clojure.core</td><td>Like map, except f is applied in parallel. Semi...</td></tr><tr name="#&apos;clojure.core/pop"><td id="section-content"><a href="clojure.core.html#clojure.core/pop">pop</a></td><td>    fn</td><td>clojure.core</td><td>For a list or queue, returns a new list/queue w...</td></tr><tr name="#&apos;clojure.core/pop!"><td id="section-content"><a href="clojure.core.html#clojure.core/pop!">pop!</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Removes the last i...</td></tr><tr name="#&apos;clojure.core/pop-thread-bindings"><td id="section-content"><a href="clojure.core.html#clojure.core/pop-thread-bindings">pop-thread-bindings</a></td><td>    fn</td><td>clojure.core</td><td>Pop one set of bindings pushed with push-bindin...</td></tr><tr name="#&apos;clojure.core/pos?"><td id="section-content"><a href="clojure.core.html#clojure.core/pos?">pos?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if num is greater than zero, else ...</td></tr><tr name="#&apos;clojure.pprint/pp"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pp">pp</a></td><td>    macro</td><td>clojure.pprint</td><td>A convenience macro that pretty prints the last...</td></tr><tr name="#&apos;clojure.pprint/pprint"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pprint">pprint</a></td><td>    fn</td><td>clojure.pprint</td><td>Pretty print object to the optional output writ...</td></tr><tr name="#&apos;clojure.pprint/pprint-indent"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pprint-indent">pprint-indent</a></td><td>    fn</td><td>clojure.pprint</td><td>Create an indent at this point in the pretty pr...</td></tr><tr name="#&apos;clojure.pprint/pprint-logical-block"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pprint-logical-block">pprint-logical-block</a></td><td>    macro</td><td>clojure.pprint</td><td>Execute the body as a pretty printing logical b...</td></tr><tr name="#&apos;clojure.pprint/pprint-newline"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pprint-newline">pprint-newline</a></td><td>    fn</td><td>clojure.pprint</td><td>Print a conditional newline to a pretty printin...</td></tr><tr name="#&apos;clojure.pprint/pprint-tab"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/pprint-tab">pprint-tab</a></td><td>    fn</td><td>clojure.pprint</td><td>Tab at this point in the pretty printing stream...</td></tr><tr name="#&apos;clojure.core/pr"><td id="section-content"><a href="clojure.core.html#clojure.core/pr">pr</a></td><td>    fn</td><td>clojure.core</td><td>Prints the object(s) to the output stream that ...</td></tr><tr name="#&apos;clojure.core/prefer-method"><td id="section-content"><a href="clojure.core.html#clojure.core/prefer-method">prefer-method</a></td><td>    fn</td><td>clojure.core</td><td>Causes the multimethod to prefer matches of dis...</td></tr><tr name="#&apos;clojure.core/prefers"><td id="section-content"><a href="clojure.core.html#clojure.core/prefers">prefers</a></td><td>    fn</td><td>clojure.core</td><td>Given a multimethod, returns a map of preferred...</td></tr><tr name="#&apos;clojure.core/primitives-classnames"><td id="section-content"><a href="clojure.core.html#clojure.core/primitives-classnames">primitives-classnames</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/print"><td id="section-content"><a href="clojure.core.html#clojure.core/print">print</a></td><td>    fn</td><td>clojure.core</td><td>Prints the object(s) to the output stream that ...</td></tr><tr name="#&apos;clojure.core/print-ctor"><td id="section-content"><a href="clojure.core.html#clojure.core/print-ctor">print-ctor</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/print-dup"><td id="section-content"><a href="clojure.core.html#clojure.core/print-dup">print-dup</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/printf"><td id="section-content"><a href="clojure.core.html#clojure.core/printf">printf</a></td><td>    fn</td><td>clojure.core</td><td>Prints formatted output, as per format</td></tr><tr name="#&apos;clojure.pprint/print-length-loop"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/print-length-loop">print-length-loop</a></td><td>    macro</td><td>clojure.pprint</td><td>A version of loop that iterates at most *print-...</td></tr><tr name="#&apos;clojure.core/println"><td id="section-content"><a href="clojure.core.html#clojure.core/println">println</a></td><td>    fn</td><td>clojure.core</td><td>Same as print followed by (newline)</td></tr><tr name="#&apos;clojure.core/println-str"><td id="section-content"><a href="clojure.core.html#clojure.core/println-str">println-str</a></td><td>    fn</td><td>clojure.core</td><td>println to a string, returning it</td></tr><tr name="#&apos;clojure.core/print-method"><td id="section-content"><a href="clojure.core.html#clojure.core/print-method">print-method</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/print-simple"><td id="section-content"><a href="clojure.core.html#clojure.core/print-simple">print-simple</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/print-str"><td id="section-content"><a href="clojure.core.html#clojure.core/print-str">print-str</a></td><td>    fn</td><td>clojure.core</td><td>print to a string, returning it</td></tr><tr name="#&apos;clojure.pprint/print-table"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/print-table">print-table</a></td><td>    fn</td><td>clojure.pprint</td><td>Alpha - subject to change.
   Prints a collecti...</td></tr><tr name="#&apos;clojure.core/prn"><td id="section-content"><a href="clojure.core.html#clojure.core/prn">prn</a></td><td>    fn</td><td>clojure.core</td><td>Same as pr followed by (newline). Observes *flu...</td></tr><tr name="#&apos;clojure.core/prn-str"><td id="section-content"><a href="clojure.core.html#clojure.core/prn-str">prn-str</a></td><td>    fn</td><td>clojure.core</td><td>prn to a string, returning it</td></tr><tr name="#&apos;clojure.core/promise"><td id="section-content"><a href="clojure.core.html#clojure.core/promise">promise</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Returns a promise ...</td></tr><tr name="#&apos;clojure.reflect/property-flags"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/property-flags">property-flags</a></td><td>    var</td><td>clojure.reflect</td><td></td></tr><tr name="#&apos;clojure.core/proxy"><td id="section-content"><a href="clojure.core.html#clojure.core/proxy">proxy</a></td><td>    macro</td><td>clojure.core</td><td>class-and-interfaces - a vector of class names
...</td></tr><tr name="#&apos;clojure.core/proxy-call-with-super"><td id="section-content"><a href="clojure.core.html#clojure.core/proxy-call-with-super">proxy-call-with-super</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/proxy-mappings"><td id="section-content"><a href="clojure.core.html#clojure.core/proxy-mappings">proxy-mappings</a></td><td>    fn</td><td>clojure.core</td><td>Takes a proxy instance and returns the proxy&apos;s ...</td></tr><tr name="#&apos;clojure.core/proxy-name"><td id="section-content"><a href="clojure.core.html#clojure.core/proxy-name">proxy-name</a></td><td>    fn</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/proxy-super"><td id="section-content"><a href="clojure.core.html#clojure.core/proxy-super">proxy-super</a></td><td>    macro</td><td>clojure.core</td><td>Use to call a superclass method in the body of ...</td></tr><tr name="#&apos;clojure.core/pr-str"><td id="section-content"><a href="clojure.core.html#clojure.core/pr-str">pr-str</a></td><td>    fn</td><td>clojure.core</td><td>pr to a string, returning it</td></tr><tr name="#&apos;clojure.core/push-thread-bindings"><td id="section-content"><a href="clojure.core.html#clojure.core/push-thread-bindings">push-thread-bindings</a></td><td>    fn</td><td>clojure.core</td><td>WARNING: This is a low-level function. Prefer h...</td></tr><tr name="#&apos;clojure.core/pvalues"><td id="section-content"><a href="clojure.core.html#clojure.core/pvalues">pvalues</a></td><td>    macro</td><td>clojure.core</td><td>Returns a lazy sequence of the values of the ex...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="Q">Q</th></tr></thead><tr name="#&apos;clojure.core/quot"><td id="section-content"><a href="clojure.core.html#clojure.core/quot">quot</a></td><td>    fn</td><td>clojure.core</td><td>quot[ient] of dividing numerator by denominator...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="R">R</th></tr></thead><tr name="#&apos;clojure.core/rand"><td id="section-content"><a href="clojure.core.html#clojure.core/rand">rand</a></td><td>    fn</td><td>clojure.core</td><td>Returns a random floating point number between ...</td></tr><tr name="#&apos;clojure.core/rand-int"><td id="section-content"><a href="clojure.core.html#clojure.core/rand-int">rand-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns a random integer between 0 (inclusive) ...</td></tr><tr name="#&apos;clojure.core/rand-nth"><td id="section-content"><a href="clojure.core.html#clojure.core/rand-nth">rand-nth</a></td><td>    fn</td><td>clojure.core</td><td>Return a random element of the (sequential) col...</td></tr><tr name="#&apos;clojure.core/range"><td id="section-content"><a href="clojure.core.html#clojure.core/range">range</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq of nums from start (inclusiv...</td></tr><tr name="#&apos;clojure.core/ratio?"><td id="section-content"><a href="clojure.core.html#clojure.core/ratio?">ratio?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is a Ratio</td></tr><tr name="#&apos;clojure.core/rational?"><td id="section-content"><a href="clojure.core.html#clojure.core/rational?">rational?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if n is a rational number</td></tr><tr name="#&apos;clojure.core/rationalize"><td id="section-content"><a href="clojure.core.html#clojure.core/rationalize">rationalize</a></td><td>    fn</td><td>clojure.core</td><td>returns the rational value of num</td></tr><tr name="#&apos;clojure.core/read"><td id="section-content"><a href="clojure.core.html#clojure.core/read">read</a></td><td>    fn</td><td>clojure.core</td><td>Reads the next object from stream, which must b...</td></tr><tr name="#&apos;clojure.core/read-line"><td id="section-content"><a href="clojure.core.html#clojure.core/read-line">read-line</a></td><td>    fn</td><td>clojure.core</td><td>Reads the next line from stream that is the cur...</td></tr><tr name="#&apos;clojure.core/read-string"><td id="section-content"><a href="clojure.core.html#clojure.core/read-string">read-string</a></td><td>    fn</td><td>clojure.core</td><td>Reads one object from the string s</td></tr><tr name="#&apos;clojure.core/realized?"><td id="section-content"><a href="clojure.core.html#clojure.core/realized?">realized?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if a value has been produced for a...</td></tr><tr name="#&apos;clojure.core/reduce"><td id="section-content"><a href="clojure.core.html#clojure.core/reduce">reduce</a></td><td>    fn</td><td>clojure.core</td><td>f should be a function of 2 arguments. If val i...</td></tr><tr name="#&apos;clojure.core/reductions"><td id="section-content"><a href="clojure.core.html#clojure.core/reductions">reductions</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq of the intermediate values o...</td></tr><tr name="#&apos;clojure.core/ref"><td id="section-content"><a href="clojure.core.html#clojure.core/ref">ref</a></td><td>    fn</td><td>clojure.core</td><td>Creates and returns a Ref with an initial value...</td></tr><tr name="#&apos;clojure.core/refer"><td id="section-content"><a href="clojure.core.html#clojure.core/refer">refer</a></td><td>    fn</td><td>clojure.core</td><td>refers to all public vars of ns, subject to fil...</td></tr><tr name="#&apos;clojure.core/refer-clojure"><td id="section-content"><a href="clojure.core.html#clojure.core/refer-clojure">refer-clojure</a></td><td>    macro</td><td>clojure.core</td><td>Same as (refer &apos;clojure.core &lt;filters&gt;)</td></tr><tr name="#&apos;clojure.core/ref-history-count"><td id="section-content"><a href="clojure.core.html#clojure.core/ref-history-count">ref-history-count</a></td><td>    fn</td><td>clojure.core</td><td>Returns the history count of a ref</td></tr><tr name="#&apos;clojure.core/re-find"><td id="section-content"><a href="clojure.core.html#clojure.core/re-find">re-find</a></td><td>    fn</td><td>clojure.core</td><td>Returns the next regex match, if any, of string...</td></tr><tr name="#&apos;clojure.reflect/reflect"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/reflect">reflect</a></td><td>    fn</td><td>clojure.reflect</td><td>Alpha - subject to change.
   Reflect on the ty...</td></tr><tr name="#&apos;clojure.reflect/Reflector"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/Reflector">Reflector</a></td><td>    var</td><td>clojure.reflect</td><td>Protocol for reflection implementers.</td></tr><tr name="#&apos;clojure.core/ref-max-history"><td id="section-content"><a href="clojure.core.html#clojure.core/ref-max-history">ref-max-history</a></td><td>    fn</td><td>clojure.core</td><td>Gets the max-history of a ref, or sets it and r...</td></tr><tr name="#&apos;clojure.core/ref-min-history"><td id="section-content"><a href="clojure.core.html#clojure.core/ref-min-history">ref-min-history</a></td><td>    fn</td><td>clojure.core</td><td>Gets the min-history of a ref, or sets it and r...</td></tr><tr name="#&apos;clojure.core/ref-set"><td id="section-content"><a href="clojure.core.html#clojure.core/ref-set">ref-set</a></td><td>    fn</td><td>clojure.core</td><td>Must be called in a transaction. Sets the value...</td></tr><tr name="#&apos;clojure.core/re-groups"><td id="section-content"><a href="clojure.core.html#clojure.core/re-groups">re-groups</a></td><td>    fn</td><td>clojure.core</td><td>Returns the groups from the most recent match/f...</td></tr><tr name="#&apos;clojure.core/reify"><td id="section-content"><a href="clojure.core.html#clojure.core/reify">reify</a></td><td>    macro</td><td>clojure.core</td><td>reify is a macro with the following structure:
...</td></tr><tr name="#&apos;clojure.core/release-pending-sends"><td id="section-content"><a href="clojure.core.html#clojure.core/release-pending-sends">release-pending-sends</a></td><td>    fn</td><td>clojure.core</td><td>Normally, actions sent directly or indirectly d...</td></tr><tr name="#&apos;clojure.core/rem"><td id="section-content"><a href="clojure.core.html#clojure.core/rem">rem</a></td><td>    fn</td><td>clojure.core</td><td>remainder of dividing numerator by denominator.</td></tr><tr name="#&apos;clojure.core/re-matcher"><td id="section-content"><a href="clojure.core.html#clojure.core/re-matcher">re-matcher</a></td><td>    fn</td><td>clojure.core</td><td>Returns an instance of java.util.regex.Matcher,...</td></tr><tr name="#&apos;clojure.core/re-matches"><td id="section-content"><a href="clojure.core.html#clojure.core/re-matches">re-matches</a></td><td>    fn</td><td>clojure.core</td><td>Returns the match, if any, of string to pattern...</td></tr><tr name="#&apos;clojure.core/remove"><td id="section-content"><a href="clojure.core.html#clojure.core/remove">remove</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the items in coll fo...</td></tr><tr name="#&apos;clojure.core/remove-all-methods"><td id="section-content"><a href="clojure.core.html#clojure.core/remove-all-methods">remove-all-methods</a></td><td>    fn</td><td>clojure.core</td><td>Removes all of the methods of multimethod.</td></tr><tr name="#&apos;clojure.core/remove-method"><td id="section-content"><a href="clojure.core.html#clojure.core/remove-method">remove-method</a></td><td>    fn</td><td>clojure.core</td><td>Removes the method of multimethod associated	wi...</td></tr><tr name="#&apos;clojure.core/remove-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/remove-ns">remove-ns</a></td><td>    fn</td><td>clojure.core</td><td>Removes the namespace named by the symbol. Use ...</td></tr><tr name="#&apos;clojure.core/remove-watch"><td id="section-content"><a href="clojure.core.html#clojure.core/remove-watch">remove-watch</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Removes a watch (s...</td></tr><tr name="#&apos;clojure.core/re-pattern"><td id="section-content"><a href="clojure.core.html#clojure.core/re-pattern">re-pattern</a></td><td>    fn</td><td>clojure.core</td><td>Returns an instance of java.util.regex.Pattern,...</td></tr><tr name="#&apos;clojure.core/repeat"><td id="section-content"><a href="clojure.core.html#clojure.core/repeat">repeat</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy (infinite! or length n if suppli...</td></tr><tr name="#&apos;clojure.core/repeatedly"><td id="section-content"><a href="clojure.core.html#clojure.core/repeatedly">repeatedly</a></td><td>    fn</td><td>clojure.core</td><td>Takes a function of no args, presumably with si...</td></tr><tr name="#&apos;clojure.string/replace"><td id="section-content"><a href="clojure.string.html#clojure.string/replace">replace</a></td><td>    fn</td><td>clojure.string</td><td>Replaces all instance of match with replacement...</td></tr><tr name="#&apos;clojure.string/replace-first"><td id="section-content"><a href="clojure.string.html#clojure.string/replace-first">replace-first</a></td><td>    fn</td><td>clojure.string</td><td>Replaces the first instance of match with repla...</td></tr><tr name="#&apos;clojure.core/replicate"><td id="section-content"><a href="clojure.core.html#clojure.core/replicate">replicate</a></td><td>    fn</td><td>clojure.core</td><td>DEPRECATED: Use &apos;repeat&apos; instead.
  Returns a l...</td></tr><tr name="#&apos;clojure.core/require"><td id="section-content"><a href="clojure.core.html#clojure.core/require">require</a></td><td>    fn</td><td>clojure.core</td><td>Loads libs, skipping any that are already loade...</td></tr><tr name="#&apos;clojure.core/re-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/re-seq">re-seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of successive matches o...</td></tr><tr name="#&apos;clojure.core/reset!"><td id="section-content"><a href="clojure.core.html#clojure.core/reset!">reset!</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value of atom to newval without regard...</td></tr><tr name="#&apos;clojure.core/reset-meta!"><td id="section-content"><a href="clojure.core.html#clojure.core/reset-meta!">reset-meta!</a></td><td>    fn</td><td>clojure.core</td><td>Atomically resets the metadata for a namespace/...</td></tr><tr name="#&apos;clojure.core/resolve"><td id="section-content"><a href="clojure.core.html#clojure.core/resolve">resolve</a></td><td>    fn</td><td>clojure.core</td><td>same as (ns-resolve *ns* symbol) or (ns-resolve...</td></tr><tr name="#&apos;clojure.core/rest"><td id="section-content"><a href="clojure.core.html#clojure.core/rest">rest</a></td><td>    fn</td><td>clojure.core</td><td>Returns a possibly empty seq of the items after...</td></tr><tr name="#&apos;clojure.core/restart-agent"><td id="section-content"><a href="clojure.core.html#clojure.core/restart-agent">restart-agent</a></td><td>    fn</td><td>clojure.core</td><td>When an agent is failed, changes the agent stat...</td></tr><tr name="#&apos;clojure.string/reverse"><td id="section-content"><a href="clojure.string.html#clojure.string/reverse">reverse</a></td><td>    fn</td><td>clojure.string</td><td>Returns s with its characters reversed.</td></tr><tr name="#&apos;clojure.core/reversible?"><td id="section-content"><a href="clojure.core.html#clojure.core/reversible?">reversible?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll implements Reversible</td></tr><tr name="#&apos;clojure.core/rseq"><td id="section-content"><a href="clojure.core.html#clojure.core/rseq">rseq</a></td><td>    fn</td><td>clojure.core</td><td>Returns, in constant time, a seq of the items i...</td></tr><tr name="#&apos;clojure.core/rsubseq"><td id="section-content"><a href="clojure.core.html#clojure.core/rsubseq">rsubseq</a></td><td>    fn</td><td>clojure.core</td><td>sc must be a sorted collection, test(s) one of ...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="S">S</th></tr></thead><tr name="#&apos;clojure.core/satisfies?"><td id="section-content"><a href="clojure.core.html#clojure.core/satisfies?">satisfies?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x satisfies the protocol</td></tr><tr name="#&apos;clojure.core/sbyte"><td id="section-content"><a href="clojure.core.html#clojure.core/sbyte">sbyte</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to sbyte</td></tr><tr name="#&apos;clojure.core/second"><td id="section-content"><a href="clojure.core.html#clojure.core/second">second</a></td><td>    fn</td><td>clojure.core</td><td>Same as (first (next x))</td></tr><tr name="#&apos;clojure.core/select-keys"><td id="section-content"><a href="clojure.core.html#clojure.core/select-keys">select-keys</a></td><td>    fn</td><td>clojure.core</td><td>Returns a map containing only those entries in ...</td></tr><tr name="#&apos;clojure.core/send"><td id="section-content"><a href="clojure.core.html#clojure.core/send">send</a></td><td>    fn</td><td>clojure.core</td><td>Dispatch an action to an agent. Returns the age...</td></tr><tr name="#&apos;clojure.core/send-off"><td id="section-content"><a href="clojure.core.html#clojure.core/send-off">send-off</a></td><td>    fn</td><td>clojure.core</td><td>Dispatch a potentially blocking action to an ag...</td></tr><tr name="#&apos;clojure.core/seq"><td id="section-content"><a href="clojure.core.html#clojure.core/seq">seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns a seq on the collection. If the collect...</td></tr><tr name="#&apos;clojure.core/seq?"><td id="section-content"><a href="clojure.core.html#clojure.core/seq?">seq?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x implements ISeq</td></tr><tr name="#&apos;clojure.core/sequence"><td id="section-content"><a href="clojure.core.html#clojure.core/sequence">sequence</a></td><td>    fn</td><td>clojure.core</td><td>Coerces coll to a (possibly empty) sequence, if...</td></tr><tr name="#&apos;clojure.core/sequential?"><td id="section-content"><a href="clojure.core.html#clojure.core/sequential?">sequential?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll implements Sequential</td></tr><tr name="#&apos;clojure.core/set"><td id="section-content"><a href="clojure.core.html#clojure.core/set">set</a></td><td>    fn</td><td>clojure.core</td><td>Returns a set of the distinct elements of coll.</td></tr><tr name="#&apos;clojure.core/set?"><td id="section-content"><a href="clojure.core.html#clojure.core/set?">set?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x implements IPersistentSet</td></tr><tr name="#&apos;clojure.core/set-error-handler!"><td id="section-content"><a href="clojure.core.html#clojure.core/set-error-handler!">set-error-handler!</a></td><td>    fn</td><td>clojure.core</td><td>Sets the error-handler of agent a to handler-fn...</td></tr><tr name="#&apos;clojure.core/set-error-mode!"><td id="section-content"><a href="clojure.core.html#clojure.core/set-error-mode!">set-error-mode!</a></td><td>    fn</td><td>clojure.core</td><td>Sets the error-mode of agent a to mode-keyword,...</td></tr><tr name="#&apos;clojure.pprint/set-pprint-dispatch"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/set-pprint-dispatch">set-pprint-dispatch</a></td><td>    fn</td><td>clojure.pprint</td><td>Set the pretty print dispatch function to a fun...</td></tr><tr name="#&apos;clojure.core/set-validator"><td id="section-content"><a href="clojure.core.html#clojure.core/set-validator">set-validator</a></td><td>    fn</td><td>clojure.core</td><td>Sets the validator-fn for a var/ref/agent/atom....</td></tr><tr name="#&apos;clojure.test-helper/set-var-roots"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/set-var-roots">set-var-roots</a></td><td>    fn</td><td>clojure.test-helper</td><td></td></tr><tr name="#&apos;clojure.clr.shell/sh"><td id="section-content"><a href="clojure.clr.shell.html#clojure.clr.shell/sh">sh</a></td><td>    fn</td><td>clojure.clr.shell</td><td>Passes the given strings to a new Process to la...</td></tr><tr name="#&apos;clojure.core/short"><td id="section-content"><a href="clojure.core.html#clojure.core/short">short</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to short</td></tr><tr name="#&apos;clojure.core/short-array"><td id="section-content"><a href="clojure.core.html#clojure.core/short-array">short-array</a></td><td>    fn</td><td>clojure.core</td><td>Creates an array of shorts</td></tr><tr name="#&apos;clojure.core/shorts"><td id="section-content"><a href="clojure.core.html#clojure.core/shorts">shorts</a></td><td>    fn</td><td>clojure.core</td><td>Casts to shorts[]</td></tr><tr name="#&apos;clojure.test-helper/should-not-reflect"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/should-not-reflect">should-not-reflect</a></td><td>    macro</td><td>clojure.test-helper</td><td>Turn on all warning flags, and test that reflec...</td></tr><tr name="#&apos;clojure.test-helper/should-print-err-message"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/should-print-err-message">should-print-err-message</a></td><td>    macro</td><td>clojure.test-helper</td><td>Turn on all warning flags, and test that error ...</td></tr><tr name="#&apos;clojure.core/shutdown-agents"><td id="section-content"><a href="clojure.core.html#clojure.core/shutdown-agents">shutdown-agents</a></td><td>    fn</td><td>clojure.core</td><td>Initiates a shutdown of the thread pools that b...</td></tr><tr name="#&apos;clojure.pprint/simple-dispatch"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/simple-dispatch">simple-dispatch</a></td><td>    var</td><td>clojure.pprint</td><td>The pretty print dispatch function for simple d...</td></tr><tr name="#&apos;clojure.core/slurp"><td id="section-content"><a href="clojure.core.html#clojure.core/slurp">slurp</a></td><td>    fn</td><td>clojure.core</td><td>Opens a reader on f and reads all its contents,...</td></tr><tr name="#&apos;clojure.core/some"><td id="section-content"><a href="clojure.core.html#clojure.core/some">some</a></td><td>    fn</td><td>clojure.core</td><td>Returns the first logical true value of (pred x...</td></tr><tr name="#&apos;clojure.core/some-fn"><td id="section-content"><a href="clojure.core.html#clojure.core/some-fn">some-fn</a></td><td>    fn</td><td>clojure.core</td><td>Takes a set of predicates and returns a functio...</td></tr><tr name="#&apos;clojure.core/sort"><td id="section-content"><a href="clojure.core.html#clojure.core/sort">sort</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sorted sequence of the items in coll....</td></tr><tr name="#&apos;clojure.core/sort-by"><td id="section-content"><a href="clojure.core.html#clojure.core/sort-by">sort-by</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sorted sequence of the items in coll,...</td></tr><tr name="#&apos;clojure.core/sorted?"><td id="section-content"><a href="clojure.core.html#clojure.core/sorted?">sorted?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if coll implements Sorted</td></tr><tr name="#&apos;clojure.core/sorted-map"><td id="section-content"><a href="clojure.core.html#clojure.core/sorted-map">sorted-map</a></td><td>    fn</td><td>clojure.core</td><td>keyval =&gt; key val
  Returns a new sorted map wi...</td></tr><tr name="#&apos;clojure.core/sorted-map-by"><td id="section-content"><a href="clojure.core.html#clojure.core/sorted-map-by">sorted-map-by</a></td><td>    fn</td><td>clojure.core</td><td>keyval =&gt; key val
  Returns a new sorted map wi...</td></tr><tr name="#&apos;clojure.core/sorted-set"><td id="section-content"><a href="clojure.core.html#clojure.core/sorted-set">sorted-set</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new sorted set with supplied keys.</td></tr><tr name="#&apos;clojure.core/sorted-set-by"><td id="section-content"><a href="clojure.core.html#clojure.core/sorted-set-by">sorted-set-by</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new sorted set with supplied keys, us...</td></tr><tr name="#&apos;clojure.core/special-symbol?"><td id="section-content"><a href="clojure.core.html#clojure.core/special-symbol?">special-symbol?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if s names a special form</td></tr><tr name="#&apos;clojure.core/spit"><td id="section-content"><a href="clojure.core.html#clojure.core/spit">spit</a></td><td>    fn</td><td>clojure.core</td><td>Opposite of slurp.  Opens f with writer, writes...</td></tr><tr name="#&apos;clojure.string/split"><td id="section-content"><a href="clojure.string.html#clojure.string/split">split</a></td><td>    fn</td><td>clojure.string</td><td>Splits string on a regular expression.  Optiona...</td></tr><tr name="#&apos;clojure.core/split-at"><td id="section-content"><a href="clojure.core.html#clojure.core/split-at">split-at</a></td><td>    fn</td><td>clojure.core</td><td>Returns a vector of [(take n coll) (drop n coll...</td></tr><tr name="#&apos;clojure.string/split-lines"><td id="section-content"><a href="clojure.string.html#clojure.string/split-lines">split-lines</a></td><td>    fn</td><td>clojure.string</td><td>Splits s on \n or \r\n.</td></tr><tr name="#&apos;clojure.core/split-with"><td id="section-content"><a href="clojure.core.html#clojure.core/split-with">split-with</a></td><td>    fn</td><td>clojure.core</td><td>Returns a vector of [(take-while pred coll) (dr...</td></tr><tr name="#&apos;clojure.core/str"><td id="section-content"><a href="clojure.core.html#clojure.core/str">str</a></td><td>    fn</td><td>clojure.core</td><td>With no args, returns the empty string. With on...</td></tr><tr name="#&apos;clojure.core/string?"><td id="section-content"><a href="clojure.core.html#clojure.core/string?">string?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x is a String</td></tr><tr name="#&apos;clojure.clr.io/string-&gt;encoding"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/string-&gt;encoding">string-&gt;encoding</a></td><td>    var</td><td>clojure.clr.io</td><td></td></tr><tr name="#&apos;clojure.core/struct"><td id="section-content"><a href="clojure.core.html#clojure.core/struct">struct</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new structmap instance with the keys ...</td></tr><tr name="#&apos;clojure.core/struct-map"><td id="section-content"><a href="clojure.core.html#clojure.core/struct-map">struct-map</a></td><td>    fn</td><td>clojure.core</td><td>Returns a new structmap instance with the keys ...</td></tr><tr name="#&apos;clojure.core/subs"><td id="section-content"><a href="clojure.core.html#clojure.core/subs">subs</a></td><td>    fn</td><td>clojure.core</td><td>Returns the substring of s beginning at start i...</td></tr><tr name="#&apos;clojure.core/subseq"><td id="section-content"><a href="clojure.core.html#clojure.core/subseq">subseq</a></td><td>    fn</td><td>clojure.core</td><td>sc must be a sorted collection, test(s) one of ...</td></tr><tr name="#&apos;clojure.core/subvec"><td id="section-content"><a href="clojure.core.html#clojure.core/subvec">subvec</a></td><td>    fn</td><td>clojure.core</td><td>Returns a persistent vector of the items in vec...</td></tr><tr name="#&apos;clojure.core/supers"><td id="section-content"><a href="clojure.core.html#clojure.core/supers">supers</a></td><td>    fn</td><td>clojure.core</td><td>Returns the immediate and indirect superclasses...</td></tr><tr name="#&apos;clojure.core/swap!"><td id="section-content"><a href="clojure.core.html#clojure.core/swap!">swap!</a></td><td>    fn</td><td>clojure.core</td><td>Atomically swaps the value of atom to be:
  (ap...</td></tr><tr name="#&apos;clojure.core/symbol"><td id="section-content"><a href="clojure.core.html#clojure.core/symbol">symbol</a></td><td>    fn</td><td>clojure.core</td><td>Returns a Symbol with the given namespace and n...</td></tr><tr name="#&apos;clojure.core/symbol?"><td id="section-content"><a href="clojure.core.html#clojure.core/symbol?">symbol?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x is a Symbol</td></tr><tr name="#&apos;clojure.core/sync"><td id="section-content"><a href="clojure.core.html#clojure.core/sync">sync</a></td><td>    macro</td><td>clojure.core</td><td>transaction-flags =&gt; TBD, pass nil for now

  R...</td></tr><tr name="#&apos;clojure.core/sys-action"><td id="section-content"><a href="clojure.core.html#clojure.core/sys-action">sys-action</a></td><td>    macro</td><td>clojure.core</td><td>Translates to a gen-delegate for a System.Actio...</td></tr><tr name="#&apos;clojure.core/sys-func"><td id="section-content"><a href="clojure.core.html#clojure.core/sys-func">sys-func</a></td><td>    macro</td><td>clojure.core</td><td>Translates to a gen-delegate for a System.Func&lt;...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="T">T</th></tr></thead><tr name="#&apos;clojure.core/take"><td id="section-content"><a href="clojure.core.html#clojure.core/take">take</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the first n items in...</td></tr><tr name="#&apos;clojure.core/take-last"><td id="section-content"><a href="clojure.core.html#clojure.core/take-last">take-last</a></td><td>    fn</td><td>clojure.core</td><td>Returns a seq of the last n items in coll.  Dep...</td></tr><tr name="#&apos;clojure.core/take-nth"><td id="section-content"><a href="clojure.core.html#clojure.core/take-nth">take-nth</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy seq of every nth item in coll.</td></tr><tr name="#&apos;clojure.core/take-while"><td id="section-content"><a href="clojure.core.html#clojure.core/take-while">take-while</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of successive items fro...</td></tr><tr name="#&apos;clojure.test-helper/temp-ns"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/temp-ns">temp-ns</a></td><td>    fn</td><td>clojure.test-helper</td><td>Create and return a temporary ns, using clojure...</td></tr><tr name="#&apos;clojure.core/test"><td id="section-content"><a href="clojure.core.html#clojure.core/test">test</a></td><td>    fn</td><td>clojure.core</td><td>test [v] finds fn at key :test in var metadata ...</td></tr><tr name="#&apos;clojure.clr.io/text-reader"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/text-reader">text-reader</a></td><td>    fn</td><td>clojure.clr.io</td><td>Attempts to coerce its argument into an open Sy...</td></tr><tr name="#&apos;clojure.clr.io/text-writer"><td id="section-content"><a href="clojure.clr.io.html#clojure.clr.io/text-writer">text-writer</a></td><td>    fn</td><td>clojure.clr.io</td><td>Attempts to coerce its argument into an open Sy...</td></tr><tr name="#&apos;clojure.core/the-ns"><td id="section-content"><a href="clojure.core.html#clojure.core/the-ns">the-ns</a></td><td>    fn</td><td>clojure.core</td><td>If passed a namespace, returns it. Else, when p...</td></tr><tr name="#&apos;clojure.core/thread-bound?"><td id="section-content"><a href="clojure.core.html#clojure.core/thread-bound?">thread-bound?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if all of the vars provided as arg...</td></tr><tr name="#&apos;clojure.core/time"><td id="section-content"><a href="clojure.core.html#clojure.core/time">time</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates expr and prints the time it took.  Re...</td></tr><tr name="#&apos;clojure.core/to-array"><td id="section-content"><a href="clojure.core.html#clojure.core/to-array">to-array</a></td><td>    fn</td><td>clojure.core</td><td>Returns an array of Objects containing the cont...</td></tr><tr name="#&apos;clojure.core/to-array-2d"><td id="section-content"><a href="clojure.core.html#clojure.core/to-array-2d">to-array-2d</a></td><td>    fn</td><td>clojure.core</td><td>Returns a (potentially-ragged) 2-dimensional ar...</td></tr><tr name="#&apos;clojure.core/trampoline"><td id="section-content"><a href="clojure.core.html#clojure.core/trampoline">trampoline</a></td><td>    fn</td><td>clojure.core</td><td>trampoline can be used to convert algorithms re...</td></tr><tr name="#&apos;clojure.core/transient"><td id="section-content"><a href="clojure.core.html#clojure.core/transient">transient</a></td><td>    fn</td><td>clojure.core</td><td>Alpha - subject to change.
  Returns a new, tra...</td></tr><tr name="#&apos;clojure.core/tree-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/tree-seq">tree-seq</a></td><td>    fn</td><td>clojure.core</td><td>Returns a lazy sequence of the nodes in a tree,...</td></tr><tr name="#&apos;clojure.string/trim"><td id="section-content"><a href="clojure.string.html#clojure.string/trim">trim</a></td><td>    fn</td><td>clojure.string</td><td>Removes whitespace from both ends of string.</td></tr><tr name="#&apos;clojure.string/triml"><td id="section-content"><a href="clojure.string.html#clojure.string/triml">triml</a></td><td>    fn</td><td>clojure.string</td><td>Removes whitespace from the left side of string...</td></tr><tr name="#&apos;clojure.string/trim-newline"><td id="section-content"><a href="clojure.string.html#clojure.string/trim-newline">trim-newline</a></td><td>    fn</td><td>clojure.string</td><td>Removes all trailing newline \n or return \r ch...</td></tr><tr name="#&apos;clojure.string/trimr"><td id="section-content"><a href="clojure.string.html#clojure.string/trimr">trimr</a></td><td>    fn</td><td>clojure.string</td><td>Removes whitespace from the right side of strin...</td></tr><tr name="#&apos;clojure.core/true?"><td id="section-content"><a href="clojure.core.html#clojure.core/true?">true?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if x is the value true, false othe...</td></tr><tr name="#&apos;clojure.core/type"><td id="section-content"><a href="clojure.core.html#clojure.core/type">type</a></td><td>    fn</td><td>clojure.core</td><td>Returns the :type metadata of x, or its Class i...</td></tr><tr name="#&apos;clojure.core/type-args"><td id="section-content"><a href="clojure.core.html#clojure.core/type-args">type-args</a></td><td>    fn</td><td>clojure.core</td><td>Supplies type arguments to a generic method int...</td></tr><tr name="#&apos;clojure.reflect/typename"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/typename">typename</a></td><td>    fn</td><td>clojure.reflect</td><td>Returns Java name as returned by ASM getClassNa...</td></tr><tr name="#&apos;clojure.reflect/TypeReference"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/TypeReference">TypeReference</a></td><td>    var</td><td>clojure.reflect</td><td>A TypeReference can be unambiguously converted ...</td></tr><tr name="#&apos;clojure.reflect/type-reflect"><td id="section-content"><a href="clojure.reflect.html#clojure.reflect/type-reflect">type-reflect</a></td><td>    fn</td><td>clojure.reflect</td><td>Alpha - subject to change.
   Reflect on a type...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="U">U</th></tr></thead><tr name="#&apos;clojure.core/uint"><td id="section-content"><a href="clojure.core.html#clojure.core/uint">uint</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to uint</td></tr><tr name="#&apos;clojure.core/ulong"><td id="section-content"><a href="clojure.core.html#clojure.core/ulong">ulong</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to ulong</td></tr><tr name="#&apos;clojure.core/unchecked-add"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-add">unchecked-add</a></td><td>    fn</td><td>clojure.core</td><td>Returns the sum of x and y, both long.
  Note -...</td></tr><tr name="#&apos;clojure.core/unchecked-add-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-add-int">unchecked-add-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the sum of x and y, both int.
  Note - ...</td></tr><tr name="#&apos;clojure.core/unchecked-byte"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-byte">unchecked-byte</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to byte. Subject to rounding or truncati...</td></tr><tr name="#&apos;clojure.core/unchecked-char"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-char">unchecked-char</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to char. Subject to rounding or truncati...</td></tr><tr name="#&apos;clojure.core/unchecked-dec"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-dec">unchecked-dec</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one less than x, a long.
  Not...</td></tr><tr name="#&apos;clojure.core/unchecked-dec-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-dec-int">unchecked-dec-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one less than x, an int.
  Not...</td></tr><tr name="#&apos;clojure.core/unchecked-divide-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-divide-int">unchecked-divide-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the division of x by y, both int.
  Not...</td></tr><tr name="#&apos;clojure.core/unchecked-double"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-double">unchecked-double</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to double. Subject to rounding.</td></tr><tr name="#&apos;clojure.core/unchecked-float"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-float">unchecked-float</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to float. Subject to rounding.</td></tr><tr name="#&apos;clojure.core/unchecked-inc"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-inc">unchecked-inc</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one greater than x, a long.
  ...</td></tr><tr name="#&apos;clojure.core/unchecked-inc-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-inc-int">unchecked-inc-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns a number one greater than x, an int.
  ...</td></tr><tr name="#&apos;clojure.core/unchecked-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-int">unchecked-int</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to int. Subject to rounding or truncatio...</td></tr><tr name="#&apos;clojure.core/unchecked-long"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-long">unchecked-long</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to long. Subject to rounding or truncati...</td></tr><tr name="#&apos;clojure.core/unchecked-multiply"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-multiply">unchecked-multiply</a></td><td>    fn</td><td>clojure.core</td><td>Returns the product of x and y, both long.
  No...</td></tr><tr name="#&apos;clojure.core/unchecked-multiply-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-multiply-int">unchecked-multiply-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the product of x and y, both int.
  Not...</td></tr><tr name="#&apos;clojure.core/unchecked-negate"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-negate">unchecked-negate</a></td><td>    fn</td><td>clojure.core</td><td>Returns the negation of x, a long.
  Note - use...</td></tr><tr name="#&apos;clojure.core/unchecked-negate-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-negate-int">unchecked-negate-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the negation of x, an int.
  Note - use...</td></tr><tr name="#&apos;clojure.core/unchecked-remainder-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-remainder-int">unchecked-remainder-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the remainder of division of x by y, bo...</td></tr><tr name="#&apos;clojure.core/unchecked-short"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-short">unchecked-short</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to short. Subject to rounding or truncat...</td></tr><tr name="#&apos;clojure.core/unchecked-subtract"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-subtract">unchecked-subtract</a></td><td>    fn</td><td>clojure.core</td><td>Returns the difference of x and y, both long.
 ...</td></tr><tr name="#&apos;clojure.core/unchecked-subtract-int"><td id="section-content"><a href="clojure.core.html#clojure.core/unchecked-subtract-int">unchecked-subtract-int</a></td><td>    fn</td><td>clojure.core</td><td>Returns the difference of x and y, both int.
  ...</td></tr><tr name="#&apos;clojure.core/underive"><td id="section-content"><a href="clojure.core.html#clojure.core/underive">underive</a></td><td>    fn</td><td>clojure.core</td><td>Removes a parent/child relationship between par...</td></tr><tr name="#&apos;clojure.core/unquote"><td id="section-content"><a href="clojure.core.html#clojure.core/unquote">unquote</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/unquote-splicing"><td id="section-content"><a href="clojure.core.html#clojure.core/unquote-splicing">unquote-splicing</a></td><td>    var</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/update-in"><td id="section-content"><a href="clojure.core.html#clojure.core/update-in">update-in</a></td><td>    fn</td><td>clojure.core</td><td>&apos;Updates&apos; a value in a nested associative struc...</td></tr><tr name="#&apos;clojure.core/update-proxy"><td id="section-content"><a href="clojure.core.html#clojure.core/update-proxy">update-proxy</a></td><td>    fn</td><td>clojure.core</td><td>Takes a proxy instance and a map of strings (wh...</td></tr><tr name="#&apos;clojure.string/upper-case"><td id="section-content"><a href="clojure.string.html#clojure.string/upper-case">upper-case</a></td><td>    fn</td><td>clojure.string</td><td>Converts string to all upper-case.</td></tr><tr name="#&apos;clojure.core/use"><td id="section-content"><a href="clojure.core.html#clojure.core/use">use</a></td><td>    fn</td><td>clojure.core</td><td>Like &apos;require, but also refers to each lib&apos;s na...</td></tr><tr name="#&apos;clojure.core/ushort"><td id="section-content"><a href="clojure.core.html#clojure.core/ushort">ushort</a></td><td>    fn</td><td>clojure.core</td><td>Coerce to ushort</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="V">V</th></tr></thead><tr name="#&apos;clojure.core/val"><td id="section-content"><a href="clojure.core.html#clojure.core/val">val</a></td><td>    fn</td><td>clojure.core</td><td>Returns the value in the map entry.</td></tr><tr name="#&apos;clojure.core/vals"><td id="section-content"><a href="clojure.core.html#clojure.core/vals">vals</a></td><td>    fn</td><td>clojure.core</td><td>Returns a sequence of the map&apos;s values.</td></tr><tr name="#&apos;clojure.core/var?"><td id="section-content"><a href="clojure.core.html#clojure.core/var?">var?</a></td><td>    fn</td><td>clojure.core</td><td>Returns true if v is of type clojure.lang.Var</td></tr><tr name="#&apos;clojure.core/var-get"><td id="section-content"><a href="clojure.core.html#clojure.core/var-get">var-get</a></td><td>    fn</td><td>clojure.core</td><td>Gets the value in the var object</td></tr><tr name="#&apos;clojure.core/var-set"><td id="section-content"><a href="clojure.core.html#clojure.core/var-set">var-set</a></td><td>    fn</td><td>clojure.core</td><td>Sets the value in the var object to val. The va...</td></tr><tr name="#&apos;clojure.core/vary-meta"><td id="section-content"><a href="clojure.core.html#clojure.core/vary-meta">vary-meta</a></td><td>    fn</td><td>clojure.core</td><td>Returns an object of the same type and value as...</td></tr><tr name="#&apos;clojure.core/vec"><td id="section-content"><a href="clojure.core.html#clojure.core/vec">vec</a></td><td>    fn</td><td>clojure.core</td><td>Creates a new vector containing the contents of...</td></tr><tr name="#&apos;clojure.core/vector"><td id="section-content"><a href="clojure.core.html#clojure.core/vector">vector</a></td><td>    fn</td><td>clojure.core</td><td>Creates a new vector containing the args.</td></tr><tr name="#&apos;clojure.core/vector?"><td id="section-content"><a href="clojure.core.html#clojure.core/vector?">vector?</a></td><td>    fn</td><td>clojure.core</td><td>Return true if x implements IPersistentVector </td></tr><tr name="#&apos;clojure.core/vector-of"><td id="section-content"><a href="clojure.core.html#clojure.core/vector-of">vector-of</a></td><td>    fn</td><td>clojure.core</td><td>Creates a new vector of a single primitive type...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="W">W</th></tr></thead><tr name="#&apos;clojure.core/when"><td id="section-content"><a href="clojure.core.html#clojure.core/when">when</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates test. If logical true, evaluates body...</td></tr><tr name="#&apos;clojure.core/when-first"><td id="section-content"><a href="clojure.core.html#clojure.core/when-first">when-first</a></td><td>    macro</td><td>clojure.core</td><td>bindings =&gt; x xs

  Same as (when (seq xs) (let...</td></tr><tr name="#&apos;clojure.core/when-let"><td id="section-content"><a href="clojure.core.html#clojure.core/when-let">when-let</a></td><td>    macro</td><td>clojure.core</td><td>bindings =&gt; binding-form test

  When test is t...</td></tr><tr name="#&apos;clojure.core/when-not"><td id="section-content"><a href="clojure.core.html#clojure.core/when-not">when-not</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates test. If logical false, evaluates bod...</td></tr><tr name="#&apos;clojure.core/while"><td id="section-content"><a href="clojure.core.html#clojure.core/while">while</a></td><td>    macro</td><td>clojure.core</td><td>Repeatedly executes body while test expression ...</td></tr><tr name="#&apos;clojure.core/with-bindings"><td id="section-content"><a href="clojure.core.html#clojure.core/with-bindings">with-bindings</a></td><td>    macro</td><td>clojure.core</td><td>Takes a map of Var/value pairs. Installs for th...</td></tr><tr name="#&apos;clojure.core/with-bindings*"><td id="section-content"><a href="clojure.core.html#clojure.core/with-bindings*">with-bindings*</a></td><td>    fn</td><td>clojure.core</td><td>Takes a map of Var/value pairs. Installs for th...</td></tr><tr name="#&apos;clojure.test-helper/with-err-print-writer"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/with-err-print-writer">with-err-print-writer</a></td><td>    macro</td><td>clojure.test-helper</td><td>Evaluate with err pointing to a temporary Print...</td></tr><tr name="#&apos;clojure.test-helper/with-err-string-writer"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/with-err-string-writer">with-err-string-writer</a></td><td>    macro</td><td>clojure.test-helper</td><td>Evaluate with err pointing to a temporary Strin...</td></tr><tr name="#&apos;clojure.core/with-in-str"><td id="section-content"><a href="clojure.core.html#clojure.core/with-in-str">with-in-str</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates body in a context in which *in* is bo...</td></tr><tr name="#&apos;clojure.core/with-loading-context"><td id="section-content"><a href="clojure.core.html#clojure.core/with-loading-context">with-loading-context</a></td><td>    macro</td><td>clojure.core</td><td></td></tr><tr name="#&apos;clojure.core/with-local-vars"><td id="section-content"><a href="clojure.core.html#clojure.core/with-local-vars">with-local-vars</a></td><td>    macro</td><td>clojure.core</td><td>varbinding=&gt; symbol init-expr

  Executes the e...</td></tr><tr name="#&apos;clojure.core/with-meta"><td id="section-content"><a href="clojure.core.html#clojure.core/with-meta">with-meta</a></td><td>    fn</td><td>clojure.core</td><td>Returns an object of the same type and value as...</td></tr><tr name="#&apos;clojure.core/with-open"><td id="section-content"><a href="clojure.core.html#clojure.core/with-open">with-open</a></td><td>    macro</td><td>clojure.core</td><td>bindings =&gt; name init

  Evaluates body in a tr...</td></tr><tr name="#&apos;clojure.core/with-out-str"><td id="section-content"><a href="clojure.core.html#clojure.core/with-out-str">with-out-str</a></td><td>    macro</td><td>clojure.core</td><td>Evaluates exprs in a context in which *out* is ...</td></tr><tr name="#&apos;clojure.pprint/with-pprint-dispatch"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/with-pprint-dispatch">with-pprint-dispatch</a></td><td>    macro</td><td>clojure.pprint</td><td>Execute body with the pretty print dispatch fun...</td></tr><tr name="#&apos;clojure.core/with-precision"><td id="section-content"><a href="clojure.core.html#clojure.core/with-precision">with-precision</a></td><td>    macro</td><td>clojure.core</td><td>Sets the precision and rounding mode to be used...</td></tr><tr name="#&apos;clojure.core/with-redefs"><td id="section-content"><a href="clojure.core.html#clojure.core/with-redefs">with-redefs</a></td><td>    macro</td><td>clojure.core</td><td>binding =&gt; var-symbol temp-value-expr

  Tempor...</td></tr><tr name="#&apos;clojure.core/with-redefs-fn"><td id="section-content"><a href="clojure.core.html#clojure.core/with-redefs-fn">with-redefs-fn</a></td><td>    fn</td><td>clojure.core</td><td>Temporarily redefines Vars during a call to fun...</td></tr><tr name="#&apos;clojure.clr.shell/with-sh-dir"><td id="section-content"><a href="clojure.clr.shell.html#clojure.clr.shell/with-sh-dir">with-sh-dir</a></td><td>    macro</td><td>clojure.clr.shell</td><td>Sets the directory for use with sh, see sh for ...</td></tr><tr name="#&apos;clojure.clr.shell/with-sh-env"><td id="section-content"><a href="clojure.clr.shell.html#clojure.clr.shell/with-sh-env">with-sh-env</a></td><td>    macro</td><td>clojure.clr.shell</td><td>Sets the environment for use with sh, see sh fo...</td></tr><tr name="#&apos;clojure.test-helper/with-var-roots"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/with-var-roots">with-var-roots</a></td><td>    macro</td><td>clojure.test-helper</td><td></td></tr><tr name="#&apos;clojure.test-helper/with-var-roots*"><td id="section-content"><a href="clojure.test-helper.html#clojure.test-helper/with-var-roots*">with-var-roots*</a></td><td>    fn</td><td>clojure.test-helper</td><td>Temporarily set var roots, run block, then put ...</td></tr><tr name="#&apos;clojure.pprint/write"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/write">write</a></td><td>    fn</td><td>clojure.pprint</td><td>Write an object subject to the current bindings...</td></tr><tr name="#&apos;clojure.pprint/write-out"><td id="section-content"><a href="clojure.pprint.html#clojure.pprint/write-out">write-out</a></td><td>    fn</td><td>clojure.pprint</td><td>Write an object to *out* subject to the current...</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id="X">X</th></tr></thead><tr name="#&apos;clojure.contrib.gen-html-docs/xconj"><td id="section-content"><a href="clojure.contrib.gen-html-docs.html#clojure.contrib.gen-html-docs/xconj">xconj</a></td><td>    fn</td><td>clojure.contrib.gen-html-docs</td><td></td></tr><tr name="#&apos;clojure.core/xml-seq"><td id="section-content"><a href="clojure.core.html#clojure.core/xml-seq">xml-seq</a></td><td>    fn</td><td>clojure.core</td><td>A tree seq on the xml elements as per xml/parse</td></tr></table></div><div id="index-body"><table><thead><tr><th colspan="3" id=""></th></tr></thead></table></div><div id="index-body"><table><thead><tr><th colspan="3" id=""></th></tr></thead></table></div></div></div></div></div></div></div></body></html>/div></div></div></div></body></html>/html>y></html>l>