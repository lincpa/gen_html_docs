<html xmlns="http://www.w3.org/1999/xhtml"><head><title>clojure.core - Clojure-clr v1.3 API Documentation</title><link href="http://clojure.github.com/clojure/static/favicon.png" rel="shortcut icon"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/clojure.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/wiki.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/internal.css" rel="stylesheet"/><link media="all" type="text/css" href="http://rippinrobr.github.com/gen_html_docs/clr.css" rel="stylesheet"/></head><body><div id="AllContentContainer"><div id="Header"><a id="Logo" href="index.html"><img alt="Clojure-clr" height="100" width="100" src="http://richhickey.github.com/clojure-contrib/static/clojure-icon.gif"/></a><h1><a title="page header title" id="page-header" href="index.html">Clojure-clr API Reference</a></h1></div><div id="leftcolumn"><div/><div class="menu"><div class="WikiCustomNav WikiElement wiki"><span class="toc-header"><span id="project-name">Clojure-clr v</span><span id="version">1.3</span></span><br/><ul><li><a class="wiki_link" href="index.html">Overview</a></li><li><a class="wiki_link" href="api-index.html">API Index</a></li></ul><div class="NamespaceTOC"><span class="toc-header">Namespaces</span><ul id="left-sidebar-list"><li><a href="clojure.clr.io.html" class="wiki_link">clojure.clr.io</a></li><li><a href="clojure.clr.shell.html" class="wiki_link">clojure.clr.shell</a></li><li><a href="clojure.contrib.gen-html-docs.html" class="wiki_link">clojure.contrib.gen-html-docs</a></li><li><a href="clojure.core.html" class="wiki_link">clojure.core</a></li><li><a href="clojure.pprint.html" class="wiki_link">clojure.pprint</a></li><li><a href="clojure.reflect.html" class="wiki_link">clojure.reflect</a></li><li><a href="clojure.string.html" class="wiki_link">clojure.string</a></li><li><a href="clojure.test-helper.html" class="wiki_link">clojure.test-helper</a></li></ul></div></div></div></div></div><div id="rightcolumn"><div id="Content"><div class="contentBox"><div class="innerContentBox"><div id="content_view" class="wiki wikiPage"><div id="right-sidebar"><div id="toc"><h1 class="nopad">Table of Contents</h1><div style="margin-left: 1em;" class="toc-section"><a href="#toc0">Overview</a><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-">-</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&apos;">-'</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*">*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*&apos;">*'</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*1">*1</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*2">*2</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*3">*3</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*agent*">*agent*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*allow-symbol-escape*">*allow-symbol-escape*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*allow-unresolved-vars*">*allow-unresolved-vars*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*assert*">*assert*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*clojure-version*">*clojure-version*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*command-line-args*">*command-line-args*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*compile-files*">*compile-files*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*compile-path*">*compile-path*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*e">*e</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*err*">*err*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*file*">*file*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*flush-on-newline*">*flush-on-newline*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*in*">*in*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*math-context*">*math-context*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*ns*">*ns*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*out*">*out*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*print-dup*">*print-dup*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*print-length*">*print-length*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*print-level*">*print-level*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*print-meta*">*print-meta*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*print-readably*">*print-readably*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*read-eval*">*read-eval*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*source-path*">*source-path*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*unchecked-math*">*unchecked-math*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*use-context-classloader*">*use-context-classloader*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*verbose-defrecords*">*verbose-defrecords*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/*warn-on-reflection*">*warn-on-reflection*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/..">..</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core//">/</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/+">+</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/+&apos;">+'</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/&lt;"><</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/&lt;="><=</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/=">=</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/==">==</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/&gt;">></a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;">-></a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/&gt;=">>=</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;&gt;">->></a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;ArrayChunk">->ArrayChunk</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;Vec">->Vec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;VecNode">->VecNode</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-&gt;VecSeq">->VecSeq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/accessor">accessor</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aclone">aclone</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/add-watch">add-watch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/agent">agent</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/agent-error">agent-error</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/agent-errors">agent-errors</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aget">aget</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/alength">alength</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/alias">alias</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/all-ns">all-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/alter">alter</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/alter-meta!">alter-meta!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/alter-var-root">alter-var-root</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/amap">amap</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ancestors">ancestors</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/and">and</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/apply">apply</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/areduce">areduce</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/array?">array?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/array-map">array-map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset">aset</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-boolean">aset-boolean</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-byte">aset-byte</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-char">aset-char</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-decimal">aset-decimal</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-double">aset-double</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-float">aset-float</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-int">aset-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-long">aset-long</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-sbyte">aset-sbyte</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-short">aset-short</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-uint">aset-uint</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-ulong">aset-ulong</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/aset-ushort">aset-ushort</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assembly-load">assembly-load</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assembly-load-file">assembly-load-file</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assembly-load-from">assembly-load-from</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assert">assert</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assoc">assoc</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assoc!">assoc!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/associative?">associative?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/assoc-in">assoc-in</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/atom">atom</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/await">await</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/await1">await1</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/await-for">await-for</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bases">bases</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bigdec">bigdec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bigint">bigint</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/biginteger">biginteger</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/binding">binding</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-and">bit-and</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-and-not">bit-and-not</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-clear">bit-clear</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-flip">bit-flip</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-not">bit-not</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-or">bit-or</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-set">bit-set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-shift-left">bit-shift-left</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-shift-right">bit-shift-right</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-test">bit-test</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bit-xor">bit-xor</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/boolean">boolean</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/boolean-array">boolean-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/booleans">booleans</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bound?">bound?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bound-fn">bound-fn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bound-fn*">bound-fn*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/butlast">butlast</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/by-ref">by-ref</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/byte">byte</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/byte-array">byte-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/bytes">bytes</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-cache-protocol-fn">-cache-protocol-fn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/case">case</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/cast">cast</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/char">char</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/char?">char?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/char-array">char-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/char-escape-string">char-escape-string</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/char-name-string">char-name-string</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chars">chars</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk">chunk</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-append">chunk-append</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-buffer">chunk-buffer</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-cons">chunk-cons</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunked-seq?">chunked-seq?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-first">chunk-first</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-next">chunk-next</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/chunk-rest">chunk-rest</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/class">class</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/class?">class?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/clear-agent-errors">clear-agent-errors</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/clojure-version">clojure-version</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/coll?">coll?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/comment">comment</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/commute">commute</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/comp">comp</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/comparator">comparator</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/compare">compare</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/compare-and-set!">compare-and-set!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/compile">compile</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/complement">complement</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/concat">concat</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/cond">cond</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/condp">condp</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/conj">conj</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/conj!">conj!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/cons">cons</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/constantly">constantly</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/construct-proxy">construct-proxy</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/contains?">contains?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/count">count</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/counted?">counted?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/create-ns">create-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/create-struct">create-struct</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/cycle">cycle</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dec">dec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dec&apos;">dec'</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/decimal">decimal</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/decimal?">decimal?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/declare">declare</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/definline">definline</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/definterface">definterface</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defmacro">defmacro</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defmethod">defmethod</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defmulti">defmulti</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defn">defn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defn-">defn-</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defonce">defonce</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defprotocol">defprotocol</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defrecord">defrecord</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/defstruct">defstruct</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/deftype">deftype</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/delay">delay</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/delay?">delay?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/deliver">deliver</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/denominator">denominator</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/deref">deref</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/derive">derive</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/descendants">descendants</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/destructure">destructure</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/disj">disj</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/disj!">disj!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dissoc">dissoc</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dissoc!">dissoc!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/distinct">distinct</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/distinct?">distinct?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/doall">doall</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dorun">dorun</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/doseq">doseq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dosync">dosync</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/dotimes">dotimes</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/doto">doto</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/double">double</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/double-array">double-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/doubles">doubles</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/drop">drop</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/drop-last">drop-last</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/drop-while">drop-while</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/empty">empty</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/empty?">empty?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/EMPTY-NODE">EMPTY-NODE</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ensure">ensure</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/enum?">enum?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/enum-and">enum-and</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/enumeration-seq">enumeration-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/enum-or">enum-or</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/enum-val">enum-val</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/error-handler">error-handler</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/error-mode">error-mode</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/eval">eval</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/even?">even?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/every?">every?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/every-pred">every-pred</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/extend">extend</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/extenders">extenders</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/extend-protocol">extend-protocol</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/extends?">extends?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/extend-type">extend-type</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/false?">false?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ffirst">ffirst</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/file-seq">file-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/filter">filter</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find">find</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find-keyword">find-keyword</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find-ns">find-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find-protocol-impl">find-protocol-impl</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find-protocol-method">find-protocol-method</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/find-var">find-var</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/first">first</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/flatten">flatten</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/float">float</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/float?">float?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/float-array">float-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/floats">floats</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/flush">flush</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/fn">fn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/fn?">fn?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/fnext">fnext</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/fnil">fnil</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/for">for</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/force">force</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/format">format</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/frequencies">frequencies</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future">future</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future?">future?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future-call">future-call</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future-cancel">future-cancel</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future-cancelled?">future-cancelled?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/future-done?">future-done?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/gen-class">gen-class</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/gen-delegate">gen-delegate</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/gen-interface">gen-interface</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/gensym">gensym</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get">get</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get-in">get-in</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get-method">get-method</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get-proxy-class">get-proxy-class</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get-thread-bindings">get-thread-bindings</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/get-validator">get-validator</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/group-by">group-by</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/hash">hash</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/hash-combine">hash-combine</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/hash-map">hash-map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/hash-set">hash-set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/identical?">identical?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/identity">identity</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/if-let">if-let</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ifn?">ifn?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/if-not">if-not</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/import">import</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/inc">inc</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/inc&apos;">inc'</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/init-proxy">init-proxy</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/in-ns">in-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/instance?">instance?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/int">int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/int-array">int-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/integer?">integer?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/interleave">interleave</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/intern">intern</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/interpose">interpose</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/into">into</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/into-array">into-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ints">ints</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/io!">io!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/isa?">isa?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/iterate">iterate</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/iterator-seq">iterator-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/juxt">juxt</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/keep">keep</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/keep-indexed">keep-indexed</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/key">key</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/keys">keys</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/keyword">keyword</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/keyword?">keyword?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/last">last</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/lazy-cat">lazy-cat</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/lazy-seq">lazy-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/let">let</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/letfn">letfn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/line-seq">line-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/list">list</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/list*">list*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/list?">list?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/load">load</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/loaded-libs">loaded-libs</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/load-file">load-file</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/load-reader">load-reader</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/load-string">load-string</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/locking">locking</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/long">long</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/long-array">long-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/longs">longs</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/loop">loop</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/macroexpand">macroexpand</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/macroexpand-1">macroexpand-1</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/make-array">make-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/make-hierarchy">make-hierarchy</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/map">map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/map?">map?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/mapcat">mapcat</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/map-indexed">map-indexed</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/max">max</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/max-key">max-key</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/memfn">memfn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/memoize">memoize</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/merge">merge</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/merge-with">merge-with</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/meta">meta</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/methods">methods</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/method-sig">method-sig</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/min">min</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/min-key">min-key</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/mod">mod</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/munge">munge</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/name">name</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/namespace">namespace</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/namespace-munge">namespace-munge</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/neg?">neg?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/newline">newline</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/next">next</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nfirst">nfirst</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nil?">nil?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nnext">nnext</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/not">not</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/not=">not=</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/not-any?">not-any?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/not-empty">not-empty</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/not-every?">not-every?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns">ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-aliases">ns-aliases</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-imports">ns-imports</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-interns">ns-interns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-map">ns-map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-name">ns-name</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-publics">ns-publics</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-refers">ns-refers</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-resolve">ns-resolve</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-unalias">ns-unalias</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ns-unmap">ns-unmap</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nth">nth</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nthnext">nthnext</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/nthrest">nthrest</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/num">num</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/number?">number?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/numerator">numerator</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/object-array">object-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/odd?">odd?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/or">or</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/parents">parents</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/partial">partial</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/partition">partition</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/partition-all">partition-all</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/partition-by">partition-by</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pcalls">pcalls</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/peek">peek</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/persistent!">persistent!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pmap">pmap</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pop">pop</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pop!">pop!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pop-thread-bindings">pop-thread-bindings</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pos?">pos?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pr">pr</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/prefer-method">prefer-method</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/prefers">prefers</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/primitives-classnames">primitives-classnames</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print">print</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print-ctor">print-ctor</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print-dup">print-dup</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/printf">printf</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/println">println</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/println-str">println-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print-method">print-method</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print-simple">print-simple</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/print-str">print-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/prn">prn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/prn-str">prn-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/promise">promise</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/proxy">proxy</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/proxy-call-with-super">proxy-call-with-super</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/proxy-mappings">proxy-mappings</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/proxy-name">proxy-name</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/proxy-super">proxy-super</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pr-str">pr-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/push-thread-bindings">push-thread-bindings</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/pvalues">pvalues</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/quot">quot</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rand">rand</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rand-int">rand-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rand-nth">rand-nth</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/range">range</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ratio?">ratio?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rational?">rational?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rationalize">rationalize</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/read">read</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/read-line">read-line</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/read-string">read-string</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/realized?">realized?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reduce">reduce</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reductions">reductions</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ref">ref</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/refer">refer</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/refer-clojure">refer-clojure</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ref-history-count">ref-history-count</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-find">re-find</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ref-max-history">ref-max-history</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ref-min-history">ref-min-history</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ref-set">ref-set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-groups">re-groups</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reify">reify</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/release-pending-sends">release-pending-sends</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rem">rem</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-matcher">re-matcher</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-matches">re-matches</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/remove">remove</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/remove-all-methods">remove-all-methods</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/remove-method">remove-method</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/remove-ns">remove-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/remove-watch">remove-watch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-pattern">re-pattern</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/repeat">repeat</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/repeatedly">repeatedly</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/replace">replace</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/replicate">replicate</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/require">require</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/re-seq">re-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reset!">reset!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reset-meta!">reset-meta!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/-reset-methods">-reset-methods</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/resolve">resolve</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rest">rest</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/restart-agent">restart-agent</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reverse">reverse</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/reversible?">reversible?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rseq">rseq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/rsubseq">rsubseq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/satisfies?">satisfies?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sbyte">sbyte</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/second">second</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/select-keys">select-keys</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/send">send</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/send-off">send-off</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/seq">seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/seq?">seq?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sequence">sequence</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sequential?">sequential?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/set">set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/set?">set?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/set-error-handler!">set-error-handler!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/set-error-mode!">set-error-mode!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/set-validator">set-validator</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/short">short</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/short-array">short-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/shorts">shorts</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/shutdown-agents">shutdown-agents</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/slurp">slurp</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/some">some</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/some-fn">some-fn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sort">sort</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sort-by">sort-by</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sorted?">sorted?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sorted-map">sorted-map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sorted-map-by">sorted-map-by</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sorted-set">sorted-set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sorted-set-by">sorted-set-by</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/special-symbol?">special-symbol?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/spit">spit</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/split-at">split-at</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/split-with">split-with</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/str">str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/string?">string?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/struct">struct</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/struct-map">struct-map</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/subs">subs</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/subseq">subseq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/subvec">subvec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/supers">supers</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/swap!">swap!</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/symbol">symbol</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/symbol?">symbol?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sync">sync</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sys-action">sys-action</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/sys-func">sys-func</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/take">take</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/take-last">take-last</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/take-nth">take-nth</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/take-while">take-while</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/test">test</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/the-ns">the-ns</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/thread-bound?">thread-bound?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/time">time</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/to-array">to-array</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/to-array-2d">to-array-2d</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/trampoline">trampoline</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/transient">transient</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/tree-seq">tree-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/true?">true?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/type">type</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/type-args">type-args</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/uint">uint</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ulong">ulong</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-add">unchecked-add</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-add-int">unchecked-add-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-byte">unchecked-byte</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-char">unchecked-char</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-dec">unchecked-dec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-dec-int">unchecked-dec-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-divide-int">unchecked-divide-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-double">unchecked-double</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-float">unchecked-float</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-inc">unchecked-inc</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-inc-int">unchecked-inc-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-int">unchecked-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-long">unchecked-long</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-multiply">unchecked-multiply</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-multiply-int">unchecked-multiply-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-negate">unchecked-negate</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-negate-int">unchecked-negate-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-remainder-int">unchecked-remainder-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-short">unchecked-short</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-subtract">unchecked-subtract</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unchecked-subtract-int">unchecked-subtract-int</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/underive">underive</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unquote">unquote</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/unquote-splicing">unquote-splicing</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/update-in">update-in</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/update-proxy">update-proxy</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/use">use</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/ushort">ushort</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/val">val</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vals">vals</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/var?">var?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/var-get">var-get</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/var-set">var-set</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vary-meta">vary-meta</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vec">vec</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vector">vector</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vector?">vector?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/vector-of">vector-of</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/when">when</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/when-first">when-first</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/when-let">when-let</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/when-not">when-not</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/while">while</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-bindings">with-bindings</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-bindings*">with-bindings*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-in-str">with-in-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-loading-context">with-loading-context</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-local-vars">with-local-vars</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-meta">with-meta</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-open">with-open</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-out-str">with-out-str</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-precision">with-precision</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-redefs">with-redefs</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/with-redefs-fn">with-redefs-fn</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/xml-seq">xml-seq</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/zero?">zero?</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.core/zipmap">zipmap</a></div></div></div></div><div id="content-tag"><h1 id="overview">API for <span id="namespace-name">clojure.core - Clojure-clr v1.3</span></h1><H4 style="margin-top: 1em;">Usage: </H4><pre>(ns your-namespace
   (:require clojure.core))</pre><h2>Overview</h2><pre id="namespace-docstr">Fundamental library of the Clojure language</pre><br/><h2>Public Variables and Functions</h2><div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-">-</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">If no ys are supplied, returns the negation of x, else subtracts</div><div class="library-member-doc-line">  the ys from x and returns the result. Does not auto-promote</div><div class="library-member-doc-line">  longs, will throw on overflow. See also: -&apos;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&apos;">-&apos;</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">If no ys are supplied, returns the negation of x, else subtracts</div><div class="library-member-doc-line">  the ys from x and returns the result.  Supports arbitrary precision.</div><div class="library-member-doc-line">  See also: -</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*">*</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the product of nums. (*) returns 1. Does not auto-promote</div><div class="library-member-doc-line">  longs, will throw on overflow. See also: *&apos;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*&apos;">*&apos;</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the product of nums. (*) returns 1.  Supports arbitrary precision.</div><div class="library-member-doc-line">  See also: *</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*1">*1</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">bound in a repl thread to the most recent value printed</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*2">*2</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">bound in a repl thread to the second most recent value printed</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*3">*3</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">bound in a repl thread to the third most recent value printed</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*agent*">*agent*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The agent currently running an action on this thread, else nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*allow-symbol-escape*">*allow-symbol-escape*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*allow-unresolved-vars*">*allow-unresolved-vars*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*assert*">*assert*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*clojure-version*">*clojure-version*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The version info for Clojure core, as a map containing :major :minor </div><div class="library-member-doc-line">  :incremental and :qualifier keys. Feature releases may increment </div><div class="library-member-doc-line">  :minor and/or :major, bugfix releases will increment :incremental. </div><div class="library-member-doc-line">  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*command-line-args*">*command-line-args*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">A sequence of the supplied command line arguments, or nil if</div><div class="library-member-doc-line">  none were supplied</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*compile-files*">*compile-files*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Set to true when compiling files, false otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*compile-path*">*compile-path*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Specifies the directory where &apos;compile&apos; will write out .class</div><div class="library-member-doc-line">  files. This directory must be in the classpath for &apos;compile&apos; to</div><div class="library-member-doc-line">  work.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to &quot;classes&quot;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*e">*e</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">bound in a repl thread to the most recent exception caught by the repl</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*err*">*err*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">A java.io.Writer object representing standard error for print operations.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to System/err, wrapped in a PrintWriter</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*file*">*file*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The path of the file being evaluated, as a String.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Evaluates to nil when there is no file, eg. in the REPL.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*flush-on-newline*">*flush-on-newline*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">When set to true, output will be flushed whenever a newline is printed.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*in*">*in*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">A java.io.Reader object representing standard input for read operations.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to System/in, wrapped in a LineNumberingPushbackReader</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*math-context*">*math-context*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*ns*">*ns*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">A clojure.lang.Namespace object representing the current namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*out*">*out*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">A java.io.Writer object representing standard output for print operations.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to System/out, wrapped in an OutputStreamWriter</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*print-dup*">*print-dup*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">When set to logical true, objects will be printed in a way that preserves</div><div class="library-member-doc-line">  their type when read in later.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*print-length*">*print-length*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">*print-length* controls how many items of each collection the</div><div class="library-member-doc-line">  printer will print. If it is bound to logical false, there is no</div><div class="library-member-doc-line">  limit. Otherwise, it must be bound to an integer indicating the maximum</div><div class="library-member-doc-line">  number of items of each collection to print. If a collection contains</div><div class="library-member-doc-line">  more items, the printer will print items up to the limit followed by</div><div class="library-member-doc-line">  &apos;...&apos; to represent the remaining items. The root binding is nil</div><div class="library-member-doc-line">  indicating no limit.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*print-level*">*print-level*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">*print-level* controls how many levels deep the printer will</div><div class="library-member-doc-line">  print nested objects. If it is bound to logical false, there is no</div><div class="library-member-doc-line">  limit. Otherwise, it must be bound to an integer indicating the maximum</div><div class="library-member-doc-line">  level to print. Each argument to print is at level 0; if an argument is a</div><div class="library-member-doc-line">  collection, its items are at level 1; and so on. If an object is a</div><div class="library-member-doc-line">  collection and is at a level greater than or equal to the value bound to</div><div class="library-member-doc-line">  *print-level*, the printer prints &apos;#&apos; to represent it. The root binding</div><div class="library-member-doc-line">  is nil indicating no limit.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*print-meta*">*print-meta*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">If set to logical true, when printing an object, its metadata will also</div><div class="library-member-doc-line">  be printed in a form that can be read back by the reader.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*print-readably*">*print-readably*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">When set to logical false, strings and characters will be printed with</div><div class="library-member-doc-line">  non-alphanumeric characters converted to the appropriate escape sequences.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to true</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*read-eval*">*read-eval*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">When set to logical false, the EvalReader (#=(...)) is disabled in the </div><div class="library-member-doc-line">  read/load in the thread-local binding.</div><div class="library-member-doc-line">  Example: (binding [*read-eval* false] (read-string &quot;#=(eval (def x 3))&quot;))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to true</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*source-path*">*source-path*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*unchecked-math*">*unchecked-math*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">While bound to true, compilations of +, -, *, inc, dec and the</div><div class="library-member-doc-line">  coercions will be done without overflow checks. Default: false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*use-context-classloader*">*use-context-classloader*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*verbose-defrecords*">*verbose-defrecords*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/*warn-on-reflection*">*warn-on-reflection*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">When set to true, the compiler will emit warnings when reflection is</div><div class="library-member-doc-line">  needed to resolve Java method calls or field accesses.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defaults to false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/..">..</h2><span id="var-type">macro</span><pre id="var-usage">([x form] [x form &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">form =&gt; fieldName-symbol or (instanceMethodName-symbol args*)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Expands into a member access (.) of the first member on the first</div><div class="library-member-doc-line">  argument, followed by the next member on the result, etc. For</div><div class="library-member-doc-line">  instance:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (.. System (getProperties) (get &quot;os.name&quot;))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  expands to:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (. (. System (getProperties)) (get &quot;os.name&quot;))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  but is easier to write, read, and understand.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core//">/</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">If no denominators are supplied, returns 1/numerator,</div><div class="library-member-doc-line">  else returns numerator divided by all of the denominators.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/+">+</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the sum of nums. (+) returns 0. Does not auto-promote</div><div class="library-member-doc-line">  longs, will throw on overflow. See also: +&apos;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/+&apos;">+&apos;</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the sum of nums. (+) returns 0.  Supports arbitrary precision.</div><div class="library-member-doc-line">  See also: +</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/&lt;">&lt;</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns non-nil if nums are in monotonically increasing order,</div><div class="library-member-doc-line">  otherwise false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/&lt;=">&lt;=</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns non-nil if nums are in monotonically non-decreasing order,</div><div class="library-member-doc-line">  otherwise false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/=">=</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Equality. Returns true if x equals y, false if not. Same as</div><div class="library-member-doc-line">  Java x.equals(y) except it also works for nil, and compares</div><div class="library-member-doc-line">  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data</div><div class="library-member-doc-line">  structures define equals() (and thus =) as a value, not an identity,</div><div class="library-member-doc-line">  comparison.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/==">==</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns non-nil if nums all have the equivalent</div><div class="library-member-doc-line">  value (type-independent), otherwise false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/&gt;">&gt;</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns non-nil if nums are in monotonically decreasing order,</div><div class="library-member-doc-line">  otherwise false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;">-&gt;</h2><span id="var-type">macro</span><pre id="var-usage">([x] [x form] [x form &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Threads the expr through the forms. Inserts x as the</div><div class="library-member-doc-line">  second item in the first form, making a list of it if it is not a</div><div class="library-member-doc-line">  list already. If there are more forms, inserts the first form as the</div><div class="library-member-doc-line">  second item in second form, etc.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/&gt;=">&gt;=</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns non-nil if nums are in monotonically non-increasing order,</div><div class="library-member-doc-line">  otherwise false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;&gt;">-&gt;&gt;</h2><span id="var-type">macro</span><pre id="var-usage">([x form] [x form &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Threads the expr through the forms. Inserts x as the</div><div class="library-member-doc-line">  last item in the first form, making a list of it if it is not a</div><div class="library-member-doc-line">  list already. If there are more forms, inserts the first form as the</div><div class="library-member-doc-line">  last item in second form, etc.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;ArrayChunk">-&gt;ArrayChunk</h2><span id="var-type">fn</span><pre id="var-usage">([am arr off end])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;Vec">-&gt;Vec</h2><span id="var-type">fn</span><pre id="var-usage">([am cnt shift root tail _meta])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;VecNode">-&gt;VecNode</h2><span id="var-type">fn</span><pre id="var-usage">([edit arr])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-&gt;VecSeq">-&gt;VecSeq</h2><span id="var-type">fn</span><pre id="var-usage">([am vec anode i offset])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/accessor">accessor</h2><span id="var-type">fn</span><pre id="var-usage">([s key])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a fn that, given an instance of a structmap with the basis,</div><div class="library-member-doc-line">  returns the value at the key.  The key must be in the basis. The</div><div class="library-member-doc-line">  returned function should be (slightly) more efficient than using</div><div class="library-member-doc-line">  get, but such use of accessors should be limited to known</div><div class="library-member-doc-line">  performance-critical areas.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aclone">aclone</h2><span id="var-type">fn</span><pre id="var-usage">([array])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a clone of the Java array. Works on arrays of known</div><div class="library-member-doc-line">  types.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/add-watch">add-watch</h2><span id="var-type">fn</span><pre id="var-usage">([reference key fn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Adds a watch function to an agent/atom/var/ref reference. The watch</div><div class="library-member-doc-line">  fn must be a fn of 4 args: a key, the reference, its old-state, its</div><div class="library-member-doc-line">  new-state. Whenever the reference&apos;s state might have been changed,</div><div class="library-member-doc-line">  any registered watches will have their functions called. The watch fn</div><div class="library-member-doc-line">  will be called synchronously, on the agent&apos;s thread if an agent,</div><div class="library-member-doc-line">  before any pending sends if agent or ref. Note that an atom&apos;s or</div><div class="library-member-doc-line">  ref&apos;s state may have changed again prior to the fn call, so use</div><div class="library-member-doc-line">  old/new-state rather than derefing the reference. Note also that watch</div><div class="library-member-doc-line">  fns may be called from multiple threads simultaneously. Var watchers</div><div class="library-member-doc-line">  are triggered only by root binding changes, not thread-local</div><div class="library-member-doc-line">  set!s. Keys must be unique per reference, and can be used to remove</div><div class="library-member-doc-line">  the watch with remove-watch, but are otherwise considered opaque by</div><div class="library-member-doc-line">  the watch mechanism.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/agent">agent</h2><span id="var-type">fn</span><pre id="var-usage">([state &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates and returns an agent with an initial value of state and </div><div class="library-member-doc-line">  zero or more options (in any order):</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :meta metadata-map</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :validator validate-fn</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :error-handler handler-fn</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :error-mode mode-keyword</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  If metadata-map is supplied, it will be come the metadata on the</div><div class="library-member-doc-line">  agent. validate-fn must be nil or a side-effect-free fn of one</div><div class="library-member-doc-line">  argument, which will be passed the intended new state on any state</div><div class="library-member-doc-line">  change. If the new state is unacceptable, the validate-fn should</div><div class="library-member-doc-line">  return false or throw an exception.  handler-fn is called if an</div><div class="library-member-doc-line">  action throws an exception or if validate-fn rejects a new state --</div><div class="library-member-doc-line">  see set-error-handler! for details.  The mode-keyword may be either</div><div class="library-member-doc-line">  :continue (the default if an error-handler is given) or :fail (the</div><div class="library-member-doc-line">  default if no error-handler is given) -- see set-error-mode! for</div><div class="library-member-doc-line">  details.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/agent-error">agent-error</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the exception thrown during an asynchronous action of the</div><div class="library-member-doc-line">  agent if the agent is failed.  Returns nil if the agent is not</div><div class="library-member-doc-line">  failed.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/agent-errors">agent-errors</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"><div class="library-member-doc-line">DEPRECATED: Use &apos;agent-error&apos; instead.</div><div class="library-member-doc-line">  Returns a sequence of the exceptions thrown during asynchronous</div><div class="library-member-doc-line">  actions of the agent.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aget">aget</h2><span id="var-type">fn</span><pre id="var-usage">([array idx] [array idx &amp; idxs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the value at the index/indices. Works on Java arrays of all</div><div class="library-member-doc-line">  types.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/alength">alength</h2><span id="var-type">fn</span><pre id="var-usage">([array])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the length of the Java array. Works on arrays of all</div><div class="library-member-doc-line">  types.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/alias">alias</h2><span id="var-type">fn</span><pre id="var-usage">([alias namespace-sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Add an alias in the current namespace to another</div><div class="library-member-doc-line">  namespace. Arguments are two symbols: the alias to be used, and</div><div class="library-member-doc-line">  the symbolic name of the target namespace. Use :as in the ns macro in preference</div><div class="library-member-doc-line">  to calling this directly.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/all-ns">all-ns</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sequence of all namespaces.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/alter">alter</h2><span id="var-type">fn</span><pre id="var-usage">([ref fun &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Must be called in a transaction. Sets the in-transaction-value of</div><div class="library-member-doc-line">  ref to:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply fun in-transaction-value-of-ref args)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  and returns the in-transaction-value of ref.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/alter-meta!">alter-meta!</h2><span id="var-type">fn</span><pre id="var-usage">([iref f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Atomically sets the metadata for a namespace/var/ref/agent/atom to be: </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply f its-current-meta args) </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  f must be free of side-effects</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/alter-var-root">alter-var-root</h2><span id="var-type">fn</span><pre id="var-usage">([v f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Atomically alters the root binding of var v by applying f to its</div><div class="library-member-doc-line">  current value plus any args</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/amap">amap</h2><span id="var-type">macro</span><pre id="var-usage">([a idx ret expr])</pre><pre id="var-docstr"><div class="library-member-doc-line">Maps an expression across an array a, using an index named idx, and</div><div class="library-member-doc-line">  return value named ret, initialized to a clone of a, then setting </div><div class="library-member-doc-line">  each element of ret to the evaluation of expr, returning the new </div><div class="library-member-doc-line">  array ret.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ancestors">ancestors</h2><span id="var-type">fn</span><pre id="var-usage">([tag] [h tag])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the immediate and indirect parents of tag, either via a Java type</div><div class="library-member-doc-line">  inheritance relationship or a relationship established via derive. h</div><div class="library-member-doc-line">  must be a hierarchy obtained from make-hierarchy, if not supplied</div><div class="library-member-doc-line">  defaults to the global hierarchy</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/and">and</h2><span id="var-type">macro</span><pre id="var-usage">([] [x] [x &amp; next])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates exprs one at a time, from left to right. If a form</div><div class="library-member-doc-line">  returns logical false (nil or false), and returns that value and</div><div class="library-member-doc-line">  doesn&apos;t evaluate any of the other expressions, otherwise it returns</div><div class="library-member-doc-line">  the value of the last expr. (and) returns true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/apply">apply</h2><span id="var-type">fn</span><pre id="var-usage">([f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Applies fn f to the argument list formed by prepending intervening arguments to args.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/areduce">areduce</h2><span id="var-type">macro</span><pre id="var-usage">([a idx ret init expr])</pre><pre id="var-docstr"><div class="library-member-doc-line">Reduces an expression across an array a, using an index named idx,</div><div class="library-member-doc-line">  and return value named ret, initialized to init, setting ret to the </div><div class="library-member-doc-line">  evaluation of expr at each step, returning ret.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/array?">array?</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/array-map">array-map</h2><span id="var-type">fn</span><pre id="var-usage">([] [&amp; keyvals])</pre><pre id="var-docstr"><div class="library-member-doc-line">Constructs an array-map.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset">aset</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on Java arrays of</div><div class="library-member-doc-line">  reference types. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-boolean">aset-boolean</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of boolean. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-byte">aset-byte</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of byte. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-char">aset-char</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of char. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-decimal">aset-decimal</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of decimal. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-double">aset-double</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of double. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-float">aset-float</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of float. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-int">aset-int</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of int. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-long">aset-long</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of long. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-sbyte">aset-sbyte</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of sbyte. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-short">aset-short</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of short. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-uint">aset-uint</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of uint. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-ulong">aset-ulong</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of ulong. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/aset-ushort">aset-ushort</h2><span id="var-type">fn</span><pre id="var-usage">([array idx val] [array idx idx2 &amp; idxv])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value at the index/indices. Works on arrays of ushort. Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assembly-load">assembly-load</h2><span id="var-type">fn</span><pre id="var-usage">([assembly-name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Load an assembly given its name</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assembly-load-file">assembly-load-file</h2><span id="var-type">fn</span><pre id="var-usage">([assembly-name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Load an assembly given its name</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assembly-load-from">assembly-load-from</h2><span id="var-type">fn</span><pre id="var-usage">([assembly-name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Load an assembly given its path</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assert">assert</h2><span id="var-type">macro</span><pre id="var-usage">([x] [x message])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates expr and throws an exception if it does not evaluate to</div><div class="library-member-doc-line">  logical true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assoc">assoc</h2><span id="var-type">fn</span><pre id="var-usage">([map key val] [map key val &amp; kvs])</pre><pre id="var-docstr"><div class="library-member-doc-line">assoc[iate]. When applied to a map, returns a new map of the</div><div class="library-member-doc-line">    same (hashed/sorted) type, that contains the mapping of key(s) to</div><div class="library-member-doc-line">    val(s). When applied to a vector, returns a new vector that</div><div class="library-member-doc-line">    contains val at index. Note - index must be &lt;= (count vector).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assoc!">assoc!</h2><span id="var-type">fn</span><pre id="var-usage">([coll key val] [coll key val &amp; kvs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  When applied to a transient map, adds mapping of key(s) to</div><div class="library-member-doc-line">  val(s). When applied to a transient vector, sets the val at index.</div><div class="library-member-doc-line">  Note - index must be &lt;= (count vector). Returns coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/associative?">associative?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll implements Associative</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/assoc-in">assoc-in</h2><span id="var-type">fn</span><pre id="var-usage">([m [k &amp; ks] v])</pre><pre id="var-docstr"><div class="library-member-doc-line">Associates a value in a nested associative structure, where ks is a</div><div class="library-member-doc-line">  sequence of keys and v is the new value and returns a new nested structure.</div><div class="library-member-doc-line">  If any levels do not exist, hash-maps will be created.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/atom">atom</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates and returns an Atom with an initial value of x and zero or</div><div class="library-member-doc-line">  more options (in any order):</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :meta metadata-map</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :validator validate-fn</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If metadata-map is supplied, it will be come the metadata on the</div><div class="library-member-doc-line">  atom. validate-fn must be nil or a side-effect-free fn of one</div><div class="library-member-doc-line">  argument, which will be passed the intended new state on any state</div><div class="library-member-doc-line">  change. If the new state is unacceptable, the validate-fn should</div><div class="library-member-doc-line">  return false or throw an exception.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/await">await</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; agents])</pre><pre id="var-docstr"><div class="library-member-doc-line">Blocks the current thread (indefinitely!) until all actions</div><div class="library-member-doc-line">  dispatched thus far, from this thread or agent, to the agent(s) have</div><div class="library-member-doc-line">  occurred.  Will block on failed agents.  Will never return if</div><div class="library-member-doc-line">  a failed agent is restarted with :clear-actions true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/await1">await1</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/await-for">await-for</h2><span id="var-type">fn</span><pre id="var-usage">([timeout-ms &amp; agents])</pre><pre id="var-docstr"><div class="library-member-doc-line">Blocks the current thread until all actions dispatched thus</div><div class="library-member-doc-line">  far (from this thread or agent) to the agents have occurred, or the</div><div class="library-member-doc-line">  timeout (in milliseconds) has elapsed. Returns nil if returning due</div><div class="library-member-doc-line">  to timeout, non-nil otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bases">bases</h2><span id="var-type">fn</span><pre id="var-usage">([c])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the immediate superclass and direct interfaces of c, if any</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bigdec">bigdec</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to BigDecimal</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bigint">bigint</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to BigInt</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/biginteger">biginteger</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to BigInteger</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/binding">binding</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">binding =&gt; var-symbol init-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Creates new bindings for the (already-existing) vars, with the</div><div class="library-member-doc-line">  supplied initial values, executes the exprs in an implicit do, then</div><div class="library-member-doc-line">  re-establishes the bindings that existed before.  The new bindings</div><div class="library-member-doc-line">  are made in parallel (unlike let); all init-exprs are evaluated</div><div class="library-member-doc-line">  before the vars are bound to their new values.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-and">bit-and</h2><span id="var-type">fn</span><pre id="var-usage">([x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise and</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-and-not">bit-and-not</h2><span id="var-type">fn</span><pre id="var-usage">([x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise and with complement</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-clear">bit-clear</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Clear bit at index n</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-flip">bit-flip</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Flip bit at index n</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-not">bit-not</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise complement</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-or">bit-or</h2><span id="var-type">fn</span><pre id="var-usage">([x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise or</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-set">bit-set</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Set bit at index n</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-shift-left">bit-shift-left</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise shift left</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-shift-right">bit-shift-right</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise shift right</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-test">bit-test</h2><span id="var-type">fn</span><pre id="var-usage">([x n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Test bit at index n</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bit-xor">bit-xor</h2><span id="var-type">fn</span><pre id="var-usage">([x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Bitwise exclusive or</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/boolean">boolean</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to boolean</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/boolean-array">boolean-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of booleans</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/booleans">booleans</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to boolean[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bound?">bound?</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; vars])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if all of the vars provided as arguments have any bound value, root or thread-local.</div><div class="library-member-doc-line">   Implies that deref&apos;ing the provided vars will succeed. Returns true if no vars are provided.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bound-fn">bound-fn</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; fntail])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a function defined by the given fntail, which will install the</div><div class="library-member-doc-line">  same bindings in effect as in the thread at the time bound-fn was called.</div><div class="library-member-doc-line">  This may be used to define a helper function which runs on a different</div><div class="library-member-doc-line">  thread, but needs the same bindings in place.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bound-fn*">bound-fn*</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a function, which will install the same bindings in effect as in</div><div class="library-member-doc-line">  the thread at the time bound-fn* was called and then call f with any given</div><div class="library-member-doc-line">  arguments. This may be used to define a helper function which runs on a</div><div class="library-member-doc-line">  different thread, but needs the same bindings in place.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/butlast">butlast</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return a seq of all but the last item in coll, in linear time</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/by-ref">by-ref</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"><div class="library-member-doc-line">Signals that a by-ref parameter is desired at this position in an interop call or method signature.</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Should only be used in CLR interop code.  Throws an exception otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/byte">byte</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to byte</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/byte-array">byte-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of bytes</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/bytes">bytes</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to bytes[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-cache-protocol-fn">-cache-protocol-fn</h2><span id="var-type">fn</span><pre id="var-usage">([pf x c interf])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/case">case</h2><span id="var-type">macro</span><pre id="var-usage">([e &amp; clauses])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes an expression, and a set of clauses.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Each clause can take the form of either:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  test-constant result-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (test-constant1 ... test-constantN)  result-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The test-constants are not evaluated. They must be compile-time</div><div class="library-member-doc-line">  literals, and need not be quoted.  If the expression is equal to a</div><div class="library-member-doc-line">  test-constant, the corresponding result-expr is returned. A single</div><div class="library-member-doc-line">  default expression can follow the clauses, and its value will be</div><div class="library-member-doc-line">  returned if no clause matches. If no default expression is provided</div><div class="library-member-doc-line">  and no clause matches, an IllegalArgumentException is thrown.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Unlike cond and condp, case does a constant-time dispatch, the</div><div class="library-member-doc-line">  clauses are not considered sequentially.  All manner of constant</div><div class="library-member-doc-line">  expressions are acceptable in case, including numbers, strings,</div><div class="library-member-doc-line">  symbols, keywords, and (Clojure) composites thereof. Note that since</div><div class="library-member-doc-line">  lists are used to group multiple constants that map to the same</div><div class="library-member-doc-line">  expression, a vector can be used to match a list if needed. The</div><div class="library-member-doc-line">  test-constants need not be all of the same type.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/cast">cast</h2><span id="var-type">fn</span><pre id="var-usage">([c x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Throws a ClassCastException if x is not a c, else returns x.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/char">char</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to char</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/char?">char?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x is a Character</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/char-array">char-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of chars</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/char-escape-string">char-escape-string</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Returns escape string for char or nil if none</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/char-name-string">char-name-string</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Returns name string for char or nil if none</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chars">chars</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to chars[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk">chunk</h2><span id="var-type">fn</span><pre id="var-usage">([b])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-append">chunk-append</h2><span id="var-type">fn</span><pre id="var-usage">([b x])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-buffer">chunk-buffer</h2><span id="var-type">fn</span><pre id="var-usage">([capacity])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-cons">chunk-cons</h2><span id="var-type">fn</span><pre id="var-usage">([chunk rest])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunked-seq?">chunked-seq?</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-first">chunk-first</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-next">chunk-next</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/chunk-rest">chunk-rest</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/class">class</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the Class of x</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/class?">class?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is an instance of Class</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/clear-agent-errors">clear-agent-errors</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"><div class="library-member-doc-line">DEPRECATED: Use &apos;restart-agent&apos; instead.</div><div class="library-member-doc-line">  Clears any exceptions thrown during asynchronous actions of the</div><div class="library-member-doc-line">  agent, allowing subsequent actions to occur.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/clojure-version">clojure-version</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns clojure version as a printable string.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/coll?">coll?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x implements IPersistentCollection</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/comment">comment</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Ignores body, yields nil</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/commute">commute</h2><span id="var-type">fn</span><pre id="var-usage">([ref fun &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Must be called in a transaction. Sets the in-transaction-value of</div><div class="library-member-doc-line">  ref to:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply fun in-transaction-value-of-ref args)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  and returns the in-transaction-value of ref.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  At the commit point of the transaction, sets the value of ref to be:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply fun most-recently-committed-value-of-ref args)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Thus fun should be commutative, or, failing that, you must accept</div><div class="library-member-doc-line">  last-one-in-wins behavior.  commute allows for more concurrency than</div><div class="library-member-doc-line">  ref-set.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/comp">comp</h2><span id="var-type">fn</span><pre id="var-usage">([] [f] [f g] [f g h] [f1 f2 f3 &amp; fs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a set of functions and returns a fn that is the composition</div><div class="library-member-doc-line">  of those fns.  The returned fn takes a variable number of args,</div><div class="library-member-doc-line">  applies the rightmost of fns to the args, the next</div><div class="library-member-doc-line">  fn (right-to-left) to the result, etc.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/comparator">comparator</h2><span id="var-type">fn</span><pre id="var-usage">([pred])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an implementation of java.util.Comparator based upon pred.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/compare">compare</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Comparator. Returns a negative number, zero, or a positive number</div><div class="library-member-doc-line">  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;</div><div class="library-member-doc-line">  y. Same as Java x.compareTo(y) except it also works for nil, and</div><div class="library-member-doc-line">  compares numbers and collections in a type-independent manner. x</div><div class="library-member-doc-line">  must implement Comparable</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/compare-and-set!">compare-and-set!</h2><span id="var-type">fn</span><pre id="var-usage">([atom oldval newval])</pre><pre id="var-docstr"><div class="library-member-doc-line">Atomically sets the value of atom to newval if and only if the</div><div class="library-member-doc-line">  current value of the atom is identical to oldval. Returns true if</div><div class="library-member-doc-line">  set happened, else false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/compile">compile</h2><span id="var-type">fn</span><pre id="var-usage">([lib])</pre><pre id="var-docstr"><div class="library-member-doc-line">Compiles the namespace named by the symbol lib into a set of</div><div class="library-member-doc-line">  classfiles. The source for the lib must be in a proper</div><div class="library-member-doc-line">  classpath-relative directory. The output files will go into the</div><div class="library-member-doc-line">  directory specified by *compile-path*, and that directory too must</div><div class="library-member-doc-line">  be in the classpath.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/complement">complement</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a fn f and returns a fn that takes the same arguments as f,</div><div class="library-member-doc-line">  has the same effects, if any, and returns the opposite truth value.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/concat">concat</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x y] [x y &amp; zs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq representing the concatenation of the elements in the supplied colls.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/cond">cond</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; clauses])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a set of test/expr pairs. It evaluates each test one at a</div><div class="library-member-doc-line">  time.  If a test returns logical true, cond evaluates and returns</div><div class="library-member-doc-line">  the value of the corresponding expr and doesn&apos;t evaluate any of the</div><div class="library-member-doc-line">  other tests or exprs. (cond) returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/condp">condp</h2><span id="var-type">macro</span><pre id="var-usage">([pred expr &amp; clauses])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a binary predicate, an expression, and a set of clauses.</div><div class="library-member-doc-line">  Each clause can take the form of either:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  test-expr result-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  test-expr :&gt;&gt; result-fn</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Note :&gt;&gt; is an ordinary keyword.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  For each clause, (pred test-expr expr) is evaluated. If it returns</div><div class="library-member-doc-line">  logical true, the clause is a match. If a binary clause matches, the</div><div class="library-member-doc-line">  result-expr is returned, if a ternary clause matches, its result-fn,</div><div class="library-member-doc-line">  which must be a unary function, is called with the result of the</div><div class="library-member-doc-line">  predicate as its argument, the result of that call being the return</div><div class="library-member-doc-line">  value of condp. A single default expression can follow the clauses,</div><div class="library-member-doc-line">  and its value will be returned if no clause matches. If no default</div><div class="library-member-doc-line">  expression is provided and no clause matches, an</div><div class="library-member-doc-line">  IllegalArgumentException is thrown.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/conj">conj</h2><span id="var-type">fn</span><pre id="var-usage">([coll x] [coll x &amp; xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">conj[oin]. Returns a new collection with the xs</div><div class="library-member-doc-line">    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may</div><div class="library-member-doc-line">    happen at different &apos;places&apos; depending on the concrete type.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/conj!">conj!</h2><span id="var-type">fn</span><pre id="var-usage">([coll x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Adds x to the transient collection, and return coll. The &apos;addition&apos;</div><div class="library-member-doc-line">  may happen at different &apos;places&apos; depending on the concrete type.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/cons">cons</h2><span id="var-type">fn</span><pre id="var-usage">([x seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new seq where x is the first element and seq is</div><div class="library-member-doc-line">    the rest.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/constantly">constantly</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a function that takes any number of arguments and returns x.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/construct-proxy">construct-proxy</h2><span id="var-type">fn</span><pre id="var-usage">([c &amp; ctor-args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a proxy class and any arguments for its superclass ctor and</div><div class="library-member-doc-line">  creates and returns an instance of the proxy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/contains?">contains?</h2><span id="var-type">fn</span><pre id="var-usage">([coll key])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if key is present in the given collection, otherwise</div><div class="library-member-doc-line">  returns false.  Note that for numerically indexed collections like</div><div class="library-member-doc-line">  vectors and Java arrays, this tests if the numeric key is within the</div><div class="library-member-doc-line">  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;</div><div class="library-member-doc-line">  it will not perform a linear search for a value.  See also &apos;some&apos;.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/count">count</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the number of items in the collection. (count nil) returns</div><div class="library-member-doc-line">  0.  Also works on strings, arrays, and Java Collections and Maps</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/counted?">counted?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll implements count in constant time</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/create-ns">create-ns</h2><span id="var-type">fn</span><pre id="var-usage">([sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Create a new namespace named by the symbol if one doesn&apos;t already</div><div class="library-member-doc-line">  exist, returns it or the already-existing namespace of the same</div><div class="library-member-doc-line">  name.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/create-struct">create-struct</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; keys])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a structure basis object.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/cycle">cycle</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy (infinite!) sequence of repetitions of the items in   coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dec">dec</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one less than num. Does not auto-promote</div><div class="library-member-doc-line">  longs, will throw on overflow. See also: dec&apos;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dec&apos;">dec&apos;</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one less than num.  Supports arbitrary precision.</div><div class="library-member-doc-line">  See also: dec</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/decimal">decimal</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to decimal</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/decimal?">decimal?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is a BigDecimal</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/declare">declare</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; names])</pre><pre id="var-docstr"><div class="library-member-doc-line">defs the supplied var names with no bindings, useful for making forward declarations.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/definline">definline</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; decl])</pre><pre id="var-docstr"><div class="library-member-doc-line">Experimental - like defmacro, except defines a named function whose</div><div class="library-member-doc-line">  body is the expansion, calls to which may be expanded inline as if</div><div class="library-member-doc-line">  it were a macro. Cannot be used with variadic (&amp;) args.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/definterface">definterface</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; sigs])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defmacro">defmacro</h2><span id="var-type">macro</span><pre id="var-usage">([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])</pre><pre id="var-docstr"><div class="library-member-doc-line">Like defn, but the resulting function name is declared as a</div><div class="library-member-doc-line">  macro and will be used as a macro by the compiler when it is</div><div class="library-member-doc-line">  called.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defmethod">defmethod</h2><span id="var-type">macro</span><pre id="var-usage">([multifn dispatch-val &amp; fn-tail])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates and installs a new method of multimethod associated with dispatch-value. </div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defmulti">defmulti</h2><span id="var-type">macro</span><pre id="var-usage">([name docstring? attr-map? dispatch-fn &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new multimethod with the associated dispatch function. </div><div class="library-member-doc-line">  The docstring and attribute-map are optional.  </div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Options are key-value pairs and may be one of:</div><div class="library-member-doc-line">    :default    the default dispatch value, defaults to :default</div><div class="library-member-doc-line">    :hierarchy  the isa? hierarchy to use for dispatching</div><div class="library-member-doc-line">                defaults to the global hierarchy</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defn">defn</h2><span id="var-type">macro</span><pre id="var-usage">([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (def name (fn [params* ] exprs*)) or (def</div><div class="library-member-doc-line">    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added</div><div class="library-member-doc-line">    to the var metadata</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defn-">defn-</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; decls])</pre><pre id="var-docstr"><div class="library-member-doc-line">same as defn, yielding non-public def</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defonce">defonce</h2><span id="var-type">macro</span><pre id="var-usage">([name expr])</pre><pre id="var-docstr"><div class="library-member-doc-line">defs name to have the root value of the expr iff the named var has no root value,</div><div class="library-member-doc-line">  else expr is unevaluated</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defprotocol">defprotocol</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; opts+sigs])</pre><pre id="var-docstr"><div class="library-member-doc-line">A protocol is a named set of named methods and their signatures:</div><div class="library-member-doc-line">  (defprotocol AProtocolName</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">    ;optional doc string</div><div class="library-member-doc-line">    &quot;A doc string for AProtocol abstraction&quot;</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  ;method signatures</div><div class="library-member-doc-line">    (bar [this a b] &quot;bar docs&quot;)</div><div class="library-member-doc-line">    (baz [this a] [this a b] [this a b c] &quot;baz docs&quot;))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  No implementations are provided. Docs can be specified for the</div><div class="library-member-doc-line">  protocol overall and for each method. The above yields a set of</div><div class="library-member-doc-line">  polymorphic functions and a protocol object. All are</div><div class="library-member-doc-line">  namespace-qualified by the ns enclosing the definition The resulting</div><div class="library-member-doc-line">  functions dispatch on the type of their first argument, which is</div><div class="library-member-doc-line">  required and corresponds to the implicit target object (&apos;this&apos; in </div><div class="library-member-doc-line">  Java parlance). defprotocol is dynamic, has no special compile-time </div><div class="library-member-doc-line">  effect, and defines no new types or classes. Implementations of </div><div class="library-member-doc-line">  the protocol methods can be provided using extend.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  defprotocol will automatically generate a corresponding interface,</div><div class="library-member-doc-line">  with the same name as the protocol, i.e. given a protocol:</div><div class="library-member-doc-line">  my.ns/Protocol, an interface: my.ns.Protocol. The interface will</div><div class="library-member-doc-line">  have methods corresponding to the protocol functions, and the</div><div class="library-member-doc-line">  protocol will automatically work with instances of the interface.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Note that you should not use this interface with deftype or</div><div class="library-member-doc-line">  reify, as they support the protocol directly:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (defprotocol P </div><div class="library-member-doc-line">    (foo [this]) </div><div class="library-member-doc-line">    (bar-me [this] [this y]))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (deftype Foo [a b c] </div><div class="library-member-doc-line">   P</div><div class="library-member-doc-line">    (foo [this] a)</div><div class="library-member-doc-line">    (bar-me [this] b)</div><div class="library-member-doc-line">    (bar-me [this y] (+ c y)))</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (bar-me (Foo. 1 2 3) 42)</div><div class="library-member-doc-line">  =&gt; 45</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (foo </div><div class="library-member-doc-line">    (let [x 42]</div><div class="library-member-doc-line">      (reify P </div><div class="library-member-doc-line">        (foo [this] 17)</div><div class="library-member-doc-line">        (bar-me [this] x)</div><div class="library-member-doc-line">        (bar-me [this y] x))))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defrecord">defrecord</h2><span id="var-type">macro</span><pre id="var-usage">([name [&amp; fields] &amp; opts+specs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (defrecord name [fields*]  options* specs*)</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Currently there are no options.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Each spec consists of a protocol or interface name followed by zero</div><div class="library-member-doc-line">  or more method bodies:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  protocol-or-interface-or-Object</div><div class="library-member-doc-line">  (methodName [args*] body)*</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Dynamically generates compiled bytecode for class with the given</div><div class="library-member-doc-line">  name, in a package with the same name as the current namespace, the</div><div class="library-member-doc-line">  given fields, and, optionally, methods for protocols and/or</div><div class="library-member-doc-line">  interfaces.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">   The class will have the (immutable) fields named by</div><div class="library-member-doc-line">  fields, which can have type hints. Protocols/interfaces and methods</div><div class="library-member-doc-line">  are optional. The only methods that can be supplied are those</div><div class="library-member-doc-line">  declared in the protocols/interfaces.  Note that method bodies are</div><div class="library-member-doc-line">  not closures, the local environment includes only the named fields,</div><div class="library-member-doc-line">  and those fields can be accessed directy. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Method definitions take the form:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (methodname [args*] body)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The argument and return types can be hinted on the arg and</div><div class="library-member-doc-line">  methodname symbols. If not supplied, they will be inferred, so type</div><div class="library-member-doc-line">  hints should be reserved for disambiguation.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Methods should be supplied for all methods of the desired</div><div class="library-member-doc-line">  protocol(s) and interface(s). You can also define overrides for</div><div class="library-member-doc-line">  methods of Object. Note that a parameter must be supplied to</div><div class="library-member-doc-line">  correspond to the target object (&apos;this&apos; in Java parlance). Thus</div><div class="library-member-doc-line">  methods for interfaces will take one more argument than do the</div><div class="library-member-doc-line">  interface declarations. Note also that recur calls to the method</div><div class="library-member-doc-line">  head should *not* pass the target object, it will be supplied</div><div class="library-member-doc-line">  automatically and can not be substituted.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  In the method bodies, the (unqualified) name can be used to name the</div><div class="library-member-doc-line">  class (for calls to new, instance? etc).</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The class will have implementations of several (clojure.lang)</div><div class="library-member-doc-line">  interfaces generated automatically: IObj (metadata support) and</div><div class="library-member-doc-line">  IPersistentMap, and all of their superinterfaces.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  In addition, defrecord will define type-and-value-based =,</div><div class="library-member-doc-line">  and will defined Java .hashCode and .equals consistent with the</div><div class="library-member-doc-line">  contract for java.util.Map.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  When AOT compiling, generates compiled bytecode for a class with the</div><div class="library-member-doc-line">  given name (a symbol), prepends the current ns as the package, and</div><div class="library-member-doc-line">  writes the .class file to the *compile-path* directory.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Two constructors will be defined, one taking the designated fields</div><div class="library-member-doc-line">  followed by a metadata map (nil for none) and an extension field</div><div class="library-member-doc-line">  map (nil for none), and one taking only the fields (using nil for</div><div class="library-member-doc-line">  meta and extension fields).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/defstruct">defstruct</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; keys])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (def name (create-struct keys...))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/deftype">deftype</h2><span id="var-type">macro</span><pre id="var-usage">([name [&amp; fields] &amp; opts+specs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (deftype name [fields*]  options* specs*)</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Currently there are no options.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Each spec consists of a protocol or interface name followed by zero</div><div class="library-member-doc-line">  or more method bodies:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  protocol-or-interface-or-Object</div><div class="library-member-doc-line">  (methodName [args*] body)*</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Dynamically generates compiled bytecode for class with the given</div><div class="library-member-doc-line">  name, in a package with the same name as the current namespace, the</div><div class="library-member-doc-line">  given fields, and, optionally, methods for protocols and/or</div><div class="library-member-doc-line">  interfaces. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The class will have the (by default, immutable) fields named by</div><div class="library-member-doc-line">  fields, which can have type hints. Protocols/interfaces and methods</div><div class="library-member-doc-line">  are optional. The only methods that can be supplied are those</div><div class="library-member-doc-line">  declared in the protocols/interfaces.  Note that method bodies are</div><div class="library-member-doc-line">  not closures, the local environment includes only the named fields,</div><div class="library-member-doc-line">  and those fields can be accessed directy. Fields can be qualified</div><div class="library-member-doc-line">  with the metadata :volatile-mutable true or :unsynchronized-mutable</div><div class="library-member-doc-line">  true, at which point (set! afield aval) will be supported in method</div><div class="library-member-doc-line">  bodies. Note well that mutable fields are extremely difficult to use</div><div class="library-member-doc-line">  correctly, and are present only to facilitate the building of higher</div><div class="library-member-doc-line">  level constructs, such as Clojure&apos;s reference types, in Clojure</div><div class="library-member-doc-line">  itself. They are for experts only - if the semantics and</div><div class="library-member-doc-line">  implications of :volatile-mutable or :unsynchronized-mutable are not</div><div class="library-member-doc-line">  immediately apparent to you, you should not be using them.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Method definitions take the form:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (methodname [args*] body)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The argument and return types can be hinted on the arg and</div><div class="library-member-doc-line">  methodname symbols. If not supplied, they will be inferred, so type</div><div class="library-member-doc-line">  hints should be reserved for disambiguation.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Methods should be supplied for all methods of the desired</div><div class="library-member-doc-line">  protocol(s) and interface(s). You can also define overrides for</div><div class="library-member-doc-line">  methods of Object. Note that a parameter must be supplied to</div><div class="library-member-doc-line">  correspond to the target object (&apos;this&apos; in Java parlance). Thus</div><div class="library-member-doc-line">  methods for interfaces will take one more argument than do the</div><div class="library-member-doc-line">  interface declarations. Note also that recur calls to the method</div><div class="library-member-doc-line">  head should *not* pass the target object, it will be supplied</div><div class="library-member-doc-line">  automatically and can not be substituted.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  In the method bodies, the (unqualified) name can be used to name the</div><div class="library-member-doc-line">  class (for calls to new, instance? etc).</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  When AOT compiling, generates compiled bytecode for a class with the</div><div class="library-member-doc-line">  given name (a symbol), prepends the current ns as the package, and</div><div class="library-member-doc-line">  writes the .class file to the *compile-path* directory.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  One constructors will be defined, taking the designated fields.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/delay">delay</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a body of expressions and yields a Delay object than will</div><div class="library-member-doc-line">  invoke the body only the first time it is forced (with force or deref/@), and</div><div class="library-member-doc-line">  will cache the result and return it on all subsequent force</div><div class="library-member-doc-line">  calls. See also - realized?</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/delay?">delay?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">returns true if x is a Delay created with delay</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/deliver">deliver</h2><span id="var-type">fn</span><pre id="var-usage">([promise val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Delivers the supplied value to the promise, releasing any pending</div><div class="library-member-doc-line">  derefs. A subsequent call to deliver on a promise will throw an exception.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/denominator">denominator</h2><span id="var-type">fn</span><pre id="var-usage">([r])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the denominator part of a Ratio.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/deref">deref</h2><span id="var-type">fn</span><pre id="var-usage">([ref] [ref timeout-ms timeout-val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,</div><div class="library-member-doc-line">  returns the in-transaction-value of ref, else returns the</div><div class="library-member-doc-line">  most-recently-committed value of ref. When applied to a var, agent</div><div class="library-member-doc-line">  or atom, returns its current state. When applied to a delay, forces</div><div class="library-member-doc-line">  it if not already forced. When applied to a future, will block if</div><div class="library-member-doc-line">  computation not complete. When applied to a promise, will block</div><div class="library-member-doc-line">  until a value is delivered.  The variant taking a timeout can be</div><div class="library-member-doc-line">  used for blocking references (futures and promises), and will return</div><div class="library-member-doc-line">  timeout-val if the timeout (in milliseconds) is reached before a</div><div class="library-member-doc-line">  value is available. See also - realized?.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/derive">derive</h2><span id="var-type">fn</span><pre id="var-usage">([tag parent] [h tag parent])</pre><pre id="var-docstr"><div class="library-member-doc-line">Establishes a parent/child relationship between parent and</div><div class="library-member-doc-line">  tag. Parent must be a namespace-qualified symbol or keyword and</div><div class="library-member-doc-line">  child can be either a namespace-qualified symbol or keyword or a</div><div class="library-member-doc-line">  class. h must be a hierarchy obtained from make-hierarchy, if not</div><div class="library-member-doc-line">  supplied defaults to, and modifies, the global hierarchy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/descendants">descendants</h2><span id="var-type">fn</span><pre id="var-usage">([tag] [h tag])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the immediate and indirect children of tag, through a</div><div class="library-member-doc-line">  relationship established via derive. h must be a hierarchy obtained</div><div class="library-member-doc-line">  from make-hierarchy, if not supplied defaults to the global</div><div class="library-member-doc-line">  hierarchy. Note: does not work on Java type inheritance</div><div class="library-member-doc-line">  relationships.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/destructure">destructure</h2><span id="var-type">fn</span><pre id="var-usage">([bindings])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/disj">disj</h2><span id="var-type">fn</span><pre id="var-usage">([set] [set key] [set key &amp; ks])</pre><pre id="var-docstr"><div class="library-member-doc-line">disj[oin]. Returns a new set of the same (hashed/sorted) type, that</div><div class="library-member-doc-line">  does not contain key(s).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/disj!">disj!</h2><span id="var-type">fn</span><pre id="var-usage">([set] [set key] [set key &amp; ks])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that</div><div class="library-member-doc-line">  does not contain key(s).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dissoc">dissoc</h2><span id="var-type">fn</span><pre id="var-usage">([map] [map key] [map key &amp; ks])</pre><pre id="var-docstr"><div class="library-member-doc-line">dissoc[iate]. Returns a new map of the same (hashed/sorted) type,</div><div class="library-member-doc-line">  that does not contain a mapping for key(s).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dissoc!">dissoc!</h2><span id="var-type">fn</span><pre id="var-usage">([map key] [map key &amp; ks])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Returns a transient map that doesn&apos;t contain a mapping for key(s).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/distinct">distinct</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the elements of coll with duplicates removed</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/distinct?">distinct?</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if no two of the arguments are =</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/doall">doall</h2><span id="var-type">fn</span><pre id="var-usage">([coll] [n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">When lazy sequences are produced via functions that have side</div><div class="library-member-doc-line">  effects, any effects other than those needed to produce the first</div><div class="library-member-doc-line">  element in the seq do not occur until the seq is consumed. doall can</div><div class="library-member-doc-line">  be used to force any effects. Walks through the successive nexts of</div><div class="library-member-doc-line">  the seq, retains the head and returns it, thus causing the entire</div><div class="library-member-doc-line">  seq to reside in memory at one time.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dorun">dorun</h2><span id="var-type">fn</span><pre id="var-usage">([coll] [n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">When lazy sequences are produced via functions that have side</div><div class="library-member-doc-line">  effects, any effects other than those needed to produce the first</div><div class="library-member-doc-line">  element in the seq do not occur until the seq is consumed. dorun can</div><div class="library-member-doc-line">  be used to force any effects. Walks through the successive nexts of</div><div class="library-member-doc-line">  the seq, does not retain the head and returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/doseq">doseq</h2><span id="var-type">macro</span><pre id="var-usage">([seq-exprs &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Repeatedly executes body (presumably for side-effects) with</div><div class="library-member-doc-line">  bindings and filtering as provided by &quot;for&quot;.  Does not retain</div><div class="library-member-doc-line">  the head of the sequence. Returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dosync">dosync</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; exprs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Runs the exprs (in an implicit do) in a transaction that encompasses</div><div class="library-member-doc-line">  exprs and any nested calls.  Starts a transaction if none is already</div><div class="library-member-doc-line">  running on this thread. Any uncaught exception will abort the</div><div class="library-member-doc-line">  transaction and flow out of dosync. The exprs may be run more than</div><div class="library-member-doc-line">  once, but any effects on Refs will be atomic.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/dotimes">dotimes</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">bindings =&gt; name n</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Repeatedly executes body (presumably for side-effects) with name</div><div class="library-member-doc-line">  bound to integers from 0 through n-1.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/doto">doto</h2><span id="var-type">macro</span><pre id="var-usage">([x &amp; forms])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates x then calls all of the methods and functions with the</div><div class="library-member-doc-line">  value of x supplied at the front of the given arguments.  The forms</div><div class="library-member-doc-line">  are evaluated in order.  Returns x.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (doto (new java.util.HashMap) (.put &quot;a&quot; 1) (.put &quot;b&quot; 2))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/double">double</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to double</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/double-array">double-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of doubles</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/doubles">doubles</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to double[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/drop">drop</h2><span id="var-type">fn</span><pre id="var-usage">([n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of all but the first n items in coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/drop-last">drop-last</h2><span id="var-type">fn</span><pre id="var-usage">([s] [n s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return a lazy sequence of all but the last n (default 1) items in coll</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/drop-while">drop-while</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the items in coll starting from the first</div><div class="library-member-doc-line">  item for which (pred item) returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/empty">empty</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an empty collection of the same category as coll, or nil</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/empty?">empty?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll has no items - same as (not (seq coll)).</div><div class="library-member-doc-line">  Please use the idiom (seq x) rather than (not (empty? x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/EMPTY-NODE">EMPTY-NODE</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ensure">ensure</h2><span id="var-type">fn</span><pre id="var-usage">([ref])</pre><pre id="var-docstr"><div class="library-member-doc-line">Must be called in a transaction. Protects the ref from modification</div><div class="library-member-doc-line">  by other transactions.  Returns the in-transaction-value of</div><div class="library-member-doc-line">  ref. Allows for more concurrency than (ref-set ref @ref)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/enum?">enum?</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/enum-and">enum-and</h2><span id="var-type">fn</span><pre id="var-usage">([flag &amp; flags])</pre><pre id="var-docstr"><div class="library-member-doc-line">Combine via and several enum (flag values).  Coerced to type of first value.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/enumeration-seq">enumeration-seq</h2><span id="var-type">fn</span><pre id="var-usage">([e])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq on a java.util.Enumeration</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/enum-or">enum-or</h2><span id="var-type">fn</span><pre id="var-usage">([flag &amp; flags])</pre><pre id="var-docstr"><div class="library-member-doc-line">Combine via or several enum (flag values).  Coerced to type of first value.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/enum-val">enum-val</h2><span id="var-type">fn</span><pre id="var-usage">([t n])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/error-handler">error-handler</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the error-handler of agent a, or nil if there is none.</div><div class="library-member-doc-line">  See set-error-handler!</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/error-mode">error-mode</h2><span id="var-type">fn</span><pre id="var-usage">([a])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the error-mode of agent a.  See set-error-mode!</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/eval">eval</h2><span id="var-type">fn</span><pre id="var-usage">([form])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates the form data structure (not text!) and returns the result.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/even?">even?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is even, throws an exception if n is not an integer</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/every?">every?</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if (pred x) is logical true for every x in coll, else</div><div class="library-member-doc-line">  false.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/every-pred">every-pred</h2><span id="var-type">fn</span><pre id="var-usage">([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 &amp; ps])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a set of predicates and returns a function f that returns true if all of its</div><div class="library-member-doc-line">  composing predicates return a logical true value against all of its arguments, else it returns</div><div class="library-member-doc-line">  false. Note that f is short-circuiting in that it will stop execution on the first</div><div class="library-member-doc-line">  argument that triggers a logical false result against the original predicates.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/extend">extend</h2><span id="var-type">fn</span><pre id="var-usage">([atype &amp; proto+mmaps])</pre><pre id="var-docstr"><div class="library-member-doc-line">Implementations of protocol methods can be provided using the extend construct:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (extend AType</div><div class="library-member-doc-line">    AProtocol</div><div class="library-member-doc-line">     {:foo an-existing-fn</div><div class="library-member-doc-line">      :bar (fn [a b] ...)</div><div class="library-member-doc-line">      :baz (fn ([a]...) ([a b] ...)...)}</div><div class="library-member-doc-line">    BProtocol </div><div class="library-member-doc-line">      {...} </div><div class="library-member-doc-line">    ...)</div><div class="library-member-doc-line"> </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  extend takes a type/class (or interface, see below), and one or more</div><div class="library-member-doc-line">  protocol + method map pairs. It will extend the polymorphism of the</div><div class="library-member-doc-line">  protocol&apos;s methods to call the supplied methods when an AType is</div><div class="library-member-doc-line">  provided as the first argument. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Method maps are maps of the keyword-ized method names to ordinary</div><div class="library-member-doc-line">  fns. This facilitates easy reuse of existing fns and fn maps, for</div><div class="library-member-doc-line">  code reuse/mixins without derivation or composition. You can extend</div><div class="library-member-doc-line">  an interface to a protocol. This is primarily to facilitate interop</div><div class="library-member-doc-line">  with the host (e.g. Java) but opens the door to incidental multiple</div><div class="library-member-doc-line">  inheritance of implementation since a class can inherit from more</div><div class="library-member-doc-line">  than one interface, both of which extend the protocol. It is TBD how</div><div class="library-member-doc-line">  to specify which impl to use. You can extend a protocol on nil.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If you are supplying the definitions explicitly (i.e. not reusing</div><div class="library-member-doc-line">  exsting functions or mixin maps), you may find it more convenient to</div><div class="library-member-doc-line">  use the extend-type or extend-protocol macros.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Note that multiple independent extend clauses can exist for the same</div><div class="library-member-doc-line">  type, not all protocols need be defined in a single extend call.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  See also:</div><div class="library-member-doc-line">  extends?, satisfies?, extenders</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/extenders">extenders</h2><span id="var-type">fn</span><pre id="var-usage">([protocol])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a collection of the types explicitly extending protocol</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/extend-protocol">extend-protocol</h2><span id="var-type">macro</span><pre id="var-usage">([p &amp; specs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Useful when you want to provide several implementations of the same</div><div class="library-member-doc-line">  protocol all at once. Takes a single protocol and the implementation</div><div class="library-member-doc-line">  of that protocol for one or more types. Expands into calls to</div><div class="library-member-doc-line">  extend-type and extend-class:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (extend-protocol Protocol</div><div class="library-member-doc-line">    AType</div><div class="library-member-doc-line">      (foo [x] ...)</div><div class="library-member-doc-line">      (bar [x y] ...)</div><div class="library-member-doc-line">    BType</div><div class="library-member-doc-line">      (foo [x] ...)</div><div class="library-member-doc-line">      (bar [x y] ...)</div><div class="library-member-doc-line">    AClass</div><div class="library-member-doc-line">      (foo [x] ...)</div><div class="library-member-doc-line">      (bar [x y] ...)</div><div class="library-member-doc-line">    nil</div><div class="library-member-doc-line">      (foo [x] ...)</div><div class="library-member-doc-line">      (bar [x y] ...))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  expands into:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (do</div><div class="library-member-doc-line">   (clojure.core/extend-type AType Protocol </div><div class="library-member-doc-line">     (foo [x] ...) </div><div class="library-member-doc-line">     (bar [x y] ...))</div><div class="library-member-doc-line">   (clojure.core/extend-type BType Protocol </div><div class="library-member-doc-line">     (foo [x] ...) </div><div class="library-member-doc-line">     (bar [x y] ...))</div><div class="library-member-doc-line">   (clojure.core/extend-type AClass Protocol </div><div class="library-member-doc-line">     (foo [x] ...) </div><div class="library-member-doc-line">     (bar [x y] ...))</div><div class="library-member-doc-line">   (clojure.core/extend-type nil Protocol </div><div class="library-member-doc-line">     (foo [x] ...) </div><div class="library-member-doc-line">     (bar [x y] ...)))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/extends?">extends?</h2><span id="var-type">fn</span><pre id="var-usage">([protocol atype])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if atype  extends protocol</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/extend-type">extend-type</h2><span id="var-type">macro</span><pre id="var-usage">([t &amp; specs])</pre><pre id="var-docstr"><div class="library-member-doc-line">A macro that expands into an extend call. Useful when you are</div><div class="library-member-doc-line">  supplying the definitions explicitly inline, extend-type</div><div class="library-member-doc-line">  automatically creates the maps required by extend. Propagates the</div><div class="library-member-doc-line">  class as a type hint on the first argument of all fns.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (extend-type MyType </div><div class="library-member-doc-line">    Countable</div><div class="library-member-doc-line">      (cnt [c] ...)</div><div class="library-member-doc-line">    Foo</div><div class="library-member-doc-line">      (bar [x y] ...)</div><div class="library-member-doc-line">      (baz ([x] ...) ([x y &amp; zs] ...)))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  expands into:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (extend MyType</div><div class="library-member-doc-line">   Countable</div><div class="library-member-doc-line">     {:cnt (fn [c] ...)}</div><div class="library-member-doc-line">   Foo</div><div class="library-member-doc-line">     {:baz (fn ([x] ...) ([x y &amp; zs] ...))</div><div class="library-member-doc-line">      :bar (fn [x y] ...)})</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/false?">false?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is the value false, false otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ffirst">ffirst</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (first (first x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/file-seq">file-seq</h2><span id="var-type">fn</span><pre id="var-usage">([dir])</pre><pre id="var-docstr"><div class="library-member-doc-line">A tree seq on java.io.Files</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/filter">filter</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the items in coll for which</div><div class="library-member-doc-line">  (pred item) returns true. pred must be free of side-effects.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find">find</h2><span id="var-type">fn</span><pre id="var-usage">([map key])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the map entry for key, or nil if key not present.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find-keyword">find-keyword</h2><span id="var-type">fn</span><pre id="var-usage">([name] [ns name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a Keyword with the given namespace and name if one already</div><div class="library-member-doc-line">  exists.  This function will not intern a new keyword. If the keyword</div><div class="library-member-doc-line">  has not already been interned, it will return nil.  Do not use :</div><div class="library-member-doc-line">  in the keyword strings, it will be added automatically.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find-ns">find-ns</h2><span id="var-type">fn</span><pre id="var-usage">([sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the namespace named by the symbol or nil if it doesn&apos;t exist.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find-protocol-impl">find-protocol-impl</h2><span id="var-type">fn</span><pre id="var-usage">([protocol x])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find-protocol-method">find-protocol-method</h2><span id="var-type">fn</span><pre id="var-usage">([protocol methodk x])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/find-var">find-var</h2><span id="var-type">fn</span><pre id="var-usage">([sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the global var named by the namespace-qualified symbol, or</div><div class="library-member-doc-line">  nil if no var with that name.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/first">first</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the first item in the collection. Calls seq on its</div><div class="library-member-doc-line">   argument. If coll is nil, returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/flatten">flatten</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes any nested combination of sequential things (lists, vectors,</div><div class="library-member-doc-line">  etc.) and returns their contents as a single, flat sequence.</div><div class="library-member-doc-line">  (flatten nil) returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/float">float</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to float</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/float?">float?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is a floating point number</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/float-array">float-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of floats</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/floats">floats</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to float[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/flush">flush</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Flushes the output stream that is the current value of</div><div class="library-member-doc-line">  *out*</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/fn">fn</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; sigs])</pre><pre id="var-docstr"><div class="library-member-doc-line">params =&gt; positional-params* , or positional-params* &amp; next-param</div><div class="library-member-doc-line">  positional-param =&gt; binding-form</div><div class="library-member-doc-line">  next-param =&gt; binding-form</div><div class="library-member-doc-line">  name =&gt; symbol</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Defines a function</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/fn?">fn?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x implements Fn, i.e. is an object created via fn.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/fnext">fnext</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (first (next x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/fnil">fnil</h2><span id="var-type">fn</span><pre id="var-usage">([f x] [f x y] [f x y z])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a function f, and returns a function that calls f, replacing</div><div class="library-member-doc-line">  a nil first argument to f with the supplied value x. Higher arity</div><div class="library-member-doc-line">  versions can replace arguments in the second and third</div><div class="library-member-doc-line">  positions (y, z). Note that the function f can take any number of</div><div class="library-member-doc-line">  arguments, not just the one(s) being nil-patched.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/for">for</h2><span id="var-type">macro</span><pre id="var-usage">([seq-exprs body-expr])</pre><pre id="var-docstr"><div class="library-member-doc-line">List comprehension. Takes a vector of one or more</div><div class="library-member-doc-line">   binding-form/collection-expr pairs, each followed by zero or more</div><div class="library-member-doc-line">   modifiers, and yields a lazy sequence of evaluations of expr.</div><div class="library-member-doc-line">   Collections are iterated in a nested fashion, rightmost fastest,</div><div class="library-member-doc-line">   and nested coll-exprs can refer to bindings created in prior</div><div class="library-member-doc-line">   binding-forms.  Supported modifiers are: :let [binding-form expr ...],</div><div class="library-member-doc-line">   :while test, :when test.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/force">force</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">If x is a Delay, returns the (possibly cached) value of its expression, else returns x</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/format">format</h2><span id="var-type">fn</span><pre id="var-usage">([fmt &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Formats a string using java.lang.String.format, see java.util.Formatter for format</div><div class="library-member-doc-line">  string syntax</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/frequencies">frequencies</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map from distinct items in coll to the number of times</div><div class="library-member-doc-line">  they appear.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future">future</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a body of expressions and yields a future object that will</div><div class="library-member-doc-line">  invoke the body in another thread, and will cache the result and</div><div class="library-member-doc-line">  return it on all subsequent calls to deref/@. If the computation has</div><div class="library-member-doc-line">  not yet finished, calls to deref/@ will block, unless the variant of</div><div class="library-member-doc-line">  deref with timeout is used. See also - realized?..</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future?">future?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is a future</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future-call">future-call</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a function of no args and yields a future object that will</div><div class="library-member-doc-line">  invoke the function in another thread, and will cache the result and</div><div class="library-member-doc-line">  return it on all subsequent calls to deref/@. If the computation has</div><div class="library-member-doc-line">  not yet finished, calls to deref/@ will block, unless the variant</div><div class="library-member-doc-line">  of deref with timeout is used. See also - realized?.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future-cancel">future-cancel</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Cancels the future, if possible.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future-cancelled?">future-cancelled?</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if future f is cancelled</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/future-done?">future-done?</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if future f is done</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/gen-class">gen-class</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">When compiling, generates compiled bytecode for a class with the</div><div class="library-member-doc-line">  given package-qualified :name (which, as all names in these</div><div class="library-member-doc-line">  parameters, can be a string or symbol), and writes the .class file</div><div class="library-member-doc-line">  to the *compile-path* directory.  When not compiling, does</div><div class="library-member-doc-line">  nothing. The gen-class construct contains no implementation, as the</div><div class="library-member-doc-line">  implementation will be dynamically sought by the generated class in</div><div class="library-member-doc-line">  functions in an implementing Clojure namespace. Given a generated</div><div class="library-member-doc-line">  class org.mydomain.MyClass with a method named mymethod, gen-class</div><div class="library-member-doc-line">  will generate an implementation that looks for a function named by </div><div class="library-member-doc-line">  (str prefix mymethod) (default prefix: &quot;-&quot;) in a</div><div class="library-member-doc-line">  Clojure namespace specified by :impl-ns</div><div class="library-member-doc-line">  (defaults to the current namespace). All inherited methods,</div><div class="library-member-doc-line">  generated methods, and init and main functions (see :methods, :init,</div><div class="library-member-doc-line">  and :main below) will be found similarly prefixed. By default, the</div><div class="library-member-doc-line">  static initializer for the generated class will attempt to load the</div><div class="library-member-doc-line">  Clojure support code for the class as a resource from the classpath,</div><div class="library-member-doc-line">  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This</div><div class="library-member-doc-line">  behavior can be controlled by :load-impl-ns</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Note that methods with a maximum of 18 parameters are supported.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  In all subsequent sections taking types, the primitive types can be</div><div class="library-member-doc-line">  referred to by their Java names (int, float etc), and classes in the</div><div class="library-member-doc-line">  java.lang package can be used without a package qualifier. All other</div><div class="library-member-doc-line">  classes must be fully qualified.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Options should be a set of key/value pairs, all except for :name are optional:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :name aname</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The package-qualified name of the class to be generated</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :extends aclass</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Specifies the superclass, the non-private methods of which will be</div><div class="library-member-doc-line">  overridden by the class. If not provided, defaults to Object.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :implements [interface ...]</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  One or more interfaces, the methods of which will be implemented by the class.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :init name</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If supplied, names a function that will be called with the arguments</div><div class="library-member-doc-line">  to the constructor. Must return [ [superclass-constructor-args] state] </div><div class="library-member-doc-line">  If not supplied, the constructor args are passed directly to</div><div class="library-member-doc-line">  the superclass constructor and the state will be nil</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :constructors {[param-types] [super-param-types], ...}</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  By default, constructors are created for the generated class which</div><div class="library-member-doc-line">  match the signature(s) of the constructors for the superclass. This</div><div class="library-member-doc-line">  parameter may be used to explicitly specify constructors, each entry</div><div class="library-member-doc-line">  providing a mapping from a constructor signature to a superclass</div><div class="library-member-doc-line">  constructor signature. When you supply this, you must supply an :init</div><div class="library-member-doc-line">  specifier. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :post-init name</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If supplied, names a function that will be called with the object as</div><div class="library-member-doc-line">  the first argument, followed by the arguments to the constructor.</div><div class="library-member-doc-line">  It will be called every time an object of this class is created,</div><div class="library-member-doc-line">  immediately after all the inherited constructors have completed.</div><div class="library-member-doc-line">  It&apos;s return value is ignored.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :methods [ [name [param-types] return-type], ...]</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The generated class automatically defines all of the non-private</div><div class="library-member-doc-line">  methods of its superclasses/interfaces. This parameter can be used</div><div class="library-member-doc-line">  to specify the signatures of additional methods of the generated</div><div class="library-member-doc-line">  class. Static methods can be specified with ^{:static true} in the</div><div class="library-member-doc-line">  signature&apos;s metadata. Do not repeat superclass/interface signatures</div><div class="library-member-doc-line">  here.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :main boolean</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If supplied and true, a static public main function will be generated. It will</div><div class="library-member-doc-line">  pass each string of the String[] argument as a separate argument to</div><div class="library-member-doc-line">  a function called (str prefix main).</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :factory name</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If supplied, a (set of) public static factory function(s) will be</div><div class="library-member-doc-line">  created with the given name, and the same signature(s) as the</div><div class="library-member-doc-line">  constructor(s).</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  :state name</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If supplied, a public final instance field with the given name will be</div><div class="library-member-doc-line">  created. You must supply an :init function in order to provide a</div><div class="library-member-doc-line">  value for the state. Note that, though final, the state can be a ref</div><div class="library-member-doc-line">  or agent, supporting the creation of Java objects with transactional</div><div class="library-member-doc-line">  or asynchronous mutation semantics.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :exposes {protected-field-name {:get name :set name}, ...}</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Since the implementations of the methods of the generated class</div><div class="library-member-doc-line">  occur in Clojure functions, they have no access to the inherited</div><div class="library-member-doc-line">  protected fields of the superclass. This parameter can be used to</div><div class="library-member-doc-line">  generate public getter/setter methods exposing the protected field(s)</div><div class="library-member-doc-line">  for use in the implementation.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :exposes-methods {super-method-name exposed-name, ...}</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  It is sometimes necessary to call the superclass&apos; implementation of an</div><div class="library-member-doc-line">  overridden method.  Those methods may be exposed and referred in </div><div class="library-member-doc-line">  the new method implementation by a local name.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :prefix string</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Default: &quot;-&quot; Methods called e.g. Foo will be looked up in vars called</div><div class="library-member-doc-line">  prefixFoo in the implementing ns.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :impl-ns name</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Default: the name of the current ns. Implementations of methods will be </div><div class="library-member-doc-line">  looked up in this namespace.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :load-impl-ns boolean</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Default: true. Causes the static initializer for the generated class</div><div class="library-member-doc-line">  to reference the load code for the implementing namespace. Should be</div><div class="library-member-doc-line">  true when implementing-ns is the default, false if you intend to</div><div class="library-member-doc-line">  load the code via some other method.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/gen-delegate">gen-delegate</h2><span id="var-type">macro</span><pre id="var-usage">([type argVec &amp; body])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/gen-interface">gen-interface</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">When compiling, generates compiled bytecode for an interface with</div><div class="library-member-doc-line">  the given package-qualified :name (which, as all names in these</div><div class="library-member-doc-line">  parameters, can be a string or symbol), and writes the .class file</div><div class="library-member-doc-line">  to the *compile-path* directory.  When not compiling, does nothing.</div><div class="library-member-doc-line"> </div><div class="library-member-doc-line">  In all subsequent sections taking types, the primitive types can be</div><div class="library-member-doc-line">  referred to by their Java names (int, float etc), and classes in the</div><div class="library-member-doc-line">  java.lang package can be used without a package qualifier. All other</div><div class="library-member-doc-line">  classes must be fully qualified.</div><div class="library-member-doc-line"> </div><div class="library-member-doc-line">  Options should be a set of key/value pairs, all except for :name are</div><div class="library-member-doc-line">  optional:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :name aname</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The package-qualified name of the class to be generated</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :extends [interface ...]</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  One or more interfaces, which will be extended by this interface.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :methods [ [name [param-types] return-type], ...]</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  This parameter is used to specify the signatures of the methods of</div><div class="library-member-doc-line">  the generated interface.  Do not repeat superinterface signatures</div><div class="library-member-doc-line">  here.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/gensym">gensym</h2><span id="var-type">fn</span><pre id="var-usage">([] [prefix-string])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new symbol with a unique name. If a prefix string is</div><div class="library-member-doc-line">  supplied, the name is prefix# where # is some unique number. If</div><div class="library-member-doc-line">  prefix is not supplied, the prefix is &apos;G__&apos;.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get">get</h2><span id="var-type">fn</span><pre id="var-usage">([map key] [map key not-found])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the value mapped to key, not-found or nil if key not present.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get-in">get-in</h2><span id="var-type">fn</span><pre id="var-usage">([m ks] [m ks not-found])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the value in a nested associative structure,</div><div class="library-member-doc-line">  where ks is a sequence of ke(ys. Returns nil if the key is not present,</div><div class="library-member-doc-line">  or the not-found value if supplied.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get-method">get-method</h2><span id="var-type">fn</span><pre id="var-usage">([multifn dispatch-val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Given a multimethod and a dispatch value, returns the dispatch fn</div><div class="library-member-doc-line">  that would apply to that value, or nil if none apply and no default</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get-proxy-class">get-proxy-class</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; bases])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes an optional single class followed by zero or more</div><div class="library-member-doc-line">  interfaces. If not supplied class defaults to Object.  Creates an</div><div class="library-member-doc-line">  returns an instance of a proxy class derived from the supplied</div><div class="library-member-doc-line">  classes. The resulting value is cached and used for any subsequent</div><div class="library-member-doc-line">  requests for the same class set. Returns a Class object.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get-thread-bindings">get-thread-bindings</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Get a map with the Var/value pairs which is currently in effect for the</div><div class="library-member-doc-line">  current thread.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/get-validator">get-validator</h2><span id="var-type">fn</span><pre id="var-usage">([iref])</pre><pre id="var-docstr"><div class="library-member-doc-line">Gets the validator-fn for a var/ref/agent/atom.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/group-by">group-by</h2><span id="var-type">fn</span><pre id="var-usage">([f coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the elements of coll keyed by the result of</div><div class="library-member-doc-line">  f on each element. The value at each key will be a vector of the</div><div class="library-member-doc-line">  corresponding elements, in the order they appeared in coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/hash">hash</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the hash code of its argument</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/hash-combine">hash-combine</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/hash-map">hash-map</h2><span id="var-type">fn</span><pre id="var-usage">([] [&amp; keyvals])</pre><pre id="var-docstr"><div class="library-member-doc-line">keyval =&gt; key val</div><div class="library-member-doc-line">  Returns a new hash map with supplied mappings.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/hash-set">hash-set</h2><span id="var-type">fn</span><pre id="var-usage">([] [&amp; keys])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new hash set with supplied keys.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/identical?">identical?</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Tests if 2 arguments are the same object</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/identity">identity</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns its argument.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/if-let">if-let</h2><span id="var-type">macro</span><pre id="var-usage">([bindings then] [bindings then else &amp; oldform])</pre><pre id="var-docstr"><div class="library-member-doc-line">bindings =&gt; binding-form test</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  If test is true, evaluates then with binding-form bound to the value of </div><div class="library-member-doc-line">  test, if not, yields else</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ifn?">ifn?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x implements IFn. Note that many data structures</div><div class="library-member-doc-line">  (e.g. sets and maps) implement IFn</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/if-not">if-not</h2><span id="var-type">macro</span><pre id="var-usage">([test then] [test then else])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates test. If logical false, evaluates and returns then expr, </div><div class="library-member-doc-line">  otherwise else expr, if supplied, else nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/import">import</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; import-symbols-or-lists])</pre><pre id="var-docstr"><div class="library-member-doc-line">import-list =&gt; (package-symbol class-name-symbols*)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  For each name in class-name-symbols, adds a mapping from name to the</div><div class="library-member-doc-line">  class named by package.name to the current namespace. Use :import in the ns</div><div class="library-member-doc-line">  macro in preference to calling this directly.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/inc">inc</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one greater than num. Does not auto-promote</div><div class="library-member-doc-line">  longs, will throw on overflow. See also: inc&apos;</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/inc&apos;">inc&apos;</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one greater than num.  Supports arbitrary precision.</div><div class="library-member-doc-line">  See also: inc</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/init-proxy">init-proxy</h2><span id="var-type">fn</span><pre id="var-usage">([proxy mappings])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a proxy instance and a map of strings (which must</div><div class="library-member-doc-line">  correspond to methods of the proxy superclass/superinterfaces) to</div><div class="library-member-doc-line">  fns (which must take arguments matching the corresponding method,</div><div class="library-member-doc-line">  plus an additional (explicit) first arg corresponding to this, and</div><div class="library-member-doc-line">  sets the proxy&apos;s fn map. Returns the proxy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/in-ns">in-ns</h2><span id="var-type">var</span><pre id="var-usage">([name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets *ns* to the namespace named by the symbol, creating it if needed.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/instance?">instance?</h2><span id="var-type">fn</span><pre id="var-usage">([c x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates x and tests if it is an instance of the class</div><div class="library-member-doc-line">   c. Returns true or false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/int">int</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to int</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/int-array">int-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of ints</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/integer?">integer?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is an integer</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/interleave">interleave</h2><span id="var-type">fn</span><pre id="var-usage">([c1 c2] [c1 c2 &amp; colls])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq of the first item in each coll, then the second etc.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/intern">intern</h2><span id="var-type">fn</span><pre id="var-usage">([ns name] [ns name val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Finds or creates a var named by the symbol name in the namespace</div><div class="library-member-doc-line">  ns (which can be a symbol or a namespace), setting its root binding</div><div class="library-member-doc-line">  to val if supplied. The namespace must exist. The var will adopt any</div><div class="library-member-doc-line">  metadata from the name symbol.  Returns the var.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/interpose">interpose</h2><span id="var-type">fn</span><pre id="var-usage">([sep coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq of the elements of coll separated by sep</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/into">into</h2><span id="var-type">fn</span><pre id="var-usage">([to from])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new coll consisting of to-coll with all of the items of</div><div class="library-member-doc-line">  from-coll conjoined.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/into-array">into-array</h2><span id="var-type">fn</span><pre id="var-usage">([aseq] [type aseq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an array with components set to the values in aseq. The array&apos;s</div><div class="library-member-doc-line">  component type is type if provided, or the type of the first value in</div><div class="library-member-doc-line">  aseq if present, or Object. All values in aseq must be compatible with</div><div class="library-member-doc-line">  the component type. Class objects for the primitive types can be obtained</div><div class="library-member-doc-line">  using, e.g., Integer/TYPE.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ints">ints</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to int[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/io!">io!</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">If an io! block occurs in a transaction, throws an</div><div class="library-member-doc-line">  IllegalStateException, else runs body in an implicit do. If the</div><div class="library-member-doc-line">  first expression in body is a literal string, will use that as the</div><div class="library-member-doc-line">  exception message.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/isa?">isa?</h2><span id="var-type">fn</span><pre id="var-usage">([child parent] [h child parent])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if (= child parent), or child is directly or indirectly derived from</div><div class="library-member-doc-line">  parent, either via a Java type inheritance relationship or a</div><div class="library-member-doc-line">  relationship established via derive. h must be a hierarchy obtained</div><div class="library-member-doc-line">  from make-hierarchy, if not supplied defaults to the global</div><div class="library-member-doc-line">  hierarchy</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/iterate">iterate</h2><span id="var-type">fn</span><pre id="var-usage">([f x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/iterator-seq">iterator-seq</h2><span id="var-type">fn</span><pre id="var-usage">([iter])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq on a java.util.Iterator. Note that most collections</div><div class="library-member-doc-line">  providing iterators implement Iterable and thus support seq directly.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/juxt">juxt</h2><span id="var-type">fn</span><pre id="var-usage">([f] [f g] [f g h] [f g h &amp; fs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a set of functions and returns a fn that is the juxtaposition</div><div class="library-member-doc-line">  of those fns.  The returned fn takes a variable number of args, and</div><div class="library-member-doc-line">  returns a vector containing the result of applying each fn to the</div><div class="library-member-doc-line">  args (left-to-right).</div><div class="library-member-doc-line">  ((juxt a b c) x) =&gt; [(a x) (b x) (c x)]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/keep">keep</h2><span id="var-type">fn</span><pre id="var-usage">([f coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the non-nil results of (f item). Note,</div><div class="library-member-doc-line">  this means false return values will be included.  f must be free of</div><div class="library-member-doc-line">  side-effects.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/keep-indexed">keep-indexed</h2><span id="var-type">fn</span><pre id="var-usage">([f coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the non-nil results of (f index item). Note,</div><div class="library-member-doc-line">  this means false return values will be included.  f must be free of</div><div class="library-member-doc-line">  side-effects.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/key">key</h2><span id="var-type">fn</span><pre id="var-usage">([e])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the key of the map entry.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/keys">keys</h2><span id="var-type">fn</span><pre id="var-usage">([map])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sequence of the map&apos;s keys.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/keyword">keyword</h2><span id="var-type">fn</span><pre id="var-usage">([name] [ns name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a Keyword with the given namespace and name.  Do not use :</div><div class="library-member-doc-line">  in the keyword strings, it will be added automatically.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/keyword?">keyword?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x is a Keyword</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/last">last</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return the last item in coll, in linear time</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/lazy-cat">lazy-cat</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; colls])</pre><pre id="var-docstr"><div class="library-member-doc-line">Expands to code which yields a lazy sequence of the concatenation</div><div class="library-member-doc-line">  of the supplied colls.  Each coll expr is not evaluated until it is</div><div class="library-member-doc-line">  needed.</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/lazy-seq">lazy-seq</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a body of expressions that returns an ISeq or nil, and yields</div><div class="library-member-doc-line">  a Seqable object that will invoke the body only the first time seq</div><div class="library-member-doc-line">  is called, and will cache the result and return it on all subsequent</div><div class="library-member-doc-line">  seq calls. Se all - realized?</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/let">let</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">binding =&gt; binding-form init-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Evaluates the exprs in a lexical context in which the symbols in</div><div class="library-member-doc-line">  the binding-forms are bound to their respective init-exprs or parts</div><div class="library-member-doc-line">  therein.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/letfn">letfn</h2><span id="var-type">macro</span><pre id="var-usage">([fnspecs &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Takes a vector of function specs and a body, and generates a set of</div><div class="library-member-doc-line">  bindings of functions to their names. All of the names are available</div><div class="library-member-doc-line">  in all of the definitions of the functions, as well as the body.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/line-seq">line-seq</h2><span id="var-type">fn</span><pre id="var-usage">([rdr])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the lines of text from rdr as a lazy sequence of strings.</div><div class="library-member-doc-line">  rdr must implement java.io.BufferedReader.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/list">list</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; items])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new list containing the items.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/list*">list*</h2><span id="var-type">fn</span><pre id="var-usage">([args] [a args] [a b args] [a b c args] [a b c d &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new list containing the items prepended to the rest, the</div><div class="library-member-doc-line">  last of which will be treated as a sequence.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/list?">list?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x implements IPersistentList</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/load">load</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; paths])</pre><pre id="var-docstr"><div class="library-member-doc-line">Loads Clojure code from resources in classpath. A path is interpreted as</div><div class="library-member-doc-line">  classpath-relative if it begins with a slash or relative to the root</div><div class="library-member-doc-line">  directory for the current namespace otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/loaded-libs">loaded-libs</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sorted set of symbols naming the currently loaded libs</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/load-file">load-file</h2><span id="var-type">var</span><pre id="var-usage">([name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sequentially read and evaluate the set of forms contained in the file.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/load-reader">load-reader</h2><span id="var-type">fn</span><pre id="var-usage">([rdr])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sequentially read and evaluate the set of forms contained in the</div><div class="library-member-doc-line">  stream/file</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/load-string">load-string</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sequentially read and evaluate the set of forms contained in the</div><div class="library-member-doc-line">  string</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/locking">locking</h2><span id="var-type">macro</span><pre id="var-usage">([x &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Executes exprs in an implicit do, while holding the monitor of x.</div><div class="library-member-doc-line">  Will release the monitor of x in all circumstances.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/long">long</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to long</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/long-array">long-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of longs</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/longs">longs</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to long[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/loop">loop</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates the exprs in a lexical context in which the symbols in</div><div class="library-member-doc-line">  the binding-forms are bound to their respective init-exprs or parts</div><div class="library-member-doc-line">  therein. Acts as a recur target.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/macroexpand">macroexpand</h2><span id="var-type">fn</span><pre id="var-usage">([form])</pre><pre id="var-docstr"><div class="library-member-doc-line">Repeatedly calls macroexpand-1 on form until it no longer</div><div class="library-member-doc-line">  represents a macro form, then returns it.  Note neither</div><div class="library-member-doc-line">  macroexpand-1 nor macroexpand expand macros in subforms.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/macroexpand-1">macroexpand-1</h2><span id="var-type">fn</span><pre id="var-usage">([form])</pre><pre id="var-docstr"><div class="library-member-doc-line">If form represents a macro form, returns its expansion,</div><div class="library-member-doc-line">  else returns form.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/make-array">make-array</h2><span id="var-type">fn</span><pre id="var-usage">([type len] [type dim &amp; more-dims])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates and returns an array of instances of the specified class of</div><div class="library-member-doc-line">  the specified dimension(s).  Note that a class object is required.</div><div class="library-member-doc-line">  Class objects can be obtained by using their imported or</div><div class="library-member-doc-line">  fully-qualified name.  Class objects for the primitive types can be</div><div class="library-member-doc-line">  obtained using, e.g., Integer/TYPE.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/make-hierarchy">make-hierarchy</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a hierarchy object for use with derive, isa? etc.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/map">map</h2><span id="var-type">fn</span><pre id="var-usage">([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp; colls])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence consisting of the result of applying f to the</div><div class="library-member-doc-line">  set of first items of each coll, followed by applying f to the set</div><div class="library-member-doc-line">  of second items in each coll, until any one of the colls is</div><div class="library-member-doc-line">  exhausted.  Any remaining items in other colls are ignored. Function</div><div class="library-member-doc-line">  f should accept number-of-colls arguments.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/map?">map?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x implements IPersistentMap</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/mapcat">mapcat</h2><span id="var-type">fn</span><pre id="var-usage">([f &amp; colls])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the result of applying concat to the result of applying map</div><div class="library-member-doc-line">  to f and colls.  Thus function f should return a collection.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/map-indexed">map-indexed</h2><span id="var-type">fn</span><pre id="var-usage">([f coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence consisting of the result of applying f to 0</div><div class="library-member-doc-line">  and the first item of coll, followed by applying f to 1 and the second</div><div class="library-member-doc-line">  item in coll, etc, until coll is exhausted. Thus function f should</div><div class="library-member-doc-line">  accept 2 arguments, index and item.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/max">max</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the greatest of the nums.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/max-key">max-key</h2><span id="var-type">fn</span><pre id="var-usage">([k x] [k x y] [k x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the x for which (k x), a number, is greatest.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/memfn">memfn</h2><span id="var-type">macro</span><pre id="var-usage">([name &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Expands into code that creates a fn that expects to be passed an</div><div class="library-member-doc-line">  object and any args and calls the named instance method on the</div><div class="library-member-doc-line">  object passing the args. Use when you want to treat a Java method as</div><div class="library-member-doc-line">  a first-class fn.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/memoize">memoize</h2><span id="var-type">fn</span><pre id="var-usage">([f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a memoized version of a referentially transparent function. The</div><div class="library-member-doc-line">  memoized version of the function keeps a cache of the mapping from arguments</div><div class="library-member-doc-line">  to results and, when calls with the same arguments are repeated often, has</div><div class="library-member-doc-line">  higher performance at the expense of higher memory use.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/merge">merge</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; maps])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map that consists of the rest of the maps conj-ed onto</div><div class="library-member-doc-line">  the first.  If a key occurs in more than one map, the mapping from</div><div class="library-member-doc-line">  the latter (left-to-right) will be the mapping in the result.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/merge-with">merge-with</h2><span id="var-type">fn</span><pre id="var-usage">([f &amp; maps])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map that consists of the rest of the maps conj-ed onto</div><div class="library-member-doc-line">  the first.  If a key occurs in more than one map, the mapping(s)</div><div class="library-member-doc-line">  from the latter (left-to-right) will be combined with the mapping in</div><div class="library-member-doc-line">  the result by calling (f val-in-result val-in-latter).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/meta">meta</h2><span id="var-type">fn</span><pre id="var-usage">([obj])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the metadata of obj, returns nil if there is no metadata.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/methods">methods</h2><span id="var-type">fn</span><pre id="var-usage">([multifn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Given a multimethod, returns a map of dispatch values -&gt; dispatch fns</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/method-sig">method-sig</h2><span id="var-type">fn</span><pre id="var-usage">([meth])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/min">min</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the least of the nums.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/min-key">min-key</h2><span id="var-type">fn</span><pre id="var-usage">([k x] [k x y] [k x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the x for which (k x), a number, is least.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/mod">mod</h2><span id="var-type">fn</span><pre id="var-usage">([num div])</pre><pre id="var-docstr"><div class="library-member-doc-line">Modulus of num and div. Truncates toward negative infinity.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/munge">munge</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/name">name</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the name String of a string, symbol or keyword.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/namespace">namespace</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the namespace String of a symbol or keyword, or nil if not present.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/namespace-munge">namespace-munge</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Convert a Clojure namespace name to a legal Java package name.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/neg?">neg?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if num is less than zero, else false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/newline">newline</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Writes a platform-specific newline to *out*</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/next">next</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq of the items after the first. Calls seq on its</div><div class="library-member-doc-line">  argument.  If there are no more items, returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nfirst">nfirst</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (next(first x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nil?">nil?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is nil, false otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nnext">nnext</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (next (next x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/not">not</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is logical false, false otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/not=">not=</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x y] [x y &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (not (= obj1 obj2))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/not-any?">not-any?</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns false if (pred x) is logical true for any x in coll,</div><div class="library-member-doc-line">  else true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/not-empty">not-empty</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">If coll is empty, returns nil, else coll</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/not-every?">not-every?</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns false if (pred x) is logical true for every x in</div><div class="library-member-doc-line">  coll, else true.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns">ns</h2><span id="var-type">macro</span><pre id="var-usage">([name docstring? attr-map? references*])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets *ns* to the namespace named by name (unevaluated), creating it</div><div class="library-member-doc-line">  if needed.  references can be zero or more of: (:refer-clojure ...)</div><div class="library-member-doc-line">  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)</div><div class="library-member-doc-line">  with the syntax of refer-clojure/require/use/import/load/gen-class</div><div class="library-member-doc-line">  respectively, except the arguments are unevaluated and need not be</div><div class="library-member-doc-line">  quoted. (:gen-class ...), when supplied, defaults to :name</div><div class="library-member-doc-line">  corresponding to the ns name, :main true, :impl-ns same as ns, and</div><div class="library-member-doc-line">  :init-impl-ns true. All options of gen-class are</div><div class="library-member-doc-line">  supported. The :gen-class directive is ignored when not</div><div class="library-member-doc-line">  compiling. If :gen-class is not supplied, when compiled only an</div><div class="library-member-doc-line">  nsname__init.class will be generated. If :refer-clojure is not used, a</div><div class="library-member-doc-line">  default (refer &apos;clojure) is used.  Use of ns is preferred to</div><div class="library-member-doc-line">  individual calls to in-ns/require/use/import:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (ns foo.bar</div><div class="library-member-doc-line">    (:refer-clojure :exclude [ancestors printf])</div><div class="library-member-doc-line">    (:require (clojure.contrib sql sql.tests))</div><div class="library-member-doc-line">    (:use (my.lib this that))</div><div class="library-member-doc-line">    (:import (java.util Date Timer Random)</div><div class="library-member-doc-line">              (java.sql Connection Statement)))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-aliases">ns-aliases</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the aliases for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-imports">ns-imports</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the import mappings for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-interns">ns-interns</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the intern mappings for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-map">ns-map</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of all the mappings for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-name">ns-name</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the name of the namespace, a symbol.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-publics">ns-publics</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the public intern mappings for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-refers">ns-refers</h2><span id="var-type">fn</span><pre id="var-usage">([ns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map of the refer mappings for the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-resolve">ns-resolve</h2><span id="var-type">fn</span><pre id="var-usage">([ns sym] [ns env sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the var or Class to which a symbol will be resolved in the</div><div class="library-member-doc-line">  namespace (unless found in the environment), else nil.  Note that </div><div class="library-member-doc-line">  if the symbol is fully qualified, the var/Class to which it resolves </div><div class="library-member-doc-line">  need not be present in the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-unalias">ns-unalias</h2><span id="var-type">fn</span><pre id="var-usage">([ns sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes the alias for the symbol from the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ns-unmap">ns-unmap</h2><span id="var-type">fn</span><pre id="var-usage">([ns sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes the mappings for the symbol from the namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nth">nth</h2><span id="var-type">fn</span><pre id="var-usage">([coll index] [coll index not-found])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the value at the index. get returns nil if index out of</div><div class="library-member-doc-line">  bounds, nth throws an exception unless not-found is supplied.  nth</div><div class="library-member-doc-line">  also works for strings, Java arrays, regex Matchers and Lists, and,</div><div class="library-member-doc-line">  in O(n) time, for sequences.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nthnext">nthnext</h2><span id="var-type">fn</span><pre id="var-usage">([coll n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the nth next of coll, (seq coll) when n is 0.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/nthrest">nthrest</h2><span id="var-type">fn</span><pre id="var-usage">([coll n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the nth rest of coll, coll when n is 0.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/num">num</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to Number</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/number?">number?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is a Number</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/numerator">numerator</h2><span id="var-type">fn</span><pre id="var-usage">([r])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the numerator part of a Ratio.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/object-array">object-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of objects</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/odd?">odd?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is odd, throws an exception if n is not an integer</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/or">or</h2><span id="var-type">macro</span><pre id="var-usage">([] [x] [x &amp; next])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates exprs one at a time, from left to right. If a form</div><div class="library-member-doc-line">  returns a logical true value, or returns that value and doesn&apos;t</div><div class="library-member-doc-line">  evaluate any of the other expressions, otherwise it returns the</div><div class="library-member-doc-line">  value of the last expression. (or) returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/parents">parents</h2><span id="var-type">fn</span><pre id="var-usage">([tag] [h tag])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the immediate parents of tag, either via a Java type</div><div class="library-member-doc-line">  inheritance relationship or a relationship established via derive. h</div><div class="library-member-doc-line">  must be a hierarchy obtained from make-hierarchy, if not supplied</div><div class="library-member-doc-line">  defaults to the global hierarchy</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/partial">partial</h2><span id="var-type">fn</span><pre id="var-usage">([f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a function f and fewer than the normal arguments to f, and</div><div class="library-member-doc-line">  returns a fn that takes a variable number of additional args. When</div><div class="library-member-doc-line">  called, the returned function calls f with args + additional args.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/partition">partition</h2><span id="var-type">fn</span><pre id="var-usage">([n coll] [n step coll] [n step pad coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of lists of n items each, at offsets step</div><div class="library-member-doc-line">  apart. If step is not supplied, defaults to n, i.e. the partitions</div><div class="library-member-doc-line">  do not overlap. If a pad collection is supplied, use its elements as</div><div class="library-member-doc-line">  necessary to complete last partition upto n items. In case there are</div><div class="library-member-doc-line">  not enough padding elements, return a partition with less than n items.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/partition-all">partition-all</h2><span id="var-type">fn</span><pre id="var-usage">([n coll] [n step coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of lists like partition, but may include</div><div class="library-member-doc-line">  partitions with fewer than n items at the end.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/partition-by">partition-by</h2><span id="var-type">fn</span><pre id="var-usage">([f coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Applies f to each value in coll, splitting it each time f returns</div><div class="library-member-doc-line">   a new value.  Returns a lazy seq of partitions.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pcalls">pcalls</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; fns])</pre><pre id="var-docstr"><div class="library-member-doc-line">Executes the no-arg fns in parallel, returning a lazy sequence of</div><div class="library-member-doc-line">  their values</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/peek">peek</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">For a list or queue, same as first, for a vector, same as, but much</div><div class="library-member-doc-line">  more efficient than, last. If the collection is empty, returns nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/persistent!">persistent!</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Returns a new, persistent version of the transient collection, in</div><div class="library-member-doc-line">  constant time. The transient collection cannot be used after this</div><div class="library-member-doc-line">  call, any such use will throw an exception.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pmap">pmap</h2><span id="var-type">fn</span><pre id="var-usage">([f coll] [f coll &amp; colls])</pre><pre id="var-docstr"><div class="library-member-doc-line">Like map, except f is applied in parallel. Semi-lazy in that the</div><div class="library-member-doc-line">  parallel computation stays ahead of the consumption, but doesn&apos;t</div><div class="library-member-doc-line">  realize the entire result unless required. Only useful for</div><div class="library-member-doc-line">  computationally intensive functions where the time of f dominates</div><div class="library-member-doc-line">  the coordination overhead.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pop">pop</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">For a list or queue, returns a new list/queue without the first</div><div class="library-member-doc-line">  item, for a vector, returns a new vector without the last item. If</div><div class="library-member-doc-line">  the collection is empty, throws an exception.  Note - not the same</div><div class="library-member-doc-line">  as next/butlast.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pop!">pop!</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Removes the last item from a transient vector. If</div><div class="library-member-doc-line">  the collection is empty, throws an exception. Returns coll</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pop-thread-bindings">pop-thread-bindings</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Pop one set of bindings pushed with push-binding before. It is an error to</div><div class="library-member-doc-line">  pop bindings without pushing before.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pos?">pos?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if num is greater than zero, else false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pr">pr</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x &amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Prints the object(s) to the output stream that is the current value</div><div class="library-member-doc-line">  of *out*.  Prints the object(s), separated by spaces if there is</div><div class="library-member-doc-line">  more than one.  By default, pr and prn print in a way that objects</div><div class="library-member-doc-line">  can be read by the reader</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/prefer-method">prefer-method</h2><span id="var-type">fn</span><pre id="var-usage">([multifn dispatch-val-x dispatch-val-y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y </div><div class="library-member-doc-line">   when there is a conflict</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/prefers">prefers</h2><span id="var-type">fn</span><pre id="var-usage">([multifn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Given a multimethod, returns a map of preferred value -&gt; set of other values</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/primitives-classnames">primitives-classnames</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print">print</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Prints the object(s) to the output stream that is the current value</div><div class="library-member-doc-line">  of *out*.  print and println produce output for human consumption.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print-ctor">print-ctor</h2><span id="var-type">fn</span><pre id="var-usage">([o print-args w])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print-dup">print-dup</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/printf">printf</h2><span id="var-type">fn</span><pre id="var-usage">([fmt &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Prints formatted output, as per format</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/println">println</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as print followed by (newline)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/println-str">println-str</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">println to a string, returning it</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print-method">print-method</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print-simple">print-simple</h2><span id="var-type">fn</span><pre id="var-usage">([o w])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/print-str">print-str</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">print to a string, returning it</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/prn">prn</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; more])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as pr followed by (newline). Observes *flush-on-newline*</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/prn-str">prn-str</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">prn to a string, returning it</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/promise">promise</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Returns a promise object that can be read with deref/@, and set,</div><div class="library-member-doc-line">  once only, with deliver. Calls to deref/@ prior to delivery will</div><div class="library-member-doc-line">  block, unless the variant of deref with timeout is used. All</div><div class="library-member-doc-line">  subsequent derefs will return the same delivered value without</div><div class="library-member-doc-line">  blocking. See also - realized?.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/proxy">proxy</h2><span id="var-type">macro</span><pre id="var-usage">([class-and-interfaces args &amp; fs])</pre><pre id="var-docstr"><div class="library-member-doc-line">class-and-interfaces - a vector of class names</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  args - a (possibly empty) vector of arguments to the superclass</div><div class="library-member-doc-line">  constructor.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  f =&gt; (name [params*] body) or</div><div class="library-member-doc-line">  (name ([params*] body) ([params+] body) ...)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Expands to code which creates a instance of a proxy class that</div><div class="library-member-doc-line">  implements the named class/interface(s) by calling the supplied</div><div class="library-member-doc-line">  fns. A single class, if provided, must be first. If not provided it</div><div class="library-member-doc-line">  defaults to Object.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The interfaces names must be valid interface types. If a method fn</div><div class="library-member-doc-line">  is not provided for a class method, the superclass methd will be</div><div class="library-member-doc-line">  called. If a method fn is not provided for an interface method, an</div><div class="library-member-doc-line">  UnsupportedOperationException will be thrown should it be</div><div class="library-member-doc-line">  called. Method fns are closures and can capture the environment in</div><div class="library-member-doc-line">  which proxy is called. Each method fn takes an additional implicit</div><div class="library-member-doc-line">  first arg, which is bound to &apos;this. Note that while method fns can</div><div class="library-member-doc-line">  be provided to override protected methods, they have no other access</div><div class="library-member-doc-line">  to protected members, nor to super, as these capabilities cannot be</div><div class="library-member-doc-line">  proxied.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/proxy-call-with-super">proxy-call-with-super</h2><span id="var-type">fn</span><pre id="var-usage">([call this meth])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/proxy-mappings">proxy-mappings</h2><span id="var-type">fn</span><pre id="var-usage">([proxy])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a proxy instance and returns the proxy&apos;s fn map.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/proxy-name">proxy-name</h2><span id="var-type">fn</span><pre id="var-usage">([super interfaces])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/proxy-super">proxy-super</h2><span id="var-type">macro</span><pre id="var-usage">([meth &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Use to call a superclass method in the body of a proxy method. </div><div class="library-member-doc-line">  Note, expansion captures &apos;this</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pr-str">pr-str</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">pr to a string, returning it</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/push-thread-bindings">push-thread-bindings</h2><span id="var-type">fn</span><pre id="var-usage">([bindings])</pre><pre id="var-docstr"><div class="library-member-doc-line">WARNING: This is a low-level function. Prefer high-level macros like</div><div class="library-member-doc-line">  binding where ever possible.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Takes a map of Var/value pairs. Binds each Var to the associated value for</div><div class="library-member-doc-line">  the current thread. Each call *MUST* be accompanied by a matching call to</div><div class="library-member-doc-line">  pop-thread-bindings wrapped in a try-finally!</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">      (push-thread-bindings bindings)</div><div class="library-member-doc-line">      (try</div><div class="library-member-doc-line">        ...</div><div class="library-member-doc-line">        (finally</div><div class="library-member-doc-line">          (pop-thread-bindings)))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/pvalues">pvalues</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; exprs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the values of the exprs, which are</div><div class="library-member-doc-line">  evaluated in parallel</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/quot">quot</h2><span id="var-type">fn</span><pre id="var-usage">([num div])</pre><pre id="var-docstr"><div class="library-member-doc-line">quot[ient] of dividing numerator by denominator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rand">rand</h2><span id="var-type">fn</span><pre id="var-usage">([] [n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a random floating point number between 0 (inclusive) and</div><div class="library-member-doc-line">  n (default 1) (exclusive).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rand-int">rand-int</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a random integer between 0 (inclusive) and n (exclusive).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rand-nth">rand-nth</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return a random element of the (sequential) collection. Will have</div><div class="library-member-doc-line">  the same performance characteristics as nth for the given</div><div class="library-member-doc-line">  collection.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/range">range</h2><span id="var-type">fn</span><pre id="var-usage">([] [end] [start end] [start end step])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq of nums from start (inclusive) to end</div><div class="library-member-doc-line">  (exclusive), by step, where start defaults to 0 and step to 1, and end</div><div class="library-member-doc-line">  to infinity.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ratio?">ratio?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is a Ratio</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rational?">rational?</h2><span id="var-type">fn</span><pre id="var-usage">([n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if n is a rational number</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rationalize">rationalize</h2><span id="var-type">fn</span><pre id="var-usage">([num])</pre><pre id="var-docstr"><div class="library-member-doc-line">returns the rational value of num</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/read">read</h2><span id="var-type">fn</span><pre id="var-usage">([] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?])</pre><pre id="var-docstr"><div class="library-member-doc-line">Reads the next object from stream, which must be an instance of</div><div class="library-member-doc-line">  java.io.PushbackReader or some derivee.  stream defaults to the</div><div class="library-member-doc-line">  current value of *in* .</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/read-line">read-line</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Reads the next line from stream that is the current value of *in* .</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/read-string">read-string</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Reads one object from the string s</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/realized?">realized?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if a value has been produced for a promise, delay, future or lazy sequence.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reduce">reduce</h2><span id="var-type">fn</span><pre id="var-usage">([f coll] [f val coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">f should be a function of 2 arguments. If val is not supplied,</div><div class="library-member-doc-line">  returns the result of applying f to the first 2 items in coll, then</div><div class="library-member-doc-line">  applying f to that result and the 3rd item, etc. If coll contains no</div><div class="library-member-doc-line">  items, f must accept no arguments as well, and reduce returns the</div><div class="library-member-doc-line">  result of calling f with no arguments.  If coll has only 1 item, it</div><div class="library-member-doc-line">  is returned and f is not called.  If val is supplied, returns the</div><div class="library-member-doc-line">  result of applying f to val and the first item in coll, then</div><div class="library-member-doc-line">  applying f to that result and the 2nd item, etc. If coll contains no</div><div class="library-member-doc-line">  items, returns val and f is not called.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reductions">reductions</h2><span id="var-type">fn</span><pre id="var-usage">([f coll] [f init coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq of the intermediate values of the reduction (as</div><div class="library-member-doc-line">  per reduce) of coll by f, starting with init.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ref">ref</h2><span id="var-type">fn</span><pre id="var-usage">([x] [x &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates and returns a Ref with an initial value of x and zero or</div><div class="library-member-doc-line">  more options (in any order):</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :meta metadata-map</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :validator validate-fn</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :min-history (default 0)</div><div class="library-member-doc-line">  :max-history (default 10)</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  If metadata-map is supplied, it will be come the metadata on the</div><div class="library-member-doc-line">  ref. validate-fn must be nil or a side-effect-free fn of one</div><div class="library-member-doc-line">  argument, which will be passed the intended new state on any state</div><div class="library-member-doc-line">  change. If the new state is unacceptable, the validate-fn should</div><div class="library-member-doc-line">  return false or throw an exception. validate-fn will be called on</div><div class="library-member-doc-line">  transaction commit, when all refs have their final values.</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Normally refs accumulate history dynamically as needed to deal with</div><div class="library-member-doc-line">  read demands.  If you know in advance you will need a history you can</div><div class="library-member-doc-line">  set :min-history to ensure that it will be available when first needed (instead</div><div class="library-member-doc-line">  of after a read fault).   History is limited and the limit can be set</div><div class="library-member-doc-line">  with :max-history.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/refer">refer</h2><span id="var-type">fn</span><pre id="var-usage">([ns-sym &amp; filters])</pre><pre id="var-docstr"><div class="library-member-doc-line">refers to all public vars of ns, subject to filters.</div><div class="library-member-doc-line">  filters can include at most one each of:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  :exclude list-of-symbols</div><div class="library-member-doc-line">  :only list-of-symbols</div><div class="library-member-doc-line">  :rename map-of-fromsymbol-tosymbol</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  For each public interned var in the namespace named by the symbol,</div><div class="library-member-doc-line">  adds a mapping from the name of the var to the var to the current</div><div class="library-member-doc-line">  namespace.  Throws an exception if name is already mapped to</div><div class="library-member-doc-line">  something else in the current namespace. Filters can be used to</div><div class="library-member-doc-line">  select a subset, via inclusion or exclusion, or to provide a mapping</div><div class="library-member-doc-line">  to a symbol different from the var&apos;s name, in order to prevent</div><div class="library-member-doc-line">  clashes. Use :use in the ns macro in preference to calling this directly.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/refer-clojure">refer-clojure</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; filters])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (refer &apos;clojure.core &lt;filters&gt;)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ref-history-count">ref-history-count</h2><span id="var-type">fn</span><pre id="var-usage">([ref])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the history count of a ref</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-find">re-find</h2><span id="var-type">fn</span><pre id="var-usage">([m] [re s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the next regex match, if any, of string to pattern, using</div><div class="library-member-doc-line">  java.util.regex.Matcher.find().  Uses re-groups to return the</div><div class="library-member-doc-line">  groups.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ref-max-history">ref-max-history</h2><span id="var-type">fn</span><pre id="var-usage">([ref] [ref n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Gets the max-history of a ref, or sets it and returns the ref</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ref-min-history">ref-min-history</h2><span id="var-type">fn</span><pre id="var-usage">([ref] [ref n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Gets the min-history of a ref, or sets it and returns the ref</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ref-set">ref-set</h2><span id="var-type">fn</span><pre id="var-usage">([ref val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Must be called in a transaction. Sets the value of ref.</div><div class="library-member-doc-line">  Returns val.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-groups">re-groups</h2><span id="var-type">fn</span><pre id="var-usage">([m])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the groups from the most recent match/find. If there are no</div><div class="library-member-doc-line">  nested groups, returns a string of the entire match. If there are</div><div class="library-member-doc-line">  nested groups, returns a vector of the groups, the first element</div><div class="library-member-doc-line">  being the entire match.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reify">reify</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; opts+specs])</pre><pre id="var-docstr"><div class="library-member-doc-line">reify is a macro with the following structure:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line"> (reify options* specs*)</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  Currently there are no options.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Each spec consists of the protocol or interface name followed by zero</div><div class="library-member-doc-line">  or more method bodies:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  protocol-or-interface-or-Object</div><div class="library-member-doc-line">  (methodName [args+] body)*</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Methods should be supplied for all methods of the desired</div><div class="library-member-doc-line">  protocol(s) and interface(s). You can also define overrides for</div><div class="library-member-doc-line">  methods of Object. Note that the first parameter must be supplied to</div><div class="library-member-doc-line">  correspond to the target object (&apos;this&apos; in Java parlance). Thus</div><div class="library-member-doc-line">  methods for interfaces will take one more argument than do the</div><div class="library-member-doc-line">  interface declarations.  Note also that recur calls to the method</div><div class="library-member-doc-line">  head should *not* pass the target object, it will be supplied</div><div class="library-member-doc-line">  automatically and can not be substituted.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The return type can be indicated by a type hint on the method name,</div><div class="library-member-doc-line">  and arg types can be indicated by a type hint on arg names. If you</div><div class="library-member-doc-line">  leave out all hints, reify will try to match on same name/arity</div><div class="library-member-doc-line">  method in the protocol(s)/interface(s) - this is preferred. If you</div><div class="library-member-doc-line">  supply any hints at all, no inference is done, so all hints (or</div><div class="library-member-doc-line">  default of Object) must be correct, for both arguments and return</div><div class="library-member-doc-line">  type. If a method is overloaded in a protocol/interface, multiple</div><div class="library-member-doc-line">  independent method definitions must be supplied.  If overloaded with</div><div class="library-member-doc-line">  same arity in an interface you must specify complete hints to</div><div class="library-member-doc-line">  disambiguate - a missing hint implies Object.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  recur works to method heads The method bodies of reify are lexical</div><div class="library-member-doc-line">  closures, and can refer to the surrounding local scope:</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  (str (let [f &quot;foo&quot;] </div><div class="library-member-doc-line">       (reify Object </div><div class="library-member-doc-line">         (toString [this] f))))</div><div class="library-member-doc-line">  == &quot;foo&quot;</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (seq (let [f &quot;foo&quot;] </div><div class="library-member-doc-line">       (reify clojure.lang.Seqable </div><div class="library-member-doc-line">         (seq [this] (seq f)))))</div><div class="library-member-doc-line">  == (\f \o \o))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/release-pending-sends">release-pending-sends</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Normally, actions sent directly or indirectly during another action</div><div class="library-member-doc-line">  are held until the action completes (changes the agent&apos;s</div><div class="library-member-doc-line">  state). This function can be used to dispatch any pending sent</div><div class="library-member-doc-line">  actions immediately. This has no impact on actions sent during a</div><div class="library-member-doc-line">  transaction, which are still held until commit. If no action is</div><div class="library-member-doc-line">  occurring, does nothing. Returns the number of actions dispatched.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rem">rem</h2><span id="var-type">fn</span><pre id="var-usage">([num div])</pre><pre id="var-docstr"><div class="library-member-doc-line">remainder of dividing numerator by denominator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-matcher">re-matcher</h2><span id="var-type">fn</span><pre id="var-usage">([re s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an instance of java.util.regex.Matcher, for use, e.g. in</div><div class="library-member-doc-line">  re-find.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-matches">re-matches</h2><span id="var-type">fn</span><pre id="var-usage">([re s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the match, if any, of string to pattern, using</div><div class="library-member-doc-line">  java.util.regex.Matcher.matches().  Uses re-groups to return the</div><div class="library-member-doc-line">  groups.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/remove">remove</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the items in coll for which</div><div class="library-member-doc-line">  (pred item) returns false. pred must be free of side-effects.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/remove-all-methods">remove-all-methods</h2><span id="var-type">fn</span><pre id="var-usage">([multifn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes all of the methods of multimethod.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/remove-method">remove-method</h2><span id="var-type">fn</span><pre id="var-usage">([multifn dispatch-val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes the method of multimethod associated	with dispatch-value.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/remove-ns">remove-ns</h2><span id="var-type">fn</span><pre id="var-usage">([sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes the namespace named by the symbol. Use with caution.</div><div class="library-member-doc-line">  Cannot be used to remove the clojure namespace.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/remove-watch">remove-watch</h2><span id="var-type">fn</span><pre id="var-usage">([reference key])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Removes a watch (set by add-watch) from a reference</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-pattern">re-pattern</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an instance of java.util.regex.Pattern, for use, e.g. in</div><div class="library-member-doc-line">  re-matcher.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/repeat">repeat</h2><span id="var-type">fn</span><pre id="var-usage">([x] [n x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy (infinite! or length n if supplied) sequence of xs.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/repeatedly">repeatedly</h2><span id="var-type">fn</span><pre id="var-usage">([f] [n f])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a function of no args, presumably with side effects, and</div><div class="library-member-doc-line">  returns an infinite (or length n if supplied) lazy sequence of calls</div><div class="library-member-doc-line">  to it</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/replace">replace</h2><span id="var-type">fn</span><pre id="var-usage">([smap coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Given a map of replacement pairs and a vector/collection, returns a</div><div class="library-member-doc-line">  vector/seq with any elements = a key in smap replaced with the</div><div class="library-member-doc-line">  corresponding val in smap</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/replicate">replicate</h2><span id="var-type">fn</span><pre id="var-usage">([n x])</pre><pre id="var-docstr"><div class="library-member-doc-line">DEPRECATED: Use &apos;repeat&apos; instead.</div><div class="library-member-doc-line">  Returns a lazy seq of n xs.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/require">require</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Loads libs, skipping any that are already loaded. Each argument is</div><div class="library-member-doc-line">  either a libspec that identifies a lib, a prefix list that identifies</div><div class="library-member-doc-line">  multiple libs whose names share a common prefix, or a flag that modifies</div><div class="library-member-doc-line">  how all the identified libs are loaded. Use :require in the ns macro</div><div class="library-member-doc-line">  in preference to calling this directly.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Libs</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  A &apos;lib&apos; is a named set of resources in classpath whose contents define a</div><div class="library-member-doc-line">  library of Clojure code. Lib names are symbols and each lib is associated</div><div class="library-member-doc-line">  with a Clojure namespace and a Java package that share its name. A lib&apos;s</div><div class="library-member-doc-line">  name also locates its root directory within classpath using Java&apos;s</div><div class="library-member-doc-line">  package name to classpath-relative path mapping. All resources in a lib</div><div class="library-member-doc-line">  should be contained in the directory structure under its root directory.</div><div class="library-member-doc-line">  All definitions a lib makes should be in its associated namespace.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  &apos;require loads a lib by loading its root resource. The root resource path</div><div class="library-member-doc-line">  is derived from the lib name in the following manner:</div><div class="library-member-doc-line">  Consider a lib named by the symbol &apos;x.y.z; it has the root directory</div><div class="library-member-doc-line">  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root</div><div class="library-member-doc-line">  resource should contain code to create the lib&apos;s namespace (usually by using</div><div class="library-member-doc-line">  the ns macro) and load any additional lib resources. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Libspecs</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  A libspec is a lib name or a vector containing a lib name followed by</div><div class="library-member-doc-line">  options expressed as sequential keywords and arguments.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Recognized options: :as</div><div class="library-member-doc-line">  :as takes a symbol as its argument and makes that symbol an alias to the</div><div class="library-member-doc-line">    lib&apos;s namespace in the current namespace.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Prefix Lists</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  It&apos;s common for Clojure code to depend on several libs whose names have</div><div class="library-member-doc-line">  the same prefix. When specifying libs, prefix lists can be used to reduce</div><div class="library-member-doc-line">  repetition. A prefix list contains the shared prefix followed by libspecs</div><div class="library-member-doc-line">  with the shared prefix removed from the lib names. After removing the</div><div class="library-member-doc-line">  prefix, the names that remain must not contain any periods.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Flags</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  A flag is a keyword.</div><div class="library-member-doc-line">  Recognized flags: :reload, :reload-all, :verbose</div><div class="library-member-doc-line">  :reload forces loading of all the identified libs even if they are</div><div class="library-member-doc-line">    already loaded</div><div class="library-member-doc-line">  :reload-all implies :reload and also forces loading of all libs that the</div><div class="library-member-doc-line">    identified libs directly or indirectly load via require or use</div><div class="library-member-doc-line">  :verbose triggers printing information about each load, alias, and refer</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Example:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The following would load the libraries clojure.zip and clojure.set</div><div class="library-member-doc-line">  abbreviated as &apos;s&apos;.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (require &apos;(clojure zip [set :as s]))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/re-seq">re-seq</h2><span id="var-type">fn</span><pre id="var-usage">([re s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of successive matches of pattern in string,</div><div class="library-member-doc-line">  using java.util.regex.Matcher.find(), each such match processed with</div><div class="library-member-doc-line">  re-groups.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reset!">reset!</h2><span id="var-type">fn</span><pre id="var-usage">([atom newval])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value of atom to newval without regard for the</div><div class="library-member-doc-line">  current value. Returns newval.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reset-meta!">reset-meta!</h2><span id="var-type">fn</span><pre id="var-usage">([iref metadata-map])</pre><pre id="var-docstr"><div class="library-member-doc-line">Atomically resets the metadata for a namespace/var/ref/agent/atom</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/-reset-methods">-reset-methods</h2><span id="var-type">fn</span><pre id="var-usage">([protocol])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/resolve">resolve</h2><span id="var-type">fn</span><pre id="var-usage">([sym] [env sym])</pre><pre id="var-docstr"><div class="library-member-doc-line">same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rest">rest</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a possibly empty seq of the items after the first. Calls seq on its</div><div class="library-member-doc-line">  argument.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/restart-agent">restart-agent</h2><span id="var-type">fn</span><pre id="var-usage">([a new-state &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">When an agent is failed, changes the agent state to new-state and</div><div class="library-member-doc-line">  then un-fails the agent so that sends are allowed again.  If</div><div class="library-member-doc-line">  a :clear-actions true option is given, any actions queued on the</div><div class="library-member-doc-line">  agent that were being held while it was failed will be discarded,</div><div class="library-member-doc-line">  otherwise those held actions will proceed.  The new-state must pass</div><div class="library-member-doc-line">  the validator if any, or restart will throw an exception and the</div><div class="library-member-doc-line">  agent will remain failed with its old state and error.  Watchers, if</div><div class="library-member-doc-line">  any, will NOT be notified of the new state.  Throws an exception if</div><div class="library-member-doc-line">  the agent is not failed.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reverse">reverse</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq of the items in coll in reverse order. Not lazy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/reversible?">reversible?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll implements Reversible</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rseq">rseq</h2><span id="var-type">fn</span><pre id="var-usage">([rev])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns, in constant time, a seq of the items in rev (which</div><div class="library-member-doc-line">  can be a vector or sorted-map), in reverse order. If rev is empty returns nil</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/rsubseq">rsubseq</h2><span id="var-type">fn</span><pre id="var-usage">([sc test key] [sc start-test start-key end-test end-key])</pre><pre id="var-docstr"><div class="library-member-doc-line">sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or</div><div class="library-member-doc-line">  &gt;=. Returns a reverse seq of those entries with keys ek for</div><div class="library-member-doc-line">  which (test (.. sc comparator (compare ek key)) 0) is true</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/satisfies?">satisfies?</h2><span id="var-type">fn</span><pre id="var-usage">([protocol x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x satisfies the protocol</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sbyte">sbyte</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to sbyte</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/second">second</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Same as (first (next x))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/select-keys">select-keys</h2><span id="var-type">fn</span><pre id="var-usage">([map keyseq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map containing only those entries in map whose key is in keys</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/send">send</h2><span id="var-type">fn</span><pre id="var-usage">([a f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Dispatch an action to an agent. Returns the agent immediately.</div><div class="library-member-doc-line">  Subsequently, in a thread from a thread pool, the state of the agent</div><div class="library-member-doc-line">  will be set to the value of:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply action-fn state-of-agent args)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/send-off">send-off</h2><span id="var-type">fn</span><pre id="var-usage">([a f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Dispatch a potentially blocking action to an agent. Returns the</div><div class="library-member-doc-line">  agent immediately. Subsequently, in a separate thread, the state of</div><div class="library-member-doc-line">  the agent will be set to the value of:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  (apply action-fn state-of-agent args)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/seq">seq</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq on the collection. If the collection is </div><div class="library-member-doc-line">    empty, returns nil.  (seq nil) returns nil. seq also works on </div><div class="library-member-doc-line">    Strings, native Java arrays (of reference types) and any objects </div><div class="library-member-doc-line">    that implement Iterable.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/seq?">seq?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x implements ISeq</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sequence">sequence</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerces coll to a (possibly empty) sequence, if it is not already</div><div class="library-member-doc-line">  one. Will not force a lazy seq. (sequence nil) yields ()</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sequential?">sequential?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll implements Sequential</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/set">set</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a set of the distinct elements of coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/set?">set?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x implements IPersistentSet</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/set-error-handler!">set-error-handler!</h2><span id="var-type">fn</span><pre id="var-usage">([a handler-fn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the error-handler of agent a to handler-fn.  If an action</div><div class="library-member-doc-line">  being run by the agent throws an exception or doesn&apos;t pass the</div><div class="library-member-doc-line">  validator fn, handler-fn will be called with two arguments: the</div><div class="library-member-doc-line">  agent and the exception.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/set-error-mode!">set-error-mode!</h2><span id="var-type">fn</span><pre id="var-usage">([a mode-keyword])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the error-mode of agent a to mode-keyword, which must be</div><div class="library-member-doc-line">  either :fail or :continue.  If an action being run by the agent</div><div class="library-member-doc-line">  throws an exception or doesn&apos;t pass the validator fn, an</div><div class="library-member-doc-line">  error-handler may be called (see set-error-handler!), after which,</div><div class="library-member-doc-line">  if the mode is :continue, the agent will continue as if neither the</div><div class="library-member-doc-line">  action that caused the error nor the error itself ever happened.</div><div class="library-member-doc-line">  </div><div class="library-member-doc-line">  If the mode is :fail, the agent will become failed and will stop</div><div class="library-member-doc-line">  accepting new &apos;send&apos; and &apos;send-off&apos; actions, and any previously</div><div class="library-member-doc-line">  queued actions will be held until a &apos;restart-agent&apos;.  Deref will</div><div class="library-member-doc-line">  still work, returning the state of the agent before the error.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/set-validator">set-validator</h2><span id="var-type">fn</span><pre id="var-usage">([iref validator-fn])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a</div><div class="library-member-doc-line">  side-effect-free fn of one argument, which will be passed the intended</div><div class="library-member-doc-line">  new state on any state change. If the new state is unacceptable, the</div><div class="library-member-doc-line">  validator-fn should return false or throw an exception. If the current state (root</div><div class="library-member-doc-line">  value if var) is not acceptable to the new validator, an exception</div><div class="library-member-doc-line">  will be thrown and the validator will not be changed.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/short">short</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to short</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/short-array">short-array</h2><span id="var-type">fn</span><pre id="var-usage">([size-or-seq] [size init-val-or-seq])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates an array of shorts</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/shorts">shorts</h2><span id="var-type">fn</span><pre id="var-usage">([xs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Casts to shorts[]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/shutdown-agents">shutdown-agents</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Initiates a shutdown of the thread pools that back the agent</div><div class="library-member-doc-line">  system. Running actions will complete, but no new actions will be</div><div class="library-member-doc-line">  accepted</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/slurp">slurp</h2><span id="var-type">fn</span><pre id="var-usage">([f &amp; opts])</pre><pre id="var-docstr"><div class="library-member-doc-line">Opens a reader on f and reads all its contents, returning a string.</div><div class="library-member-doc-line">  See clojure.java.io/reader for a complete list of supported arguments.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/some">some</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the first logical true value of (pred x) for any x in coll,</div><div class="library-member-doc-line">  else nil.  One common idiom is to use a set as pred, for example</div><div class="library-member-doc-line">  this will return :fred if :fred is in the sequence, otherwise nil:</div><div class="library-member-doc-line">  (some #{:fred} coll)</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/some-fn">some-fn</h2><span id="var-type">fn</span><pre id="var-usage">([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 &amp; ps])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a set of predicates and returns a function f that returns the first logical true value</div><div class="library-member-doc-line">  returned by one of its composing predicates against any of its arguments, else it returns</div><div class="library-member-doc-line">  logical false. Note that f is short-circuiting in that it will stop execution on the first</div><div class="library-member-doc-line">  argument that triggers a logical true result against the original predicates.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sort">sort</h2><span id="var-type">fn</span><pre id="var-usage">([coll] [comp coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sorted sequence of the items in coll. If no comparator is</div><div class="library-member-doc-line">  supplied, uses compare. comparator must</div><div class="library-member-doc-line">  implement java.util.Comparator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sort-by">sort-by</h2><span id="var-type">fn</span><pre id="var-usage">([keyfn coll] [keyfn comp coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sorted sequence of the items in coll, where the sort</div><div class="library-member-doc-line">  order is determined by comparing (keyfn item).  If no comparator is</div><div class="library-member-doc-line">  supplied, uses compare. comparator must</div><div class="library-member-doc-line">  implement java.util.Comparator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sorted?">sorted?</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if coll implements Sorted</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sorted-map">sorted-map</h2><span id="var-type">fn</span><pre id="var-usage">([] [&amp; keyvals])</pre><pre id="var-docstr"><div class="library-member-doc-line">keyval =&gt; key val</div><div class="library-member-doc-line">  Returns a new sorted map with supplied mappings.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sorted-map-by">sorted-map-by</h2><span id="var-type">fn</span><pre id="var-usage">([comparator &amp; keyvals])</pre><pre id="var-docstr"><div class="library-member-doc-line">keyval =&gt; key val</div><div class="library-member-doc-line">  Returns a new sorted map with supplied mappings, using the supplied comparator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sorted-set">sorted-set</h2><span id="var-type">fn</span><pre id="var-usage">([] [&amp; keys])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new sorted set with supplied keys.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sorted-set-by">sorted-set-by</h2><span id="var-type">fn</span><pre id="var-usage">([comparator &amp; keys])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new sorted set with supplied keys, using the supplied comparator.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/special-symbol?">special-symbol?</h2><span id="var-type">fn</span><pre id="var-usage">([s])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if s names a special form</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/spit">spit</h2><span id="var-type">fn</span><pre id="var-usage">([f content &amp; options])</pre><pre id="var-docstr"><div class="library-member-doc-line">Opposite of slurp.  Opens f with writer, writes content, then</div><div class="library-member-doc-line">  closes f.  Options passed to clojure.java.io/writer.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/split-at">split-at</h2><span id="var-type">fn</span><pre id="var-usage">([n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a vector of [(take n coll) (drop n coll)]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/split-with">split-with</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a vector of [(take-while pred coll) (drop-while pred coll)]</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/str">str</h2><span id="var-type">fn</span><pre id="var-usage">([] [x] [x &amp; ys])</pre><pre id="var-docstr"><div class="library-member-doc-line">With no args, returns the empty string. With one arg x, returns</div><div class="library-member-doc-line">  x.toString().  (str nil) returns the empty string. With more than</div><div class="library-member-doc-line">  one arg, returns the concatenation of the str values of the args.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/string?">string?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x is a String</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/struct">struct</h2><span id="var-type">fn</span><pre id="var-usage">([s &amp; vals])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new structmap instance with the keys of the</div><div class="library-member-doc-line">  structure-basis. vals must be supplied for basis keys in order -</div><div class="library-member-doc-line">  where values are not supplied they will default to nil.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/struct-map">struct-map</h2><span id="var-type">fn</span><pre id="var-usage">([s &amp; inits])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a new structmap instance with the keys of the</div><div class="library-member-doc-line">  structure-basis. keyvals may contain all, some or none of the basis</div><div class="library-member-doc-line">  keys - where values are not supplied they will default to nil.</div><div class="library-member-doc-line">  keyvals can also contain keys not in the basis.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/subs">subs</h2><span id="var-type">fn</span><pre id="var-usage">([s start] [s start end])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the substring of s beginning at start inclusive, and ending</div><div class="library-member-doc-line">  at end (defaults to length of string), exclusive.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/subseq">subseq</h2><span id="var-type">fn</span><pre id="var-usage">([sc test key] [sc start-test start-key end-test end-key])</pre><pre id="var-docstr"><div class="library-member-doc-line">sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or</div><div class="library-member-doc-line">  &gt;=. Returns a seq of those entries with keys ek for</div><div class="library-member-doc-line">  which (test (.. sc comparator (compare ek key)) 0) is true</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/subvec">subvec</h2><span id="var-type">fn</span><pre id="var-usage">([v start] [v start end])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a persistent vector of the items in vector from</div><div class="library-member-doc-line">  start (inclusive) to end (exclusive).  If end is not supplied,</div><div class="library-member-doc-line">  defaults to (count vector). This operation is O(1) and very fast, as</div><div class="library-member-doc-line">  the resulting vector shares structure with the original and no</div><div class="library-member-doc-line">  trimming is done.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/supers">supers</h2><span id="var-type">fn</span><pre id="var-usage">([class])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the immediate and indirect superclasses and interfaces of c, if any</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/swap!">swap!</h2><span id="var-type">fn</span><pre id="var-usage">([atom f] [atom f x] [atom f x y] [atom f x y &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Atomically swaps the value of atom to be:</div><div class="library-member-doc-line">  (apply f current-value-of-atom args). Note that f may be called</div><div class="library-member-doc-line">  multiple times, and thus should be free of side effects.  Returns</div><div class="library-member-doc-line">  the value that was swapped in.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/symbol">symbol</h2><span id="var-type">fn</span><pre id="var-usage">([name] [ns name])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a Symbol with the given namespace and name.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/symbol?">symbol?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x is a Symbol</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sync">sync</h2><span id="var-type">macro</span><pre id="var-usage">([flags-ignored-for-now &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">transaction-flags =&gt; TBD, pass nil for now</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Runs the exprs (in an implicit do) in a transaction that encompasses</div><div class="library-member-doc-line">  exprs and any nested calls.  Starts a transaction if none is already</div><div class="library-member-doc-line">  running on this thread. Any uncaught exception will abort the</div><div class="library-member-doc-line">  transaction and flow out of sync. The exprs may be run more than</div><div class="library-member-doc-line">  once, but any effects on Refs will be atomic.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sys-action">sys-action</h2><span id="var-type">macro</span><pre id="var-usage">([typesyms &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Translates to a gen-delegate for a System.Action&lt;,...&gt; call</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/sys-func">sys-func</h2><span id="var-type">macro</span><pre id="var-usage">([typesyms &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Translates to a gen-delegate for a System.Func&lt;,...&gt; call</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/take">take</h2><span id="var-type">fn</span><pre id="var-usage">([n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the first n items in coll, or all items if</div><div class="library-member-doc-line">  there are fewer than n.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/take-last">take-last</h2><span id="var-type">fn</span><pre id="var-usage">([n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a seq of the last n items in coll.  Depending on the type</div><div class="library-member-doc-line">  of coll may be no better than linear time.  For vectors, see also subvec.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/take-nth">take-nth</h2><span id="var-type">fn</span><pre id="var-usage">([n coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy seq of every nth item in coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/take-while">take-while</h2><span id="var-type">fn</span><pre id="var-usage">([pred coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of successive items from coll while</div><div class="library-member-doc-line">  (pred item) returns true. pred must be free of side-effects.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/test">test</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"><div class="library-member-doc-line">test [v] finds fn at key :test in var metadata and calls it,</div><div class="library-member-doc-line">  presuming failure will throw exception</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/the-ns">the-ns</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">If passed a namespace, returns it. Else, when passed a symbol,</div><div class="library-member-doc-line">  returns the namespace named by it, throwing an exception if not</div><div class="library-member-doc-line">  found.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/thread-bound?">thread-bound?</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; vars])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if all of the vars provided as arguments have thread-local bindings.</div><div class="library-member-doc-line">   Implies that set!&apos;ing the provided vars will succeed.  Returns true if no vars are provided.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/time">time</h2><span id="var-type">macro</span><pre id="var-usage">([expr])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates expr and prints the time it took.  Returns the value of</div><div class="library-member-doc-line"> expr.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/to-array">to-array</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an array of Objects containing the contents of coll, which</div><div class="library-member-doc-line">  can be any Collection.  Maps to java.util.Collection.toArray().</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/to-array-2d">to-array-2d</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a (potentially-ragged) 2-dimensional array of Objects</div><div class="library-member-doc-line">  containing the contents of coll, which can be any Collection of any</div><div class="library-member-doc-line">  Collection.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/trampoline">trampoline</h2><span id="var-type">fn</span><pre id="var-usage">([f] [f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">trampoline can be used to convert algorithms requiring mutual</div><div class="library-member-doc-line">  recursion without stack consumption. Calls f with supplied args, if</div><div class="library-member-doc-line">  any. If f returns a fn, calls that fn with no arguments, and</div><div class="library-member-doc-line">  continues to repeat, until the return value is not a fn, then</div><div class="library-member-doc-line">  returns that non-fn value. Note that if you want to return a fn as a</div><div class="library-member-doc-line">  final value, you must wrap it in some data structure and unpack it</div><div class="library-member-doc-line">  after trampoline returns.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/transient">transient</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">  Returns a new, transient version of the collection, in constant time.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/tree-seq">tree-seq</h2><span id="var-type">fn</span><pre id="var-usage">([branch? children root])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a lazy sequence of the nodes in a tree, via a depth-first walk.</div><div class="library-member-doc-line">   branch? must be a fn of one arg that returns true if passed a node</div><div class="library-member-doc-line">   that can have children (but may not).  children must be a fn of one</div><div class="library-member-doc-line">   arg that returns a sequence of the children. Will only be called on</div><div class="library-member-doc-line">   nodes for which branch? returns true. Root is the root node of the</div><div class="library-member-doc-line">  tree.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/true?">true?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if x is the value true, false otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/type">type</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the :type metadata of x, or its Class if none</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/type-args">type-args</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"><div class="library-member-doc-line">Supplies type arguments to a generic method interop call</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Should only be used in CLR interop code.  Throws an exception otherwise.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/uint">uint</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to uint</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ulong">ulong</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to ulong</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-add">unchecked-add</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the sum of x and y, both long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-add-int">unchecked-add-int</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the sum of x and y, both int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-byte">unchecked-byte</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to byte. Subject to rounding or truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-char">unchecked-char</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to char. Subject to rounding or truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-dec">unchecked-dec</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one less than x, a long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-dec-int">unchecked-dec-int</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one less than x, an int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-divide-int">unchecked-divide-int</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the division of x by y, both int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-double">unchecked-double</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to double. Subject to rounding.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-float">unchecked-float</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to float. Subject to rounding.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-inc">unchecked-inc</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one greater than x, a long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-inc-int">unchecked-inc-int</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a number one greater than x, an int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-int">unchecked-int</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to int. Subject to rounding or truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-long">unchecked-long</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to long. Subject to rounding or truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-multiply">unchecked-multiply</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the product of x and y, both long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-multiply-int">unchecked-multiply-int</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the product of x and y, both int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-negate">unchecked-negate</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the negation of x, a long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-negate-int">unchecked-negate-int</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the negation of x, an int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-remainder-int">unchecked-remainder-int</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the remainder of division of x by y, both int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-short">unchecked-short</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to short. Subject to rounding or truncation.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-subtract">unchecked-subtract</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the difference of x and y, both long.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unchecked-subtract-int">unchecked-subtract-int</h2><span id="var-type">fn</span><pre id="var-usage">([x y])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the difference of x and y, both int.</div><div class="library-member-doc-line">  Note - uses a primitive operator subject to overflow.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/underive">underive</h2><span id="var-type">fn</span><pre id="var-usage">([tag parent] [h tag parent])</pre><pre id="var-docstr"><div class="library-member-doc-line">Removes a parent/child relationship between parent and</div><div class="library-member-doc-line">  tag. h must be a hierarchy obtained from make-hierarchy, if not</div><div class="library-member-doc-line">  supplied defaults to, and modifies, the global hierarchy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unquote">unquote</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/unquote-splicing">unquote-splicing</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/update-in">update-in</h2><span id="var-type">fn</span><pre id="var-usage">([m [k &amp; ks] f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">&apos;Updates&apos; a value in a nested associative structure, where ks is a</div><div class="library-member-doc-line">  sequence of keys and f is a function that will take the old value</div><div class="library-member-doc-line">  and any supplied args and return the new value, and returns a new</div><div class="library-member-doc-line">  nested structure.  If any levels do not exist, hash-maps will be</div><div class="library-member-doc-line">  created.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/update-proxy">update-proxy</h2><span id="var-type">fn</span><pre id="var-usage">([proxy mappings])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a proxy instance and a map of strings (which must</div><div class="library-member-doc-line">  correspond to methods of the proxy superclass/superinterfaces) to</div><div class="library-member-doc-line">  fns (which must take arguments matching the corresponding method,</div><div class="library-member-doc-line">  plus an additional (explicit) first arg corresponding to this, and</div><div class="library-member-doc-line">  updates (via assoc) the proxy&apos;s fn map. nil can be passed instead of</div><div class="library-member-doc-line">  a fn, in which case the corresponding method will revert to the</div><div class="library-member-doc-line">  default behavior. Note that this function can be used to update the</div><div class="library-member-doc-line">  behavior of an existing instance without changing its identity.</div><div class="library-member-doc-line">  Returns the proxy.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/use">use</h2><span id="var-type">fn</span><pre id="var-usage">([&amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Like &apos;require, but also refers to each lib&apos;s namespace using</div><div class="library-member-doc-line">  clojure.core/refer. Use :use in the ns macro in preference to calling</div><div class="library-member-doc-line">  this directly.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  &apos;use accepts additional options in libspecs: :exclude, :only, :rename.</div><div class="library-member-doc-line">  The arguments and semantics for :exclude, :only, and :rename are the same</div><div class="library-member-doc-line">  as those documented for clojure.core/refer.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/ushort">ushort</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Coerce to ushort</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/val">val</h2><span id="var-type">fn</span><pre id="var-usage">([e])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the value in the map entry.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vals">vals</h2><span id="var-type">fn</span><pre id="var-usage">([map])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a sequence of the map&apos;s values.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/var?">var?</h2><span id="var-type">fn</span><pre id="var-usage">([v])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if v is of type clojure.lang.Var</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/var-get">var-get</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Gets the value in the var object</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/var-set">var-set</h2><span id="var-type">fn</span><pre id="var-usage">([x val])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the value in the var object to val. The var must be</div><div class="library-member-doc-line"> thread-locally bound.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vary-meta">vary-meta</h2><span id="var-type">fn</span><pre id="var-usage">([obj f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an object of the same type and value as obj, with</div><div class="library-member-doc-line">  (apply f (meta obj) args) as its metadata.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vec">vec</h2><span id="var-type">fn</span><pre id="var-usage">([coll])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new vector containing the contents of coll.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vector">vector</h2><span id="var-type">fn</span><pre id="var-usage">([] [a] [a b] [a b c] [a b c d] [a b c d &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new vector containing the args.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vector?">vector?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Return true if x implements IPersistentVector </div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/vector-of">vector-of</h2><span id="var-type">fn</span><pre id="var-usage">([t] [t &amp; elements])</pre><pre id="var-docstr"><div class="library-member-doc-line">Creates a new vector of a single primitive type t, where t is one</div><div class="library-member-doc-line">  of :int :long :float :double :byte :short :char or :boolean. The</div><div class="library-member-doc-line">  resulting vector complies with the interface of vectors in general,</div><div class="library-member-doc-line">  but stores the values unboxed internally.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Optionally takes one or more elements to populate the vector.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/when">when</h2><span id="var-type">macro</span><pre id="var-usage">([test &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates test. If logical true, evaluates body in an implicit do.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/when-first">when-first</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">bindings =&gt; x xs</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Same as (when (seq xs) (let [x (first xs)] body))</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/when-let">when-let</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">bindings =&gt; binding-form test</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  When test is true, evaluates body with binding-form bound to the value of test</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/when-not">when-not</h2><span id="var-type">macro</span><pre id="var-usage">([test &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates test. If logical false, evaluates body in an implicit do.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/while">while</h2><span id="var-type">macro</span><pre id="var-usage">([test &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Repeatedly executes body while test expression is true. Presumes</div><div class="library-member-doc-line">  some side-effect will cause test to become false/nil. Returns nil</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-bindings">with-bindings</h2><span id="var-type">macro</span><pre id="var-usage">([binding-map &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a map of Var/value pairs. Installs for the given Vars the associated</div><div class="library-member-doc-line">  values as thread-local bindings. The executes body. Pops the installed</div><div class="library-member-doc-line">  bindings after body was evaluated. Returns the value of body.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-bindings*">with-bindings*</h2><span id="var-type">fn</span><pre id="var-usage">([binding-map f &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Takes a map of Var/value pairs. Installs for the given Vars the associated</div><div class="library-member-doc-line">  values as thread-local bindings. Then calls f with the supplied arguments.</div><div class="library-member-doc-line">  Pops the installed bindings after f returned. Returns whatever f returns.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-in-str">with-in-str</h2><span id="var-type">macro</span><pre id="var-usage">([s &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates body in a context in which *in* is bound to a fresh</div><div class="library-member-doc-line">  StringReader initialized with the string s.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-loading-context">with-loading-context</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-local-vars">with-local-vars</h2><span id="var-type">macro</span><pre id="var-usage">([name-vals-vec &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">varbinding=&gt; symbol init-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Executes the exprs in a context in which the symbols are bound to</div><div class="library-member-doc-line">  vars with per-thread bindings to the init-exprs.  The symbols refer</div><div class="library-member-doc-line">  to the var objects themselves, and must be accessed with var-get and</div><div class="library-member-doc-line">  var-set</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-meta">with-meta</h2><span id="var-type">fn</span><pre id="var-usage">([obj m])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns an object of the same type and value as obj, with</div><div class="library-member-doc-line">    map m as its metadata.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-open">with-open</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">bindings =&gt; name init</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Evaluates body in a try expression with names bound to the values</div><div class="library-member-doc-line">  of the inits, and a finally clause that calls (.close name) on each</div><div class="library-member-doc-line">  name in reverse order.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-out-str">with-out-str</h2><span id="var-type">macro</span><pre id="var-usage">([&amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Evaluates exprs in a context in which *out* is bound to a fresh</div><div class="library-member-doc-line">  StringWriter.  Returns the string created by any nested printing</div><div class="library-member-doc-line">  calls.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-precision">with-precision</h2><span id="var-type">macro</span><pre id="var-usage">([precision &amp; exprs])</pre><pre id="var-docstr"><div class="library-member-doc-line">Sets the precision and rounding mode to be used for BigDecimal operations.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Usage: (with-precision 10 (/ 1M 3))</div><div class="library-member-doc-line">  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,</div><div class="library-member-doc-line">  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-redefs">with-redefs</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">binding =&gt; var-symbol temp-value-expr</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  Temporarily redefines Vars while executing the body.  The</div><div class="library-member-doc-line">  temp-value-exprs will be evaluated and each resulting value will</div><div class="library-member-doc-line">  replace in parallel the root value of its Var.  After the body is</div><div class="library-member-doc-line">  executed, the root values of all the Vars will be set back to their</div><div class="library-member-doc-line">  old values.  These temporary changes will be visible in all threads.</div><div class="library-member-doc-line">  Useful for mocking out functions during testing.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/with-redefs-fn">with-redefs-fn</h2><span id="var-type">fn</span><pre id="var-usage">([binding-map func])</pre><pre id="var-docstr"><div class="library-member-doc-line">Temporarily redefines Vars during a call to func.  Each val of</div><div class="library-member-doc-line">  binding-map will replace the root value of its key which must be</div><div class="library-member-doc-line">  a Var.  After func is called with no args, the root values of all</div><div class="library-member-doc-line">  the Vars will be set back to their old values.  These temporary</div><div class="library-member-doc-line">  changes will be visible in all threads.  Useful for mocking out</div><div class="library-member-doc-line">  functions during testing.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/xml-seq">xml-seq</h2><span id="var-type">fn</span><pre id="var-usage">([root])</pre><pre id="var-docstr"><div class="library-member-doc-line">A tree seq on the xml elements as per xml/parse</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/zero?">zero?</h2><span id="var-type">fn</span><pre id="var-usage">([x])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns true if num is zero, else false</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.core/zipmap">zipmap</h2><span id="var-type">fn</span><pre id="var-usage">([keys vals])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns a map with the keys mapped to the corresponding vals.</div></pre></div></div></div></div></div></div></div></div></body></html>