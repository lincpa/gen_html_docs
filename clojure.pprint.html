<html xmlns="http://www.w3.org/1999/xhtml"><head><title>clojure.pprint - Clojure-clr v1.3 API Documentation</title><link href="http://clojure.github.com/clojure/static/favicon.png" rel="shortcut icon"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/clojure.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/wiki.css" rel="stylesheet"/><link media="all" type="text/css" href="http://clojure.github.com/clojure/static/internal.css" rel="stylesheet"/><link media="all" type="text/css" href="http://rippinrobr.github.com/gen_html_docs/clr.css" rel="stylesheet"/></head><body><div id="AllContentContainer"><div id="Header"><a id="Logo" href="index.html"><img alt="Clojure-clr" height="100" width="100" src="http://richhickey.github.com/clojure-contrib/static/clojure-icon.gif"/></a><h1><a title="page header title" id="page-header" href="index.html">Clojure-clr API Reference</a></h1></div><div id="leftcolumn"><div/><div class="menu"><div class="WikiCustomNav WikiElement wiki"><span class="toc-header"><span id="project-name">Clojure-clr v</span><span id="version">1.3</span></span><br/><ul><li><a class="wiki_link" href="index.html">Overview</a></li><li><a class="wiki_link" href="api-index.html">API Index</a></li></ul><div class="NamespaceTOC"><span class="toc-header">Namespaces</span><ul id="left-sidebar-list"><li><a href="clojure.clr.io.html" class="wiki_link">clojure.clr.io</a></li><li><a href="clojure.clr.shell.html" class="wiki_link">clojure.clr.shell</a></li><li><a href="clojure.contrib.gen-html-docs.html" class="wiki_link">clojure.contrib.gen-html-docs</a></li><li><a href="clojure.core.html" class="wiki_link">clojure.core</a></li><li><a href="clojure.pprint.html" class="wiki_link">clojure.pprint</a></li><li><a href="clojure.reflect.html" class="wiki_link">clojure.reflect</a></li><li><a href="clojure.string.html" class="wiki_link">clojure.string</a></li><li><a href="clojure.test-helper.html" class="wiki_link">clojure.test-helper</a></li></ul></div></div></div></div></div><div id="rightcolumn"><div id="Content"><div class="contentBox"><div class="innerContentBox"><div id="content_view" class="wiki wikiPage"><div id="right-sidebar"><div id="toc"><h1 class="nopad">Table of Contents</h1><div style="margin-left: 1em;" class="toc-section"><a href="#toc0">Overview</a><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-base*">*print-base*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-miser-width*">*print-miser-width*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-pprint-dispatch*">*print-pprint-dispatch*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-pretty*">*print-pretty*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-radix*">*print-radix*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-right-margin*">*print-right-margin*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/*print-suppress-namespaces*">*print-suppress-namespaces*</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/cl-format">cl-format</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/code-dispatch">code-dispatch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/formatter">formatter</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/formatter-out">formatter-out</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/fresh-line">fresh-line</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/get-pretty-writer">get-pretty-writer</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pp">pp</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pprint">pprint</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pprint-indent">pprint-indent</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pprint-logical-block">pprint-logical-block</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pprint-newline">pprint-newline</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/pprint-tab">pprint-tab</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/print-length-loop">print-length-loop</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/print-table">print-table</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/set-pprint-dispatch">set-pprint-dispatch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/simple-dispatch">simple-dispatch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/with-pprint-dispatch">with-pprint-dispatch</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/write">write</a></div><div style="margin-left: 1em;" class="toc-entry"><a href="#clojure.pprint/write-out">write-out</a></div></div></div></div><div id="content-tag"><h1 id="overview">API for <span id="namespace-name">clojure.pprint - Clojure-clr v1.3</span></h1><span id="author">by Tom Faulhaber</span><H4 style="margin-top: 1em;">Usage: </H4><pre>(ns your-namespace
   (:require clojure.pprint))</pre><h2>Overview</h2><pre id="namespace-docstr">A Pretty Printer for Clojure

clojure.pprint implements a flexible system for printing structured data
in a pleasing, easy-to-understand format. Basic use of the pretty printer is 
simple, just call pprint instead of println. More advanced users can use 
the building blocks provided to create custom output formats. 

Out of the box, pprint supports a simple structured format for basic data 
and a specialized format for Clojure source code. More advanced formats, 
including formats that don&apos;t look like Clojure data at all like XML and 
JSON, can be rendered by creating custom dispatch functions. 

In addition to the pprint function, this module contains cl-format, a text 
formatting function which is fully compatible with the format function in 
Common Lisp. Because pretty printing directives are directly integrated with
cl-format, it supports very concise custom dispatch. It also provides
a more powerful alternative to Clojure&apos;s standard format function.

See documentation for pprint and cl-format for more information or 
complete documentation on the the clojure web site on github.</pre><br/><h2>Public Variables and Functions</h2><div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-base*">*print-base*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The base to use for printing integers and rationals.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-miser-width*">*print-miser-width*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The column at which to enter miser style. Depending on the dispatch table, </div><div class="library-member-doc-line">miser style add newlines in more places to try to keep lines short allowing for further </div><div class="library-member-doc-line">levels of nesting.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-pprint-dispatch*">*print-pprint-dispatch*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch</div><div class="library-member-doc-line">to modify.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-pretty*">*print-pretty*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Bind to true if you want write to use pretty printing</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-radix*">*print-radix*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, </div><div class="library-member-doc-line">or 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the </div><div class="library-member-doc-line">radix specifier is in the form #XXr where XX is the decimal value of *print-base* </div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-right-margin*">*print-right-margin*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Pretty printing will try to avoid anything going beyond this column.</div><div class="library-member-doc-line">Set it to nil to have pprint let the line be arbitrarily long. This will ignore all </div><div class="library-member-doc-line">non-mandatory newlines.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/*print-suppress-namespaces*">*print-suppress-namespaces*</h2><span id="var-type">var</span><pre id="var-usage"></pre><pre id="var-docstr"><div class="library-member-doc-line">Don&apos;t print namespaces with symbols. This is particularly useful when </div><div class="library-member-doc-line">pretty printing the results of macro expansions</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/cl-format">cl-format</h2><span id="var-type">fn</span><pre id="var-usage">([writer format-in &amp; args])</pre><pre id="var-docstr"><div class="library-member-doc-line">An implementation of a Common Lisp compatible format function. cl-format formats its</div><div class="library-member-doc-line">arguments to an output stream or string based on the format control string given. It </div><div class="library-member-doc-line">supports sophisticated formatting of structured data.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Writer is an instance of java.io.Writer, true to output to *out* or nil to output </div><div class="library-member-doc-line">to a string, format-in is the format control string and the remaining arguments </div><div class="library-member-doc-line">are the data to be formatted.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">The format control string is a string to be output with embedded &apos;format directives&apos; </div><div class="library-member-doc-line">describing how to format the various arguments passed in.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format </div><div class="library-member-doc-line">returns nil.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">For example:</div><div class="library-member-doc-line"> (let [results [46 38 22]]</div><div class="library-member-doc-line">        (cl-format true &quot;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%&quot; </div><div class="library-member-doc-line">                   (count results) results))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Prints to *out*:</div><div class="library-member-doc-line"> There are 3 results: 46, 38, 22</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Detailed documentation on format control strings is available in the &quot;Common Lisp the </div><div class="library-member-doc-line">Language, 2nd edition&quot;, Chapter 22 (available online at:</div><div class="library-member-doc-line">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) </div><div class="library-member-doc-line">and in the Common Lisp HyperSpec at </div><div class="library-member-doc-line">http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/code-dispatch">code-dispatch</h2><span id="var-type">var</span><pre id="var-usage">[[object]]</pre><pre id="var-docstr"><div class="library-member-doc-line">The pretty print dispatch function for pretty printing Clojure code.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/formatter">formatter</h2><span id="var-type">macro</span><pre id="var-usage">([format-in])</pre><pre id="var-docstr"><div class="library-member-doc-line">Makes a function which can directly run format-in. The function is</div><div class="library-member-doc-line">fn [stream &amp; args] ... and returns nil unless the stream is nil (meaning </div><div class="library-member-doc-line">output to a string) in which case it returns the resulting string.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">format-in can be either a control string or a previously compiled format.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/formatter-out">formatter-out</h2><span id="var-type">macro</span><pre id="var-usage">([format-in])</pre><pre id="var-docstr"><div class="library-member-doc-line">Makes a function which can directly run format-in. The function is</div><div class="library-member-doc-line">fn [&amp; args] ... and returns nil. This version of the formatter macro is</div><div class="library-member-doc-line">designed to be used with *out* set to an appropriate Writer. In particular,</div><div class="library-member-doc-line">this is meant to be used as part of a pretty printer dispatch method.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">format-in can be either a control string or a previously compiled format.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/fresh-line">fresh-line</h2><span id="var-type">fn</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">Make a newline if *out* is not already at the beginning of the line. If *out* is</div><div class="library-member-doc-line">not a pretty writer (which keeps track of columns), this function always outputs a newline.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/get-pretty-writer">get-pretty-writer</h2><span id="var-type">fn</span><pre id="var-usage">([writer])</pre><pre id="var-docstr"><div class="library-member-doc-line">Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it&apos;s </div><div class="library-member-doc-line">already a pretty writer. Generally, it is unneccesary to call this function, since pprint,</div><div class="library-member-doc-line">write, and cl-format all call it if they need to. However if you want the state to be </div><div class="library-member-doc-line">preserved across calls, you will want to wrap them with this. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">For example, when you want to generate column-aware output with multiple calls to cl-format, </div><div class="library-member-doc-line">do it like in this example:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">    (defn print-table [aseq column-width]</div><div class="library-member-doc-line">      (binding [*out* (get-pretty-writer *out*)]</div><div class="library-member-doc-line">        (doseq [row aseq]</div><div class="library-member-doc-line">          (doseq [col row]</div><div class="library-member-doc-line">            (cl-format true &quot;~4D~7,vT&quot; col column-width))</div><div class="library-member-doc-line">          (prn))))</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Now when you run:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">    user&gt; (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">It prints a table of squares and cubes for the numbers from 1 to 10:</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">       1      1       1    </div><div class="library-member-doc-line">       2      4       8    </div><div class="library-member-doc-line">       3      9      27    </div><div class="library-member-doc-line">       4     16      64    </div><div class="library-member-doc-line">       5     25     125    </div><div class="library-member-doc-line">       6     36     216    </div><div class="library-member-doc-line">       7     49     343    </div><div class="library-member-doc-line">       8     64     512    </div><div class="library-member-doc-line">       9     81     729    </div><div class="library-member-doc-line">      10    100    1000</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pp">pp</h2><span id="var-type">macro</span><pre id="var-usage">([])</pre><pre id="var-docstr"><div class="library-member-doc-line">A convenience macro that pretty prints the last thing output. This is</div><div class="library-member-doc-line">exactly equivalent to (pprint *1).</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pprint">pprint</h2><span id="var-type">fn</span><pre id="var-usage">([object] [object writer])</pre><pre id="var-docstr"><div class="library-member-doc-line">Pretty print object to the optional output writer. If the writer is not provided, </div><div class="library-member-doc-line">print the object to the currently bound value of *out*.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pprint-indent">pprint-indent</h2><span id="var-type">fn</span><pre id="var-usage">([relative-to n])</pre><pre id="var-docstr"><div class="library-member-doc-line">Create an indent at this point in the pretty printing stream. This defines how </div><div class="library-member-doc-line">following lines are indented. relative-to can be either :block or :current depending </div><div class="library-member-doc-line">whether the indent should be computed relative to the start of the logical block or</div><div class="library-member-doc-line">the current column position. n is an offset. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">This function is intended for use when writing custom dispatch functions.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Output is sent to *out* which must be a pretty printing writer.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pprint-logical-block">pprint-logical-block</h2><span id="var-type">macro</span><pre id="var-usage">[[options* body]]</pre><pre id="var-docstr"><div class="library-member-doc-line">Execute the body as a pretty printing logical block with output to *out* which </div><div class="library-member-doc-line">must be a pretty printing writer. When used from pprint or cl-format, this can be </div><div class="library-member-doc-line">assumed. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">This function is intended for use when writing custom dispatch functions.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Before the body, the caller can optionally specify options: :prefix, :per-line-prefix, </div><div class="library-member-doc-line">and :suffix.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pprint-newline">pprint-newline</h2><span id="var-type">fn</span><pre id="var-usage">([kind])</pre><pre id="var-docstr"><div class="library-member-doc-line">Print a conditional newline to a pretty printing stream. kind specifies if the </div><div class="library-member-doc-line">newline is :linear, :miser, :fill, or :mandatory. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">This function is intended for use when writing custom dispatch functions.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Output is sent to *out* which must be a pretty printing writer.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/pprint-tab">pprint-tab</h2><span id="var-type">fn</span><pre id="var-usage">([kind colnum colinc])</pre><pre id="var-docstr"><div class="library-member-doc-line">Tab at this point in the pretty printing stream. kind specifies whether the tab</div><div class="library-member-doc-line">is :line, :section, :line-relative, or :section-relative. </div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Colnum and colinc specify the target column and the increment to move the target</div><div class="library-member-doc-line">forward if the output is already past the original target.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">This function is intended for use when writing custom dispatch functions.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">Output is sent to *out* which must be a pretty printing writer.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">THIS FUNCTION IS NOT YET IMPLEMENTED.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/print-length-loop">print-length-loop</h2><span id="var-type">macro</span><pre id="var-usage">([bindings &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">A version of loop that iterates at most *print-length* times. This is designed </div><div class="library-member-doc-line">for use in pretty-printer dispatch functions.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/print-table">print-table</h2><span id="var-type">fn</span><pre id="var-usage">([ks rows] [rows])</pre><pre id="var-docstr"><div class="library-member-doc-line">Alpha - subject to change.</div><div class="library-member-doc-line">   Prints a collection of maps in a textual table. Prints table headings</div><div class="library-member-doc-line">   ks, and then a line of output for each row, corresponding to the keys</div><div class="library-member-doc-line">   in ks. If ks are not specified, use the keys of the first item in rows.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/set-pprint-dispatch">set-pprint-dispatch</h2><span id="var-type">fn</span><pre id="var-usage">([function])</pre><pre id="var-docstr"><div class="library-member-doc-line">Set the pretty print dispatch function to a function matching (fn [obj] ...)</div><div class="library-member-doc-line">where obj is the object to pretty print. That function will be called with *out* set</div><div class="library-member-doc-line">to a pretty printing writer to which it should do its printing.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">For example functions, see simple-dispatch and code-dispatch in </div><div class="library-member-doc-line">clojure.pprint.dispatch.clj.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/simple-dispatch">simple-dispatch</h2><span id="var-type">var</span><pre id="var-usage">[[object]]</pre><pre id="var-docstr"><div class="library-member-doc-line">The pretty print dispatch function for simple data structure format.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/with-pprint-dispatch">with-pprint-dispatch</h2><span id="var-type">macro</span><pre id="var-usage">([function &amp; body])</pre><pre id="var-docstr"><div class="library-member-doc-line">Execute body with the pretty print dispatch function bound to function.</div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/write">write</h2><span id="var-type">fn</span><pre id="var-usage">([object &amp; kw-args])</pre><pre id="var-docstr"><div class="library-member-doc-line">Write an object subject to the current bindings of the printer control variables.</div><div class="library-member-doc-line">Use the kw-args argument to override individual variables for this call (and any </div><div class="library-member-doc-line">recursive calls). Returns the string result if :stream is nil or nil otherwise.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">The following keyword arguments can be passed with values:</div><div class="library-member-doc-line">  Keyword              Meaning                              Default value</div><div class="library-member-doc-line">  :stream              Writer for output or nil             true (indicates *out*)</div><div class="library-member-doc-line">  :base                Base to use for writing rationals    Current value of *print-base*</div><div class="library-member-doc-line">  :circle*             If true, mark circular structures    Current value of *print-circle*</div><div class="library-member-doc-line">  :length              Maximum elements to show in sublists Current value of *print-length*</div><div class="library-member-doc-line">  :level               Maximum depth                        Current value of *print-level*</div><div class="library-member-doc-line">  :lines*              Maximum lines of output              Current value of *print-lines*</div><div class="library-member-doc-line">  :miser-width         Width to enter miser mode            Current value of *print-miser-width*</div><div class="library-member-doc-line">  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*</div><div class="library-member-doc-line">  :pretty              If true, do pretty printing          Current value of *print-pretty*</div><div class="library-member-doc-line">  :radix               If true, prepend a radix specifier   Current value of *print-radix*</div><div class="library-member-doc-line">  :readably*           If true, print readably              Current value of *print-readably*</div><div class="library-member-doc-line">  :right-margin        The column for the right margin      Current value of *print-right-margin*</div><div class="library-member-doc-line">  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">  * = not yet supported</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div></pre></div><div id="var-entry"><br/><hr/><h2 id="clojure.pprint/write-out">write-out</h2><span id="var-type">fn</span><pre id="var-usage">([object])</pre><pre id="var-docstr"><div class="library-member-doc-line">Write an object to *out* subject to the current bindings of the printer control </div><div class="library-member-doc-line">variables. Use the kw-args argument to override individual variables for this call (and </div><div class="library-member-doc-line">any recursive calls).</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility</div><div class="library-member-doc-line">of the caller.</div><div class="library-member-doc-line"><span class="library-member-doc-whitespace"> </span></div><div class="library-member-doc-line">This method is primarily intended for use by pretty print dispatch functions that </div><div class="library-member-doc-line">already know that the pretty printer will have set up their environment appropriately.</div><div class="library-member-doc-line">Normal library clients should use the standard &quot;write&quot; interface. </div></pre></div></div></div></div></div></div></div></div></body></html>